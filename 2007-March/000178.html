<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> r193 - in branches/ha/candrv/kernel/2.6/drivers/net/can: . sja1000
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-commit/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r193%20-%20in%20branches/ha/candrv/kernel/2.6/drivers/net/can%3A%20.%20sja1000&In-Reply-To=%3C200703261415.l2QEFSxo026621%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000177.html">
   <LINK REL="Next"  HREF="000179.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>r193 - in branches/ha/candrv/kernel/2.6/drivers/net/can: . sja1000</H1>
    <B>hartkopp at mail.berlios.de</B> 
    <A HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r193%20-%20in%20branches/ha/candrv/kernel/2.6/drivers/net/can%3A%20.%20sja1000&In-Reply-To=%3C200703261415.l2QEFSxo026621%40sheep.berlios.de%3E"
       TITLE="r193 - in branches/ha/candrv/kernel/2.6/drivers/net/can: . sja1000">hartkopp at mail.berlios.de
       </A><BR>
    <I>Mon Mar 26 16:15:28 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000177.html">r192 - trunk/kernel/2.6/drivers/net/can
</A></li>
        <LI>Next message: <A HREF="000179.html">r194 - in branches/ha/candrv/kernel/2.6/drivers/net/can: hal sja1000
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#178">[ date ]</a>
              <a href="thread.html#178">[ thread ]</a>
              <a href="subject.html#178">[ subject ]</a>
              <a href="author.html#178">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hartkopp
Date: 2007-03-26 16:15:07 +0200 (Mon, 26 Mar 2007)
New Revision: 193

Added:
   branches/ha/candrv/kernel/2.6/drivers/net/can/hal/
   branches/ha/candrv/kernel/2.6/drivers/net/can/i82527/
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/gw2.c
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/hal.h
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/io.c
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/iomem.c
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/iomux.c
Removed:
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/isa.c
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/mem.c
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/trajet-gw2.c
Modified:
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/Makefile
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/proc.c
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/sja1000.c
   branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/sja1000.h
Log:
reworked sja1000 driver for hardware abstraction layer POC.


Modified: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/Makefile
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/Makefile	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/Makefile	2007-03-26 14:15:07 UTC (rev 193)
@@ -59,10 +59,11 @@
 		-DARPHRD_CAN=280
 endif
 
-obj-m := sja1000-isa.o sja1000-gw2.o sja1000-mem.o
+obj-m := sja1000-io.o sja1000-iomem.o sja1000-iomux.o sja1000-gw2.o
 
-sja1000-mem-objs := mem.o        sja1000.o proc.o
-sja1000-isa-objs := isa.o        sja1000.o proc.o
-sja1000-gw2-objs := trajet-gw2.o sja1000.o proc.o
+sja1000-io-objs    := io.o    sja1000.o proc.o
+sja1000-iomem-objs := iomem.o sja1000.o proc.o
+sja1000-iomux-objs := iomux.o sja1000.o proc.o
+sja1000-gw2-objs   := gw2.o   sja1000.o proc.o
 
 endif

Added: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/gw2.c
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/gw2.c	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/gw2.c	2007-03-26 14:15:07 UTC (rev 193)
@@ -0,0 +1,164 @@
+/*
+ * gw2.c - Trajet GW2 register access CAN hardware abstraction layer
+ *
+ * $Id$
+ *
+ * Inspired by the OCAN driver <A HREF="http://ar.linux.it/software/#ocan">http://ar.linux.it/software/#ocan</A>
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
+ *
+ */
+
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/ioport.h&gt;
+#include &lt;asm/io.h&gt;
+#include &quot;hal.h&quot;
+
+#define ADDR_GAP 1
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return &quot;gw2&quot;; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+	extern unsigned int  speed[];
+
+	base[0]		= 0xF0100200UL;
+	irq[0]		= 26;
+	speed[0]	= 500;
+
+	base[1]		= 0xF0100300UL;
+	irq[1]		= 26;
+	speed[1]	= 100;
+
+	base[2]		= 0xF0100400UL;
+	irq[2]		= 26;
+	speed[2]	= 100;
+
+	base[3]		= 0xF0100500UL;
+	irq[3]		= 26;
+	speed[3]	= 500;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	unsigned int gw2_regs = num_regs * (ADDR_GAP + 1);
+
+	/* creating the region for IOMEM is pretty easy */
+	if (!request_mem_region(base[dev_num], gw2_regs, drv_name))
+		return 0; /* failed */
+
+	/* set device base_addr */
+	rbase[dev_num] = (unsigned long)ioremap(base[dev_num], gw2_regs);
+
+	if (rbase[dev_num])
+		return 1; /* success */
+
+	/* cleanup due to failed ioremap() */
+	release_mem_region(base[dev_num], gw2_regs);
+	return 0; /* failed */
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	unsigned int gw2_regs = num_regs * (ADDR_GAP + 1);
+
+	iounmap((void *)rbase[dev_num]);
+	release_mem_region(base[dev_num], gw2_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	static u8 val;
+	void __iomem *addr = (void __iomem *)base +
+		reg * (ADDR_GAP + 1) + ADDR_GAP;
+
+	val = (u8)readw(addr);
+	rmb();
+
+        return val;
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	void __iomem *addr = (void __iomem *)base +
+		reg * (ADDR_GAP + 1) + ADDR_GAP;
+
+	writew(val, addr);
+	wmb();
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+


Property changes on: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/gw2.c
___________________________________________________________________
Name: svn:keywords
   + Id

Added: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/hal.h
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/hal.h	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/hal.h	2007-03-26 14:15:07 UTC (rev 193)
@@ -0,0 +1,100 @@
+/*
+ * hal.h - definitions for CAN controller hardware abstraction layer
+ *
+ * Inspired by the OCAN driver <A HREF="http://ar.linux.it/software/#ocan">http://ar.linux.it/software/#ocan</A>
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
+ *
+ */
+
+#ifndef CAN_HAL_H
+#define CAN_HAL_H
+
+#include &lt;linux/types.h&gt;
+#include &lt;linux/netdevice.h&gt;
+
+/* Number of supported CAN devices for each HAL (default) */
+#define MAXDEV 8
+
+/* general function prototypes for CAN HAL */
+
+/* init the HAL - call at driver module init */
+int hal_init(void);
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void);
+
+/* get name of this CAN HAL */
+char *hal_name(void);
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void);
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name);
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs);
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num);
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num);
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num);
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg);
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val);
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev);
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev);
+
+#endif /* CAN_HAL_H */


Property changes on: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/hal.h
___________________________________________________________________
Name: svn:keywords
   + Id

Added: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/io.c
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/io.c	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/io.c	2007-03-26 14:15:07 UTC (rev 193)
@@ -0,0 +1,129 @@
+/*
+ * io.c - linear register access CAN hardware abstraction layer
+ *
+ * $Id$
+ *
+ * Inspired by the OCAN driver <A HREF="http://ar.linux.it/software/#ocan">http://ar.linux.it/software/#ocan</A>
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
+ *
+ */
+
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/ioport.h&gt;
+#include &lt;asm/io.h&gt;
+#include &quot;hal.h&quot;
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return &quot;io&quot;; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+	extern unsigned int  speed[];
+
+	base[0]		= 0x2C0UL;
+	irq[0]		= 10;
+	speed[0]	= 500;
+
+	base[1]		= 0x320UL;
+	irq[1]		= 5;
+	speed[1]	= 100;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* creating the region for IO is pretty easy */
+	return (request_region(base[dev_num], num_regs, drv_name))? 1 : 0;
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	release_region(base[dev_num], num_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	return inb(base + reg);
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	outb(val, base + reg);
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+


Property changes on: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/io.c
___________________________________________________________________
Name: svn:keywords
   + Id

Added: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/iomem.c
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/iomem.c	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/iomem.c	2007-03-26 14:15:07 UTC (rev 193)
@@ -0,0 +1,144 @@
+/*
+ * iomem.c - linear register access CAN hardware abstraction layer
+ *
+ * $Id$
+ *
+ * Inspired by the OCAN driver <A HREF="http://ar.linux.it/software/#ocan">http://ar.linux.it/software/#ocan</A>
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
+ *
+ */
+
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/ioport.h&gt;
+#include &lt;asm/io.h&gt;
+#include &quot;hal.h&quot;
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return &quot;iomem&quot;; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+	extern unsigned int  speed[];
+
+	base[0]		= 0xda000UL;
+	irq[0]		= 9;
+	speed[0]	= 500;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* creating the region for IOMEM is pretty easy */
+	if (!request_mem_region(base[dev_num], num_regs, drv_name))
+		return 0; /* failed */
+
+	/* set device base_addr */
+	rbase[dev_num] = (unsigned long)ioremap(base[dev_num], num_regs);
+
+	if (rbase[dev_num])
+		return 1; /* success */
+
+	/* cleanup due to failed ioremap() */
+	release_mem_region(base[dev_num], num_regs);
+	return 0; /* failed */
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	iounmap((void *)rbase[dev_num]);
+	release_mem_region(base[dev_num], num_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	static u8 val;
+	void __iomem *addr = (void __iomem *)base + reg;
+
+	val = (u8)readw(addr);
+	rmb();
+
+        return val;
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	void __iomem *addr = (void __iomem *)base + reg;
+
+	writew(val, addr);
+	wmb();
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+


Property changes on: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/iomem.c
___________________________________________________________________
Name: svn:keywords
   + Id

Added: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/iomux.c
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/iomux.c	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/iomux.c	2007-03-26 14:15:07 UTC (rev 193)
@@ -0,0 +1,130 @@
+/*
+ * iomux.c - multiplex register access CAN hardware abstraction layer
+ *
+ * $Id$
+ *
+ * Inspired by the OCAN driver <A HREF="http://ar.linux.it/software/#ocan">http://ar.linux.it/software/#ocan</A>
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
+ *
+ */
+
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/ioport.h&gt;
+#include &lt;asm/io.h&gt;
+#include &quot;hal.h&quot;
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return &quot;iomux&quot;; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+	extern unsigned int  speed[];
+
+	base[0]		= 0x300UL;
+	irq[0]		= 5;
+	speed[0]	= 500;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* ignore num_regs and create the 2 register region:  */
+	/* address register = base / data register = base + 1 */
+	return (request_region(base[dev_num], 2, drv_name))? 1 : 0;
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	/* ignore num_regs and create the 2 register region:  */
+	/* address register = base / data register = base + 1 */
+	release_region(base[dev_num], 2);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	outb(reg, base);	/* address */
+	return inb(base + 1);	/* data */
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	outb(reg, base);	/* address */
+	outb(val, base + 1);	/* data */
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+


Property changes on: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/iomux.c
___________________________________________________________________
Name: svn:keywords
   + Id

Deleted: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/isa.c
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/isa.c	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/isa.c	2007-03-26 14:15:07 UTC (rev 193)
@@ -1,246 +0,0 @@
-/*
- * $Id$
- *
- * isa.c - Philips SJA1000 network device driver for ISA CAN-Cards
- *
- * Copyright (c) 2002-2005 Volkswagen Group Electronic Research
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, the following disclaimer and
- *    the referenced file 'COPYING'.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of Volkswagen nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * Alternatively, provided that this notice is retained in full, this
- * software may be distributed under the terms of the GNU General
- * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
- * file from the main directory of the linux kernel source.
- *
- * The provided data structures and external interfaces from this code
- * are not restricted to be used by modules with a GPL compatible license.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
- * DAMAGE.
- *
- * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
- *
- */
-
-#include &lt;linux/module.h&gt;
-#include &lt;linux/init.h&gt;
-#include &lt;linux/kernel.h&gt;
-#include &lt;linux/sched.h&gt;
-#include &lt;linux/types.h&gt;
-#include &lt;linux/fcntl.h&gt;
-#include &lt;linux/interrupt.h&gt;
-#include &lt;linux/ptrace.h&gt;
-#include &lt;linux/ioport.h&gt;
-#include &lt;linux/in.h&gt;
-#include &lt;linux/slab.h&gt;
-#include &lt;linux/string.h&gt;
-#include &lt;linux/errno.h&gt;
-#include &lt;linux/netdevice.h&gt;
-#include &lt;linux/skbuff.h&gt;
-#include &lt;asm/io.h&gt;
-
-#include &lt;linux/can.h&gt;
-#include &lt;linux/can/ioctl.h&gt; /* for struct can_device_stats */
-#include &quot;sja1000.h&quot;
-
-#define MAX_CAN		8
-#define CAN_DEV_NAME	&quot;can%d&quot;
-#define DRV_NAME        &quot;sja1000-isa&quot;
-
-#define DEFAULT_KBIT_PER_SEC 100
-#define SJA1000_HW_CLOCK 16000000
-
-/* driver and version information */
-static const char *drv_name	= DRV_NAME;
-static const char *drv_version	= &quot;0.0.10&quot;;
-static const char *drv_reldate	= &quot;2005-10-11&quot;;
-static const char *chip_name	= SJA1000_CHIP_NAME;
-
-MODULE_AUTHOR(&quot;Oliver Hartkopp &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">oliver.hartkopp at volkswagen.de</A>&gt;&quot;);
-MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);
-MODULE_DESCRIPTION(&quot;LLCF SJA1000 network device driver '&quot; DRV_NAME &quot;'&quot;);
-
-/* module parameters */
-static uint32_t base_addr[MAX_CAN] = { (uint32_t)0x2C0L, (uint32_t)0x320L, 0};
-
-static int irq[MAX_CAN] = { 10, 5, 0 };
-
-static int speed[MAX_CAN] = { DEFAULT_KBIT_PER_SEC, DEFAULT_KBIT_PER_SEC, 0};
-
-static int btr[MAX_CAN] = { 0 };
-static int rx_probe[MAX_CAN] = { 0 };
-
-static int clk = SJA1000_HW_CLOCK;
-static int debug = 0;
-static int restart_ms = 100;
-
-/* array of all can chips */
-static struct net_device	*can_dev[MAX_CAN];
-
-static int base_addr_n;
-static int irq_n;
-static int speed_n;
-static int btr_n;
-static int rx_probe_n;
-
-module_param_array(base_addr, int, &amp;base_addr_n, 0);
-module_param_array(irq, int, &amp;irq_n, 0);
-module_param_array(speed, int, &amp;speed_n, 0);
-module_param_array(btr, int, &amp;btr_n, 0);
-module_param_array(rx_probe, int, &amp;rx_probe_n, 0);
-
-module_param(clk, int, 0);
-module_param(debug, int, 0);
-module_param(restart_ms, int, 0);
-
-/* special functions to access the chips registers */
-static uint8_t reg_read(struct net_device *dev, int reg)
-{
-	return inb(dev-&gt;base_addr + reg);
-}
-
-static void reg_write(struct net_device *dev, int reg, uint8_t val)
-{
-	outb(val, dev-&gt;base_addr + reg);
-}
-
-static struct net_device* sja1000_isa_probe(uint32_t base, int irq, int speed,
-					    int btr, int rx_probe, int clk,
-					    int debug, int restart_ms)
-{
-	struct net_device	*dev;
-	struct can_priv		*priv;
-
-	if (!(dev = alloc_netdev(sizeof(struct can_priv), CAN_DEV_NAME,
-				 sja1000_setup))) {
-		printk(KERN_ERR &quot;%s: out of memory\n&quot;, chip_name);
-		return NULL;
-	}
-
-	printk(KERN_INFO &quot;%s: base 0x%X / irq %d / speed %d / btr 0x%X / rx_probe %d\n&quot;,
-	       chip_name, base, irq, speed, btr, rx_probe);
-
-	/* fill net_device structure */
-
-	priv             = netdev_priv(dev);
-
-	dev-&gt;irq         = irq;
-	dev-&gt;base_addr   = base;
-
-	priv-&gt;reg_read   = reg_read;
-	priv-&gt;reg_write  = reg_write;
-
-	priv-&gt;speed      = speed;
-	priv-&gt;btr        = btr;
-	priv-&gt;rx_probe   = rx_probe;
-	priv-&gt;clock      = clk;
-	priv-&gt;restart_ms = restart_ms;
-	priv-&gt;debug      = debug;
-
-	if (REG_READ(0) == 0xFF) {
-		printk(KERN_INFO &quot;%s: probing failed\n&quot;, chip_name);
-		goto free_dev;
-	}
-
-	if (register_netdev(dev)) {
-		printk(KERN_INFO &quot;%s: register netdev failed\n&quot;, chip_name);
-		goto free_dev;
-	}
-
-	/* set chip into reset mode */
-	set_reset_mode(dev);
-
-	/* go into Pelican mode, disable clkout, disable comparator */
-	REG_WRITE(REG_CDR, 0xCF);
-
-	/* output control */
-	/* connected to external transceiver */
-	REG_WRITE(REG_OCR, 0x1A);
-
-	printk(KERN_INFO &quot;%s: %s found at 0x%X, irq is %d\n&quot;,
-	       dev-&gt;name, chip_name, (uint32_t)dev-&gt;base_addr, dev-&gt;irq);
-
-	return dev;
-
- free_dev:
-	free_netdev(dev);
-	return NULL;
-}
-
-static __exit void sja1000_isa_cleanup_module(void)
-{
-	int i;
-
-	for (i = 0; i &lt; MAX_CAN; i++) {
-		if (can_dev[i] != NULL) {
-			struct can_priv *priv = netdev_priv(can_dev[i]);
-			unregister_netdev(can_dev[i]);
-			del_timer(&amp;priv-&gt;timer);
-			release_region(base_addr[i], SJA1000_IO_SIZE_BASIC);
-			free_netdev(can_dev[i]);
-		}
-	}
-	sja1000_proc_delete(drv_name);
-}
-
-static __init int sja1000_isa_init_module(void)
-{
-	int i;
-	struct net_device *dev;
-
-	if (clk &lt; 1000 ) /* MHz command line value */
-		clk *= 1000000;
-
-	if (clk &lt; 1000000 ) /* kHz command line value */
-		clk *= 1000;
-
-	printk(KERN_INFO &quot;%s - %s driver v%s (%s)\n&quot;,
-	       chip_name, drv_name, drv_version, drv_reldate);
-	printk(KERN_INFO &quot;%s - options [clk %d.%06d MHz] [restart_ms %dms] [debug %d]\n&quot;,
-	       chip_name, clk/1000000, clk%1000000, restart_ms, debug);
-
-	for (i = 0; base_addr[i]; i++) {
-		printk(KERN_DEBUG &quot;%s: checking for %s on address 0x%X ...\n&quot;,
-		       chip_name, chip_name, base_addr[i]);
-		if (!request_region(base_addr[i], SJA1000_IO_SIZE_BASIC, chip_name)) {
-			printk(KERN_ERR &quot;%s: memory already in use\n&quot;, chip_name);
-			sja1000_isa_cleanup_module();
-			return -EBUSY;
-		}
-		dev = sja1000_isa_probe(base_addr[i], irq[i], speed[i], btr[i], rx_probe[i], clk, debug, restart_ms);
-
-		if (dev != NULL) {
-			can_dev[i] = dev;
-			sja1000_proc_init(drv_name, can_dev, MAX_CAN);
-		} else {
-			can_dev[i] = NULL;
-			release_region(base_addr[i], SJA1000_IO_SIZE_BASIC);
-		}
-	}
-	return 0;
-}
-
-module_init(sja1000_isa_init_module);
-module_exit(sja1000_isa_cleanup_module);

Deleted: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/mem.c
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/mem.c	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/mem.c	2007-03-26 14:15:07 UTC (rev 193)
@@ -1,262 +0,0 @@
-/*
- * $Id$
- *
- * mem.c - Philips SJA1000 network device driver for IOMEM
- *
- * Copyright (c) 2002-2005 Volkswagen Group Electronic Research
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, the following disclaimer and
- *    the referenced file 'COPYING'.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of Volkswagen nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * Alternatively, provided that this notice is retained in full, this
- * software may be distributed under the terms of the GNU General
- * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
- * file from the main directory of the linux kernel source.
- *
- * The provided data structures and external interfaces from this code
- * are not restricted to be used by modules with a GPL compatible license.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
- * DAMAGE.
- *
- * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
- *
- */
-
-#include &lt;linux/module.h&gt;
-#include &lt;linux/init.h&gt;
-#include &lt;linux/kernel.h&gt;
-#include &lt;linux/sched.h&gt;
-#include &lt;linux/types.h&gt;
-#include &lt;linux/fcntl.h&gt;
-#include &lt;linux/interrupt.h&gt;
-#include &lt;linux/ptrace.h&gt;
-#include &lt;linux/ioport.h&gt;
-#include &lt;linux/in.h&gt;
-#include &lt;linux/slab.h&gt;
-#include &lt;linux/string.h&gt;
-#include &lt;linux/errno.h&gt;
-#include &lt;linux/netdevice.h&gt;
-#include &lt;linux/skbuff.h&gt;
-#include &lt;asm/io.h&gt;
-
-#include &lt;linux/can.h&gt;
-#include &lt;linux/can/ioctl.h&gt; /* for struct can_device_stats */
-#include &quot;sja1000.h&quot;
-
-#define MAX_CAN		8
-#define CAN_DEV_NAME	&quot;can%d&quot;
-#define DRV_NAME        &quot;sja1000-mem&quot;
-
-#define DEFAULT_KBIT_PER_SEC 500
-#define SJA1000_HW_CLOCK 16000000
-
-/* driver and version information */
-static const char *drv_name	= DRV_NAME;
-static const char *drv_version	= &quot;0.0.1&quot;;
-static const char *drv_reldate	= &quot;2006-08-22&quot;;
-static const char *chip_name	= SJA1000_CHIP_NAME;
-
-MODULE_AUTHOR(&quot;Oliver Hartkopp &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">oliver.hartkopp at volkswagen.de</A>&gt;, Pavel Pisa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">pisa at cmp.felk.cvut.cz</A>&gt;&quot;);
-MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);
-MODULE_DESCRIPTION(&quot;LLCF SJA1000 network device driver '&quot; DRV_NAME &quot;'&quot;);
-
-/* module parameters */
-static uint32_t base_addr[MAX_CAN] = { (uint32_t)0xda000L, 0};
-
-static int irq[MAX_CAN] = { 9, 0 };
-
-static int speed[MAX_CAN] = { DEFAULT_KBIT_PER_SEC, DEFAULT_KBIT_PER_SEC, 0};
-
-static int btr[MAX_CAN] = { 0 };
-static int rx_probe[MAX_CAN] = { 0 };
-
-static int clk = SJA1000_HW_CLOCK;
-static int debug = 0;
-static int restart_ms = 100;
-
-/* array of all can chips */
-static struct net_device	*can_dev[MAX_CAN];
-
-static int base_addr_n;
-static int irq_n;
-static int speed_n;
-static int btr_n;
-static int rx_probe_n;
-
-module_param_array(base_addr, int, &amp;base_addr_n, 0);
-module_param_array(irq, int, &amp;irq_n, 0);
-module_param_array(speed, int, &amp;speed_n, 0);
-module_param_array(btr, int, &amp;btr_n, 0);
-module_param_array(rx_probe, int, &amp;rx_probe_n, 0);
-
-module_param(clk, int, 0);
-module_param(debug, int, 0);
-module_param(restart_ms, int, 0);
-
-/* special functions to access the chips registers */
-static uint8_t reg_read(struct net_device *dev, int reg)
-{
-	static uint8_t val;
-	void __iomem *addr = (void __iomem *)dev-&gt;base_addr + reg;
-
-	val = (uint8_t)readw(addr);
-	rmb();
-
-	return val;
-}
-
-static void reg_write(struct net_device *dev, int reg, uint8_t val)
-{
-	void __iomem *addr = (void __iomem *)dev-&gt;base_addr + reg;
-
-	writew(val, addr);
-	wmb();
-}
-
-static struct net_device* sja1000_mem_probe(uint32_t base, int irq, int speed,
-					    int btr, int rx_probe, int clk,
-					    int debug, int restart_ms)
-{
-	struct net_device	*dev;
-	struct can_priv		*priv;
-
-	if (!(dev = alloc_netdev(sizeof(struct can_priv), CAN_DEV_NAME,
-				 sja1000_setup))) {
-		printk(KERN_ERR &quot;%s: out of memory\n&quot;, chip_name);
-		return NULL;
-	}
-
-	printk(KERN_INFO &quot;%s: base 0x%X / irq %d / speed %d / btr 0x%X / rx_probe %d\n&quot;,
-	       chip_name, base, irq, speed, btr, rx_probe);
-
-	/* fill net_device structure */
-
-	priv             = netdev_priv(dev);
-
-	dev-&gt;irq         = irq;
-	dev-&gt;base_addr   = base;
-
-	priv-&gt;reg_read   = reg_read;
-	priv-&gt;reg_write  = reg_write;
-
-	priv-&gt;speed      = speed;
-	priv-&gt;btr        = btr;
-	priv-&gt;rx_probe   = rx_probe;
-	priv-&gt;clock      = clk;
-	priv-&gt;restart_ms = restart_ms;
-	priv-&gt;debug      = debug;
-
-	if (REG_READ(0) == 0xFF) {
-		printk(KERN_INFO &quot;%s: probing failed\n&quot;, chip_name);
-		goto free_dev;
-	}
-
-	if (register_netdev(dev)) {
-		printk(KERN_INFO &quot;%s: register netdev failed\n&quot;, chip_name);
-		goto free_dev;
-	}
-
-	/* set chip into reset mode */
-	set_reset_mode(dev);
-
-	/* go into Pelican mode, disable clkout, disable comparator */
-	REG_WRITE(REG_CDR, 0xCF);
-
-	/* output control */
-	/* connected to external transceiver */
-	REG_WRITE(REG_OCR, 0x1A);
-
-	printk(KERN_INFO &quot;%s: %s found at 0x%X, irq is %d\n&quot;,
-	       dev-&gt;name, chip_name, (uint32_t)dev-&gt;base_addr, dev-&gt;irq);
-
-	return dev;
-
- free_dev:
-	free_netdev(dev);
-	return NULL;
-}
-
-static __exit void sja1000_mem_cleanup_module(void)
-{
-	int i;
-
-	for (i = 0; i &lt; MAX_CAN; i++) {
-		if (can_dev[i] != NULL) {
-			struct can_priv *priv = netdev_priv(can_dev[i]);
-			unregister_netdev(can_dev[i]);
-			del_timer(&amp;priv-&gt;timer);
-			iounmap((void __iomem *)can_dev[i]-&gt;base_addr);
-			release_mem_region(base_addr[i], SJA1000_IO_SIZE_BASIC);
-			free_netdev(can_dev[i]);
-		}
-	}
-	sja1000_proc_delete(drv_name);
-}
-
-static __init int sja1000_mem_init_module(void)
-{
-	int i;
-
-	if (clk &lt; 1000 ) /* MHz command line value */
-		clk *= 1000000;
-
-	if (clk &lt; 1000000 ) /* kHz command line value */
-		clk *= 1000;
-
-	printk(KERN_INFO &quot;%s - %s driver v%s (%s)\n&quot;,
-	       chip_name, drv_name, drv_version, drv_reldate);
-	printk(KERN_INFO &quot;%s - options [clk %d.%06d MHz] [restart_ms %dms] [debug %d]\n&quot;,
-	       chip_name, clk/1000000, clk%1000000, restart_ms, debug);
-
-	for (i = 0; base_addr[i]; i++) {
-
-		struct net_device *dev = NULL;
-		void *base;
-
-		printk(KERN_DEBUG &quot;%s: checking for %s on address 0x%X ...\n&quot;,
-		       chip_name, chip_name, base_addr[i]);
-		if (!request_mem_region(base_addr[i], SJA1000_IO_SIZE_BASIC, chip_name)) {
-			printk(KERN_ERR &quot;%s: memory already in use\n&quot;, chip_name);
-			sja1000_mem_cleanup_module();
-			return -EBUSY;
-		}
-
-		base = ioremap(base_addr[i], SJA1000_IO_SIZE_BASIC);
-		if (base)
-			dev = sja1000_mem_probe((uint32_t)base, irq[i], speed[i], btr[i], rx_probe[i], clk, debug, restart_ms);
-		if (dev != NULL) {
-			can_dev[i] = dev;
-			sja1000_proc_init(drv_name, can_dev, MAX_CAN);
-		} else {
-			can_dev[i] = NULL;
-			iounmap(base);
-			release_mem_region(base_addr[i], SJA1000_IO_SIZE_BASIC);
-		}
-	}
-	return 0;
-}
-
-module_init(sja1000_mem_init_module);
-module_exit(sja1000_mem_cleanup_module);

Modified: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/proc.c
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/proc.c	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/proc.c	2007-03-26 14:15:07 UTC (rev 193)
@@ -53,14 +53,14 @@
 #include &lt;linux/can.h&gt;
 #include &lt;linux/can/ioctl.h&gt;
 #include &quot;sja1000.h&quot;
+#include &quot;hal.h&quot;
 
+extern struct net_device *can_dev[];
+
 static struct proc_dir_entry *pde       = NULL;
 static struct proc_dir_entry *pde_regs  = NULL;
 static struct proc_dir_entry *pde_reset = NULL;
 
-static struct net_device **can_dev;
-static int max_devices;
-
 static int sja1000_proc_read(char *page, char **start, off_t off,
 			     int count, int *eof, void *data)
 {
@@ -70,14 +70,19 @@
 	struct can_priv *priv;
 	unsigned char stat;
 
-	len += snprintf(page + len, PAGE_SIZE - len, &quot;CAN bus device statistics:\n&quot;);
-	len += snprintf(page + len, PAGE_SIZE - len, &quot;       errwarn  overrun   wakeup   buserr   errpass  arbitr   restarts clock        baud\n&quot;);
-	for (i = 0; (i &lt; max_devices) &amp;&amp; (len &lt; PAGE_SIZE - 200); i++) {
+	len += snprintf(page + len, PAGE_SIZE - len,
+			&quot;CAN bus device statistics:\n&quot;);
+	len += snprintf(page + len, PAGE_SIZE - len,
+			&quot;       errwarn  overrun   wakeup   buserr   &quot;
+			&quot;errpass  arbitr   restarts clock        baud\n&quot;);
+	for (i = 0; (i &lt; MAXDEV) &amp;&amp; (len &lt; PAGE_SIZE - 200); i++) {
 		if (can_dev[i]) {
 			dev = can_dev[i];
-			stat = REG_READ(REG_SR);
+			stat = hw_readreg(dev-&gt;base_addr, REG_SR);
 			priv = netdev_priv(can_dev[i]);
-			len += snprintf(page + len, PAGE_SIZE - len, &quot;can%d: %8d %8d %8d %8d %8d %8d %8d %10d %8d\n&quot;, i,
+			len += snprintf(page + len, PAGE_SIZE - len,
+					&quot;can%d: %8d %8d %8d %8d %8d &quot;
+					&quot;%8d %8d %10d %8d\n&quot;, i,
 					priv-&gt;can_stats.error_warning,
 					priv-&gt;can_stats.data_overrun,
 					priv-&gt;can_stats.wakeup,
@@ -90,18 +95,20 @@
 				);
 			if (stat &amp; 0x80) {
 				len += snprintf(page + len, PAGE_SIZE - len,
-					&quot;can%d: bus status: BUS OFF, &quot;, i);
+						&quot;can%d: bus status: &quot;
+						&quot;BUS OFF, &quot;, i);
 			} else if (stat &amp; 0x40) {
 				len += snprintf(page + len, PAGE_SIZE - len,
-					&quot;can%d: bus status: ERROR PASSIVE, &quot;, i);
+						&quot;can%d: bus status: ERROR &quot;
+						&quot;PASSIVE, &quot;, i);
 			} else {
 				len += snprintf(page + len, PAGE_SIZE - len,
-					&quot;can%d: bus status: OK, &quot;, i);
+						&quot;can%d: bus status: OK, &quot;, i);
 			}
 			len += snprintf(page + len, PAGE_SIZE - len,
 					&quot;RXERR: %d, TXERR: %d\n&quot;,
-					REG_READ(REG_RXERR),
-					REG_READ(REG_TXERR));
+					hw_readreg(dev-&gt;base_addr, REG_RXERR),
+					hw_readreg(dev-&gt;base_addr, REG_TXERR));
 		}
 	}
 
@@ -117,49 +124,55 @@
 	int i;
 	struct can_priv	  *priv;
 
-	len = sprintf(page, &quot;SJA1000 registers:\n&quot;);
-	for (i = 0; (i &lt; max_devices) &amp;&amp; (len &lt; PAGE_SIZE - 200); i++) {
+	len = sprintf(page, &quot;%s registers:\n&quot;, CHIP_NAME);
+	for (i = 0; (i &lt; MAXDEV) &amp;&amp; (len &lt; PAGE_SIZE - 200); i++) {
 		if (can_dev[i]) {
 			dev = can_dev[i];
 			len += snprintf(page + len, PAGE_SIZE - len,
-					&quot;can%d SJA1000 registers:\n&quot;, i);
+					&quot;can%d %s registers:\n&quot;, i, CHIP_NAME);
 
 			priv = netdev_priv(can_dev[i]);
-			len += snprintf(page + len, PAGE_SIZE - len, &quot;00: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n&quot;,
-					REG_READ(0x00),
-					REG_READ(0x01),
-					REG_READ(0x02),
-					REG_READ(0x03),
-					REG_READ(0x04),
-					REG_READ(0x05),
-					REG_READ(0x06),
-					REG_READ(0x07),
-					REG_READ(0x08),
-					REG_READ(0x09),
-					REG_READ(0x0a),
-					REG_READ(0x0b),
-					REG_READ(0x0c),
-					REG_READ(0x0d),
-					REG_READ(0x0e),
-					REG_READ(0x0f)
+			len += snprintf(page + len, PAGE_SIZE - len,
+					&quot;00: %02x %02x %02x %02x %02x %02x &quot;
+					&quot;%02x %02x %02x %02x %02x %02x %02x &quot;
+					&quot;%02x %02x %02x\n&quot;,
+					hw_readreg(dev-&gt;base_addr, 0x00),
+					hw_readreg(dev-&gt;base_addr, 0x01),
+					hw_readreg(dev-&gt;base_addr, 0x02),
+					hw_readreg(dev-&gt;base_addr, 0x03),
+					hw_readreg(dev-&gt;base_addr, 0x04),
+					hw_readreg(dev-&gt;base_addr, 0x05),
+					hw_readreg(dev-&gt;base_addr, 0x06),
+					hw_readreg(dev-&gt;base_addr, 0x07),
+					hw_readreg(dev-&gt;base_addr, 0x08),
+					hw_readreg(dev-&gt;base_addr, 0x09),
+					hw_readreg(dev-&gt;base_addr, 0x0a),
+					hw_readreg(dev-&gt;base_addr, 0x0b),
+					hw_readreg(dev-&gt;base_addr, 0x0c),
+					hw_readreg(dev-&gt;base_addr, 0x0d),
+					hw_readreg(dev-&gt;base_addr, 0x0e),
+					hw_readreg(dev-&gt;base_addr, 0x0f)
 				);
-			len += snprintf(page + len, PAGE_SIZE - len, &quot;10: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n&quot;,
-					REG_READ(0x10),
-					REG_READ(0x11),
-					REG_READ(0x12),
-					REG_READ(0x13),
-					REG_READ(0x14),
-					REG_READ(0x15),
-					REG_READ(0x16),
-					REG_READ(0x17),
-					REG_READ(0x18),
-					REG_READ(0x19),
-					REG_READ(0x1a),
-					REG_READ(0x1b),
-					REG_READ(0x1c),
-					REG_READ(0x1d),
-					REG_READ(0x1e),
-					REG_READ(0x1f)
+			len += snprintf(page + len, PAGE_SIZE - len,
+					&quot;10: %02x %02x %02x %02x %02x %02x &quot;
+					&quot;%02x %02x %02x %02x %02x %02x %02x &quot;
+					&quot;%02x %02x %02x\n&quot;,
+					hw_readreg(dev-&gt;base_addr, 0x10),
+					hw_readreg(dev-&gt;base_addr, 0x11),
+					hw_readreg(dev-&gt;base_addr, 0x12),
+					hw_readreg(dev-&gt;base_addr, 0x13),
+					hw_readreg(dev-&gt;base_addr, 0x14),
+					hw_readreg(dev-&gt;base_addr, 0x15),
+					hw_readreg(dev-&gt;base_addr, 0x16),
+					hw_readreg(dev-&gt;base_addr, 0x17),
+					hw_readreg(dev-&gt;base_addr, 0x18),
+					hw_readreg(dev-&gt;base_addr, 0x19),
+					hw_readreg(dev-&gt;base_addr, 0x1a),
+					hw_readreg(dev-&gt;base_addr, 0x1b),
+					hw_readreg(dev-&gt;base_addr, 0x1c),
+					hw_readreg(dev-&gt;base_addr, 0x1d),
+					hw_readreg(dev-&gt;base_addr, 0x1e),
+					hw_readreg(dev-&gt;base_addr, 0x1f)
 				);
 		}
 	}
@@ -177,7 +190,7 @@
 	struct can_priv   *priv;
 
 	len += snprintf(page + len, PAGE_SIZE - len, &quot;resetting &quot;);
-	for (i = 0; (i &lt; max_devices) &amp;&amp; (len &lt; PAGE_SIZE - 200); i++) {
+	for (i = 0; (i &lt; MAXDEV) &amp;&amp; (len &lt; PAGE_SIZE - 200); i++) {
 		if (can_dev[i]) {
 			dev = can_dev[i];
 			priv = netdev_priv(can_dev[i]);
@@ -204,13 +217,10 @@
 	return len;
 }
 
-void sja1000_proc_init(const char *drv_name, struct net_device **dev, int max)
+void sja1000_proc_create(const char *drv_name)
 {
 	char fname[256];
 
-	can_dev     = dev;
-	max_devices = max;
-
 	if (pde == NULL) {
 		sprintf(fname, PROCBASE &quot;/%s&quot;, drv_name);
 		pde = create_proc_read_entry(fname, 0644, NULL,
@@ -228,7 +238,7 @@
 	}
 }
 
-void sja1000_proc_delete(const char *drv_name)
+void sja1000_proc_remove(const char *drv_name)
 {
 	char fname[256];
 

Modified: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/sja1000.c
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/sja1000.c	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/sja1000.c	2007-03-26 14:15:07 UTC (rev 193)
@@ -6,7 +6,7 @@
  * Copyright (c) 2003 Matthias Brukner, Trajet Gmbh, Rebenring 33,
  * 38106 Braunschweig, GERMANY
  *
- * Copyright (c) 2002-2005 Volkswagen Group Electronic Research
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -49,28 +49,46 @@
 
 #include &lt;linux/autoconf.h&gt;
 #include &lt;linux/module.h&gt;
-#include &lt;linux/ioport.h&gt;
-#include &lt;linux/slab.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/fcntl.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/ptrace.h&gt;
+#include &lt;linux/string.h&gt;
+#include &lt;linux/errno.h&gt;
 #include &lt;linux/netdevice.h&gt;
 #include &lt;linux/if_arp.h&gt;
 #include &lt;linux/if_ether.h&gt;
 #include &lt;linux/skbuff.h&gt;
-#include &lt;asm/io.h&gt;
 
 #include &lt;linux/can.h&gt;
-#include &lt;linux/can/ioctl.h&gt;
+#include &lt;linux/can/ioctl.h&gt; /* for struct can_device_stats */
 #include &quot;sja1000.h&quot;
+#include &quot;hal.h&quot;
 
+MODULE_AUTHOR(&quot;Oliver Hartkopp &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">oliver.hartkopp at volkswagen.de</A>&gt;&quot;);
+MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);
+MODULE_DESCRIPTION(&quot;LLCF/socketcan '&quot; CHIP_NAME &quot;' network device driver&quot;);
+
 #ifdef CONFIG_CAN_DEBUG_DEVICES
 #define DBG(args...)   ((priv-&gt;debug &gt; 0) ? printk(args) : 0)
-#define iDBG(args...)  ((priv-&gt;debug &gt; 1) ? printk(args) : 0)  /* logging in interrupt context */
-#define iiDBG(args...) ((priv-&gt;debug &gt; 2) ? printk(args) : 0)  /* logging in interrupt context */
+/* logging in interrupt context! */
+#define iDBG(args...)  ((priv-&gt;debug &gt; 1) ? printk(args) : 0)
+#define iiDBG(args...) ((priv-&gt;debug &gt; 2) ? printk(args) : 0)
 #else
 #define DBG(args...)
 #define iDBG(args...)
 #define iiDBG(args...)
 #endif
 
+char drv_name[DRV_NAME_LEN] = &quot;undefined&quot;;
+
+/* driver and version information */
+static const char *drv_version	= &quot;0.1.0&quot;;
+static const char *drv_reldate	= &quot;2007-03-26&quot;;
+
 #ifdef CONFIG_CAN_DEBUG_DEVICES
 static const char *ecc_errors[] = {
 	NULL,
@@ -115,14 +133,145 @@
 };
 #endif
 
-/* declarations */
+/* array of all can chips */
+struct net_device *can_dev[MAXDEV];
 
+/* module parameters */
+unsigned long base[MAXDEV]	= { 0 }; /* hardware address */
+unsigned long rbase[MAXDEV]	= { 0 }; /* (remapped) device address */
+unsigned int  irq[MAXDEV]	= { 0 };
+
+unsigned int speed[MAXDEV]	= { 0 };
+unsigned int btr[MAXDEV]	= { 0 };
+
+static int rx_probe[MAXDEV]	= { 0 };
+static int clk			= DEFAULT_HW_CLK;
+static int debug		= 0;
+static int restart_ms		= 100;
+
+static int base_n;
+static int irq_n;
+static int speed_n;
+static int btr_n;
+static int rx_probe_n;
+
+module_param_array(base, int, &amp;base_n, 0);
+module_param_array(irq, int, &amp;irq_n, 0);
+module_param_array(speed, int, &amp;speed_n, 0);
+module_param_array(btr, int, &amp;btr_n, 0);
+module_param_array(rx_probe, int, &amp;rx_probe_n, 0);
+
+module_param(clk, int, 0);
+module_param(debug, int, 0);
+module_param(restart_ms, int, 0);
+
+
+/* function declarations */
+
 static void can_restart_dev(unsigned long data);
 static void chipset_init(struct net_device *dev, int wake);
 static void chipset_init_rx(struct net_device *dev);
 static void chipset_init_trx(struct net_device *dev);
+static void can_netdev_setup(struct net_device *dev);
+static struct net_device* can_create_netdev(int dev_num);
+static int  can_set_drv_name(void);
+int set_reset_mode(struct net_device *dev);
+static int sja1000_probe_chip(unsigned long base);
 
+static __exit void sja1000_exit_module(void)
+{
+	int i, ret;
 
+	for (i = 0; i &lt; MAXDEV; i++) {
+		if (can_dev[i] != NULL) {
+			struct can_priv *priv = netdev_priv(can_dev[i]);
+			unregister_netdev(can_dev[i]);
+			del_timer(&amp;priv-&gt;timer);
+			hal_release_region(i, SJA1000_IO_SIZE_BASIC);
+			free_netdev(can_dev[i]);
+		}
+	}
+	sja1000_proc_remove(drv_name);
+
+	if ((ret = hal_exit()))
+		printk(KERN_INFO &quot;%s: hal_exit error %d.\n&quot;, drv_name, ret);
+}
+
+static __init int sja1000_init_module(void)
+{
+	int i, ret;
+	struct net_device *dev;
+
+	if ((ret = hal_init()))
+		return ret;
+
+	if ((ret = can_set_drv_name()))
+		return ret;
+
+	if (clk &lt; 1000 ) /* MHz command line value */
+		clk *= 1000000;
+
+	if (clk &lt; 1000000 ) /* kHz command line value */
+		clk *= 1000;
+
+	printk(KERN_INFO &quot;%s driver v%s (%s)\n&quot;,
+	       drv_name, drv_version, drv_reldate);
+	printk(KERN_INFO &quot;%s - options [clk %d.%06d MHz] [restart_ms %dms]&quot;
+	       &quot; [debug %d]\n&quot;,
+	       drv_name, clk/1000000, clk%1000000, restart_ms, debug);
+
+	if (!base[0]) {
+		printk(KERN_INFO &quot;%s: loading defaults.\n&quot;, drv_name);
+		hal_use_defaults();
+	}
+		
+	for (i = 0; base[i]; i++) {
+		printk(KERN_DEBUG &quot;%s: checking for %s on address 0x%lX ...\n&quot;,
+		       drv_name, CHIP_NAME, base[i]);
+
+		if (!hal_request_region(i, SJA1000_IO_SIZE_BASIC, drv_name)) {
+			printk(KERN_ERR &quot;%s: memory already in use\n&quot;,
+			       drv_name);
+			sja1000_exit_module();
+			return -EBUSY;
+		}
+
+		hw_attach(i);
+		hw_reset_dev(i);
+
+		if (!sja1000_probe_chip(base[i])) {
+			printk(KERN_ERR &quot;%s: probably missing controller&quot;
+			       &quot; hardware\n&quot;, drv_name);
+			hal_release_region(i, SJA1000_IO_SIZE_BASIC);
+			sja1000_exit_module();
+			return -ENODEV;
+		}
+
+		dev = can_create_netdev(i);
+
+		if (dev != NULL) {
+			can_dev[i] = dev;
+			set_reset_mode(dev);
+			sja1000_proc_create(drv_name);
+		} else {
+			can_dev[i] = NULL;
+			hw_detach(i);
+			hal_release_region(i, SJA1000_IO_SIZE_BASIC);
+		}
+	}
+	return 0;
+}
+
+static int sja1000_probe_chip(unsigned long base)
+{
+	if (base &amp;&amp; (hw_readreg(base, 0) == 0xFF)) {
+		printk(KERN_INFO &quot;%s: probing @0x%lX failed\n&quot;,
+		       drv_name, base);
+		return 0;
+	}
+	return 1;
+}
+
 /*
  * set baud rate divisor values
  */
@@ -130,12 +279,13 @@
 {
 	struct can_priv *priv = netdev_priv(dev);
 
-	if (priv-&gt;state == STATE_UNINITIALIZED) /* no bla bla when restarting the device */
+	/* no bla bla when restarting the device */
+	if (priv-&gt;state == STATE_UNINITIALIZED)
 		printk(KERN_INFO &quot;%s: setting BTR0=%02X BTR1=%02X\n&quot;,
 		       dev-&gt;name, btr0, btr1);
 
-	REG_WRITE(REG_BTR0, btr0);
-	REG_WRITE(REG_BTR1, btr1);
+	hw_writereg(dev-&gt;base_addr, REG_BTR0, btr0);
+	hw_writereg(dev-&gt;base_addr, REG_BTR1, btr1);
 }
 
 /*
@@ -160,7 +310,9 @@
 
 	clock &gt;&gt;= 1;
 
-	for (tseg = (0 + 0 + 2) * 2; tseg &lt;= (MAX_TSEG2 + MAX_TSEG1 + 2) * 2 + 1; tseg++) {
+	for (tseg = (0 + 0 + 2) * 2;
+	     tseg &lt;= (MAX_TSEG2 + MAX_TSEG1 + 2) * 2 + 1;
+	     tseg++) {
 		brp = clock / ((1 + tseg / 2) * baud) + tseg % 2;
 		if ((brp &gt; 0) &amp;&amp; (brp &lt;= 64)) {
 			error = baud - clock / (brp * (1 + tseg / 2));
@@ -193,7 +345,8 @@
 		tseg2 = best_tseg - tseg1 - 2;
 	}
 
-	priv-&gt;btr = ((best_brp | JUMPWIDTH)&lt;&lt;8) + ((SAM &lt;&lt; 7) | (tseg2 &lt;&lt; 4) | tseg1);
+	priv-&gt;btr = ((best_brp | JUMPWIDTH)&lt;&lt;8) + 
+		((SAM &lt;&lt; 7) | (tseg2 &lt;&lt; 4) | tseg1);
 
 	printk(KERN_INFO &quot;%s: calculated best baudrate: %d / btr is 0x%04X\n&quot;,
 	       dev-&gt;name, best_baud, priv-&gt;btr);
@@ -205,13 +358,13 @@
 int set_reset_mode(struct net_device *dev)
 {
 	struct can_priv *priv = netdev_priv(dev);
-	unsigned char status = REG_READ(REG_MOD);
+	unsigned char status = hw_readreg(dev-&gt;base_addr, REG_MOD);
 	int i;
 
 	priv-&gt;can_stats.bus_error_at_init = priv-&gt;can_stats.bus_error;
 
 	/* disable interrupts */
-	REG_WRITE(REG_IER, IRQ_OFF);
+	hw_writereg(dev-&gt;base_addr, REG_IER, IRQ_OFF);
 
 	for (i = 0; i &lt; 10; i++) {
 		/* check reset bit */
@@ -224,19 +377,20 @@
 			return 0;
 		}
 
-		REG_WRITE(REG_MOD, MOD_RM); /* reset chip */
-		status = REG_READ(REG_MOD);
+		hw_writereg(dev-&gt;base_addr, REG_MOD, MOD_RM); /* reset chip */
+		status = hw_readreg(dev-&gt;base_addr, REG_MOD);
 
 	}
 
-	printk(KERN_ERR &quot;%s: setting sja1000 into reset mode failed!\n&quot;, dev-&gt;name);
+	printk(KERN_ERR &quot;%s: setting sja1000 into reset mode failed!\n&quot;,
+	       dev-&gt;name);
 	return 1;
 
 }
 
 static int set_normal_mode(struct net_device *dev)
 {
-	unsigned char status = REG_READ(REG_MOD);
+	unsigned char status = hw_readreg(dev-&gt;base_addr, REG_MOD);
 	int i;
 
 	for (i = 0; i &lt; 10; i++) {
@@ -252,18 +406,20 @@
 			return 0;
 		}
 
-		REG_WRITE(REG_MOD, 0x00); /* set chip to normal mode */
-		status = REG_READ(REG_MOD);
+		/* set chip to normal mode */
+		hw_writereg(dev-&gt;base_addr, REG_MOD, 0x00);
+		status = hw_readreg(dev-&gt;base_addr, REG_MOD);
 	}
 
-	printk(KERN_ERR &quot;%s: setting sja1000 into normal mode failed!\n&quot;, dev-&gt;name);
+	printk(KERN_ERR &quot;%s: setting sja1000 into normal mode failed!\n&quot;,
+	       dev-&gt;name);
 	return 1;
 
 }
 
 static int set_listen_mode(struct net_device *dev)
 {
-	unsigned char status = REG_READ(REG_MOD);
+	unsigned char status = hw_readreg(dev-&gt;base_addr, REG_MOD);
 	int i;
 
 	for (i = 0; i &lt; 10; i++) {
@@ -280,11 +436,12 @@
 		}
 
 		/* set listen only mode, clear reset */
-		REG_WRITE(REG_MOD, MOD_LOM);
-		status = REG_READ(REG_MOD);
+		hw_writereg(dev-&gt;base_addr, REG_MOD, MOD_LOM);
+		status = hw_readreg(dev-&gt;base_addr, REG_MOD);
 	}
 
-	printk(KERN_ERR &quot;%s: setting sja1000 into listen mode failed!\n&quot;, dev-&gt;name);
+	printk(KERN_ERR &quot;%s: setting sja1000 into listen mode failed!\n&quot;,
+	       dev-&gt;name);
 	return 1;
 
 }
@@ -300,20 +457,25 @@
 static void chipset_init_regs(struct net_device *dev)
 {
 	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev-&gt;base_addr;
 
 	/* go into Pelican mode, disable clkout, disable comparator */
-	REG_WRITE(REG_CDR, 0xCF);
+	hw_writereg(base, REG_CDR, 0xCF);
 
+	/* output control */
+	/* connected to external transceiver */
+	hw_writereg(base, REG_OCR, 0x1A);
+
 	/* set acceptance filter (accept all) */
-	REG_WRITE(REG_ACCC0, 0x00);
-	REG_WRITE(REG_ACCC1, 0x00);
-	REG_WRITE(REG_ACCC2, 0x00);
-	REG_WRITE(REG_ACCC3, 0x00);
+	hw_writereg(base, REG_ACCC0, 0x00);
+	hw_writereg(base, REG_ACCC1, 0x00);
+	hw_writereg(base, REG_ACCC2, 0x00);
+	hw_writereg(base, REG_ACCC3, 0x00);
 
-	REG_WRITE(REG_ACCM0, 0xFF);
-	REG_WRITE(REG_ACCM1, 0xFF);
-	REG_WRITE(REG_ACCM2, 0xFF);
-	REG_WRITE(REG_ACCM3, 0xFF);
+	hw_writereg(base, REG_ACCM0, 0xFF);
+	hw_writereg(base, REG_ACCM1, 0xFF);
+	hw_writereg(base, REG_ACCM2, 0xFF);
+	hw_writereg(base, REG_ACCM3, 0xFF);
 
 	/* set baudrate */
 	if (priv-&gt;btr) { /* no calculation when btr is provided */
@@ -326,8 +488,8 @@
 	}
 
 	/* output control */
-	REG_WRITE(REG_OCR, 0x1A);	/* connected to external transceiver */
-
+	/* connected to external transceiver */
+	hw_writereg(base, REG_OCR, 0x1A);
 }
 
 static void chipset_init(struct net_device *dev, int wake)
@@ -361,7 +523,7 @@
 	priv-&gt;state = STATE_PROBE;
 
 	/* enable receive and error interrupts */
-	REG_WRITE(REG_IER, IRQ_RI | IRQ_EI);
+	hw_writereg(dev-&gt;base_addr, REG_IER, IRQ_RI | IRQ_EI);
 }
 
 static void chipset_init_trx(struct net_device *dev)
@@ -382,7 +544,7 @@
 	priv-&gt;state = STATE_ACTIVE;
 
 	/* enable all interrupts */
-	REG_WRITE(REG_IER, IRQ_ALL);
+	hw_writereg(dev-&gt;base_addr, REG_IER, IRQ_ALL);
 }
 
 /*
@@ -393,8 +555,9 @@
  */
 static int can_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct can_priv  *priv = netdev_priv(dev);
-	struct can_frame *cf   = (struct can_frame*)skb-&gt;data;
+	struct can_priv  *priv	= netdev_priv(dev);
+	struct can_frame *cf	= (struct can_frame*)skb-&gt;data;
+	unsigned long base	= dev-&gt;base_addr;
 	uint8_t	fi;
 	uint8_t	dlc;
 	canid_t	id;
@@ -412,23 +575,23 @@
 	if (id &amp; CAN_EFF_FLAG) {
 		fi |= FI_FF;
 		dreg = EFF_BUF;
-		REG_WRITE(REG_FI, fi);
-		REG_WRITE(REG_ID1, (id &amp; 0x1fe00000) &gt;&gt; (5 + 16));
-		REG_WRITE(REG_ID2, (id &amp; 0x001fe000) &gt;&gt; (5 + 8));
-		REG_WRITE(REG_ID3, (id &amp; 0x00001fe0) &gt;&gt; 5);
-		REG_WRITE(REG_ID4, (id &amp; 0x0000001f) &lt;&lt; 3);
+		hw_writereg(base, REG_FI, fi);
+		hw_writereg(base, REG_ID1, (id &amp; 0x1fe00000) &gt;&gt; (5 + 16));
+		hw_writereg(base, REG_ID2, (id &amp; 0x001fe000) &gt;&gt; (5 + 8));
+		hw_writereg(base, REG_ID3, (id &amp; 0x00001fe0) &gt;&gt; 5);
+		hw_writereg(base, REG_ID4, (id &amp; 0x0000001f) &lt;&lt; 3);
 	} else {
 		dreg = SFF_BUF;
-		REG_WRITE(REG_FI, fi);
-		REG_WRITE(REG_ID1, (id &amp; 0x000007f8) &gt;&gt; 3);
-		REG_WRITE(REG_ID2, (id &amp; 0x00000007) &lt;&lt; 5);
+		hw_writereg(base, REG_FI, fi);
+		hw_writereg(base, REG_ID1, (id &amp; 0x000007f8) &gt;&gt; 3);
+		hw_writereg(base, REG_ID2, (id &amp; 0x00000007) &lt;&lt; 5);
 	}
 
 	for (i = 0; i &lt; dlc; i++) {
-		REG_WRITE(dreg++, cf-&gt;data[i]);
+		hw_writereg(base, dreg++, cf-&gt;data[i]);
 	}
 
-	REG_WRITE(REG_CMR, CMD_TR);
+	hw_writereg(base, REG_CMR, CMD_TR);
 
 	priv-&gt;stats.tx_bytes += dlc;
 
@@ -517,7 +680,8 @@
 
 static void can_rx(struct net_device *dev)
 {
-	struct can_priv *priv = netdev_priv(dev);
+	struct can_priv *priv	= netdev_priv(dev);
+	unsigned long base	= dev-&gt;base_addr;
 	struct can_frame *cf;
 	struct sk_buff	*skb;
 	uint8_t	fi;
@@ -533,21 +697,22 @@
 	skb-&gt;dev = dev;
 	skb-&gt;protocol = htons(ETH_P_CAN);
 
-	fi = REG_READ(REG_FI);
+	fi = hw_readreg(base, REG_FI);
 	dlc = fi &amp; 0x0F;
 
 	if (fi &amp; FI_FF) {
 		/* extended frame format (EFF) */
 		dreg = EFF_BUF;
-		id = (REG_READ(REG_ID1) &lt;&lt; (5+16))
-			| (REG_READ(REG_ID2) &lt;&lt; (5+8))
-			| (REG_READ(REG_ID3) &lt;&lt; 5)
-			| (REG_READ(REG_ID4) &gt;&gt; 3);
+		id = (hw_readreg(base, REG_ID1) &lt;&lt; (5+16))
+			| (hw_readreg(base, REG_ID2) &lt;&lt; (5+8))
+			| (hw_readreg(base, REG_ID3) &lt;&lt; 5)
+			| (hw_readreg(base, REG_ID4) &gt;&gt; 3);
 		id |= CAN_EFF_FLAG;
 	} else {
 		/* standard frame format (SFF) */
 		dreg = SFF_BUF;
-		id = (REG_READ(REG_ID1) &lt;&lt; 3) | (REG_READ(REG_ID2) &gt;&gt; 5);
+		id = (hw_readreg(base, REG_ID1) &lt;&lt; 3)
+			| (hw_readreg(base, REG_ID2) &gt;&gt; 5);
 	}
 
 	if (fi &amp; FI_RTR)
@@ -558,13 +723,13 @@
 	cf-&gt;can_id    = id;
 	cf-&gt;can_dlc   = dlc;
 	for (i = 0; i &lt; dlc; i++) {
-		cf-&gt;data[i] = REG_READ(dreg++);
+		cf-&gt;data[i] = hw_readreg(base, dreg++);
 	}
 	while (i &lt; 8)
 		cf-&gt;data[i++] = 0;
 
 	/* release receive buffer */
-	REG_WRITE(REG_CMR, CMD_RRB);
+	hw_writereg(base, REG_CMR, CMD_RRB);
 
 	netif_rx(skb);
 
@@ -600,28 +765,39 @@
 /*
  * SJA1000 interrupt handler
  */
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,20)
 static irqreturn_t can_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#else
+static irqreturn_t can_interrupt(int irq, void *dev_id)
+#endif
 {
-	struct net_device *dev = (struct net_device*)dev_id;
-	struct can_priv *priv = netdev_priv(dev);
+	struct net_device *dev	= (struct net_device*)dev_id;
+	struct can_priv *priv	= netdev_priv(dev);
+	unsigned long base	= dev-&gt;base_addr;
 	uint8_t isrc, status, ecc, alc;
 	int n = 0;
 
+	hw_preirq(dev);
+
 	if (priv-&gt;state == STATE_UNINITIALIZED) {
-		printk(KERN_ERR &quot;%s: %s: uninitialized controller!\n&quot;, dev-&gt;name, __FUNCTION__);
-		chipset_init(dev, 1); /* this should be possible at this stage */
+		printk(KERN_ERR &quot;%s: %s: uninitialized controller!\n&quot;,
+		       dev-&gt;name, __FUNCTION__);
+		chipset_init(dev, 1); /* should be possible at this stage */
 		return IRQ_NONE;
 	}
 
 	if (priv-&gt;state == STATE_RESET_MODE) {
-		iiDBG(KERN_ERR &quot;%s: %s: controller is in reset mode! MOD=0x%02X IER=0x%02X IR=0x%02X SR=0x%02X!\n&quot;,
-		      dev-&gt;name, __FUNCTION__, REG_READ(REG_MOD), REG_READ(REG_IER), REG_READ(REG_IR), REG_READ(REG_SR));
+		iiDBG(KERN_ERR &quot;%s: %s: controller is in reset mode! &quot;
+		      &quot;MOD=0x%02X IER=0x%02X IR=0x%02X SR=0x%02X!\n&quot;,
+		      dev-&gt;name, __FUNCTION__, hw_readreg(base, REG_MOD),
+		      hw_readreg(base, REG_IER), hw_readreg(base, REG_IR),
+		      hw_readreg(base, REG_SR));
 		return IRQ_NONE;
 	}
 
-	while ((isrc = REG_READ(REG_IR)) &amp;&amp; (n &lt; 20)) {
+	while ((isrc = hw_readreg(base, REG_IR)) &amp;&amp; (n &lt; 20)) {
 		n++;
-		status = REG_READ(REG_SR);
+		status = hw_readreg(base, REG_SR);
 
 		if (isrc &amp; IRQ_WUI) {
 			/* wake-up interrupt */
@@ -637,86 +813,105 @@
 
 			while (status &amp; SR_RBS) {
 				can_rx(dev);
-				status = REG_READ(REG_SR);
+				status = hw_readreg(base, REG_SR);
 			}
-			if (priv-&gt;state == STATE_PROBE) { /* valid RX -&gt; switch to trx-mode */
+			if (priv-&gt;state == STATE_PROBE) {
+				/* valid RX -&gt; switch to trx-mode */
 				iDBG(KERN_INFO &quot;%s: RI #%d#\n&quot;, dev-&gt;name, n);
 				chipset_init_trx(dev); /* no tx queue wakeup */
-				break; /* check again after initializing the controller */
+				break; /* check again after init controller */
 			}
 		}
 		if (isrc &amp; IRQ_DOI) {
 			/* data overrun interrupt */
-			iiDBG(KERN_INFO &quot;%s: data overrun isrc=0x%02X status=0x%02X\n&quot;,
+			iiDBG(KERN_INFO &quot;%s: data overrun isrc=0x%02X &quot;
+			      &quot;status=0x%02X\n&quot;,
 			      dev-&gt;name, isrc, status);
 			iDBG(KERN_INFO &quot;%s: DOI #%d#\n&quot;, dev-&gt;name, n);
 			priv-&gt;can_stats.data_overrun++;
-			REG_WRITE(REG_CMR, CMD_CDO); /* clear bit */
+			hw_writereg(base, REG_CMR, CMD_CDO); /* clear bit */
 		}
 		if (isrc &amp; IRQ_EI) {
 			/* error warning interrupt */
-			iiDBG(KERN_INFO &quot;%s: error warning isrc=0x%02X status=0x%02X\n&quot;,
+			iiDBG(KERN_INFO &quot;%s: error warning isrc=0x%02X &quot;
+			      &quot;status=0x%02X\n&quot;,
 			      dev-&gt;name, isrc, status);
 			iDBG(KERN_INFO &quot;%s: EI #%d#\n&quot;, dev-&gt;name, n);
 			priv-&gt;can_stats.error_warning++;
 			if (status &amp; SR_BS) {
-				printk(KERN_INFO &quot;%s: BUS OFF, restarting device\n&quot;, dev-&gt;name);
+				printk(KERN_INFO &quot;%s: BUS OFF, &quot;
+				       &quot;restarting device\n&quot;, dev-&gt;name);
 				can_restart_on(dev);
-				return IRQ_HANDLED; /* controller has been restarted, so we leave here */
+				/* controller has been restarted: leave here */
+				return IRQ_HANDLED;
 			} else if (status &amp; SR_ES) {
 				iDBG(KERN_INFO &quot;%s: error\n&quot;, dev-&gt;name);
 			}
 		}
 		if (isrc &amp; IRQ_BEI) {
 			/* bus error interrupt */
-			iiDBG(KERN_INFO &quot;%s: bus error isrc=0x%02X status=0x%02X\n&quot;,
+			iiDBG(KERN_INFO &quot;%s: bus error isrc=0x%02X &quot;
+			      &quot;status=0x%02X\n&quot;,
 			      dev-&gt;name, isrc, status);
 			iDBG(KERN_INFO &quot;%s: BEI #%d# [%d]\n&quot;, dev-&gt;name, n,
-			     priv-&gt;can_stats.bus_error - priv-&gt;can_stats.bus_error_at_init);
+			     priv-&gt;can_stats.bus_error - 
+			     priv-&gt;can_stats.bus_error_at_init);
 			priv-&gt;can_stats.bus_error++;
-			ecc = REG_READ(REG_ECC);
+			ecc = hw_readreg(base, REG_ECC);
 			iDBG(KERN_INFO &quot;%s: ECC = 0x%02X (%s, %s, %s)\n&quot;,
 			     dev-&gt;name, ecc,
 			     (ecc &amp; ECC_DIR) ? &quot;RX&quot; : &quot;TX&quot;,
 			     ecc_types[ecc &gt;&gt; ECC_ERR],
 			     ecc_errors[ecc &amp; ECC_SEG]);
 
-			/* when the bus errors flood the system, restart the controller */
-			if (priv-&gt;can_stats.bus_error_at_init + MAX_BUS_ERRORS &lt; priv-&gt;can_stats.bus_error) {
-				iDBG(KERN_INFO &quot;%s: heavy bus errors, restarting device\n&quot;, dev-&gt;name);
+			/* when the bus errors flood the system, */
+			/* restart the controller                */
+			if (priv-&gt;can_stats.bus_error_at_init +
+			    MAX_BUS_ERRORS &lt; priv-&gt;can_stats.bus_error) {
+				iDBG(KERN_INFO &quot;%s: heavy bus errors,&quot;
+				     &quot; restarting device\n&quot;, dev-&gt;name);
 				can_restart_on(dev);
-				return IRQ_HANDLED; /* controller has been restarted, so we leave here */
+				/* controller has been restarted: leave here */
+				return IRQ_HANDLED;
 			}
 #if 1
-			/* don't know, if this is a good idea, but it works fine ... */
-			if (REG_READ(REG_RXERR) &gt; 128) {
-				iDBG(KERN_INFO &quot;%s: RX_ERR &gt; 128, restarting device\n&quot;, dev-&gt;name);
+			/* don't know, if this is a good idea, */
+			/* but it works fine ...               */
+			if (hw_readreg(base, REG_RXERR) &gt; 128) {
+				iDBG(KERN_INFO &quot;%s: RX_ERR &gt; 128,&quot;
+				     &quot; restarting device\n&quot;, dev-&gt;name);
 				can_restart_on(dev);
-				return IRQ_HANDLED; /* controller has been restarted, so we leave here */
+				/* controller has been restarted: leave here */
+				return IRQ_HANDLED;
 			}
 #endif
 		}
 		if (isrc &amp; IRQ_EPI) {
 			/* error passive interrupt */
-			iiDBG(KERN_INFO &quot;%s: error passive isrc=0x%02X status=0x%02X\n&quot;,
+			iiDBG(KERN_INFO &quot;%s: error passive isrc=0x%02X&quot;
+			      &quot; status=0x%02X\n&quot;,
 			      dev-&gt;name, isrc, status);
 			iDBG(KERN_INFO &quot;%s: EPI #%d#\n&quot;, dev-&gt;name, n);
 			priv-&gt;can_stats.error_passive++;
 			if (status &amp; SR_ES) {
-				iDBG(KERN_INFO &quot;%s: -&gt; ERROR PASSIVE, restarting device\n&quot;, dev-&gt;name);
+				iDBG(KERN_INFO &quot;%s: -&gt; ERROR PASSIVE, &quot;
+				     &quot;restarting device\n&quot;, dev-&gt;name);
 				can_restart_on(dev);
-				return IRQ_HANDLED; /* controller has been restarted, so we leave here */
+				/* controller has been restarted: leave here */
+				return IRQ_HANDLED;
 			} else {
-				iDBG(KERN_INFO &quot;%s: -&gt; ERROR ACTIVE\n&quot;, dev-&gt;name);
+				iDBG(KERN_INFO &quot;%s: -&gt; ERROR ACTIVE\n&quot;,
+				     dev-&gt;name);
 			}
 		}
 		if (isrc &amp; IRQ_ALI) {
 			/* arbitration lost interrupt */
-			iiDBG(KERN_INFO &quot;%s: error arbitration lost isrc=0x%02X status=0x%02X\n&quot;,
+			iiDBG(KERN_INFO &quot;%s: error arbitration lost &quot;
+			      &quot;isrc=0x%02X status=0x%02X\n&quot;,
 			      dev-&gt;name, isrc, status);
 			iDBG(KERN_INFO &quot;%s: ALI #%d#\n&quot;, dev-&gt;name, n);
 			priv-&gt;can_stats.arbitration_lost++;
-			alc = REG_READ(REG_ALC);
+			alc = hw_readreg(base, REG_ALC);
 			iDBG(KERN_INFO &quot;%s: ALC = 0x%02X\n&quot;, dev-&gt;name, alc);
 		}
 	}
@@ -724,6 +919,8 @@
 		iDBG(KERN_INFO &quot;%s: handled %d IRQs\n&quot;, dev-&gt;name, n);
 	}
 
+	hw_postirq(dev);
+
 	return n == 0 ? IRQ_NONE : IRQ_HANDLED;
 }
 
@@ -740,8 +937,13 @@
 	priv-&gt;state = STATE_UNINITIALIZED;
 
 	/* register interrupt handler */
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,20)
 	if (request_irq(dev-&gt;irq, &amp;can_interrupt, SA_SHIRQ,
 			dev-&gt;name, (void*)dev)) {
+#else
+	if (request_irq(dev-&gt;irq, &amp;can_interrupt, IRQF_SHARED,
+			dev-&gt;name, (void*)dev)) {
+#endif
 		return -EAGAIN;
 	}
 
@@ -783,41 +985,30 @@
 }
 
 #if 0
-static uint8_t reg_read(struct net_device *dev, int reg)
-{
-	return readb(dev-&gt;base_addr + reg);
-}
-
-static void reg_write(struct net_device *dev, int reg, uint8_t val)
-{
-	writeb(val, dev-&gt;base_addr + reg);
-}
-
 static void test_if(struct net_device *dev)
 {
 	int i;
 	int j;
 	int x;
 
-	REG_WRITE(REG_CDR, 0xCF);
+	hw_writereg(base, REG_CDR, 0xCF);
 	for (i = 0; i &lt; 10000; i++) {
 		for (j = 0; j &lt; 256; j++) {
-			REG_WRITE(REG_EWL, j);
-			x = REG_READ(REG_EWL);
+			hw_writereg(base, REG_EWL, j);
+			x = hw_readreg(base, REG_EWL);
 			if (x != j) {
-				printk(KERN_INFO &quot;%s: is: %02X expected: %02X (%d)\n&quot;, dev-&gt;name, x, j, i);
+				printk(KERN_INFO &quot;%s: is: %02X expected: &quot;
+				       &quot;%02X (%d)\n&quot;, dev-&gt;name, x, j, i);
 			}
 		}
 	}
 }
 #endif
 
-void sja1000_setup(struct net_device *dev)
+void can_netdev_setup(struct net_device *dev)
 {
-	struct can_priv *priv = netdev_priv(dev);
-
 	/* Fill in the the fields of the device structure
-	   with CAN/LLCF generic values */
+	   with CAN netdev generic values */
 
 	dev-&gt;change_mtu			= NULL;
 	dev-&gt;hard_header		= NULL;
@@ -836,17 +1027,72 @@
 	dev-&gt;flags			= IFF_NOARP;
 	dev-&gt;features			= NETIF_F_NO_CSUM;
 
-	dev-&gt;open		= can_open;
-	dev-&gt;stop		= can_close;
-	dev-&gt;hard_start_xmit	= can_start_xmit;
-	dev-&gt;get_stats		= can_get_stats;
-	dev-&gt;do_ioctl           = can_ioctl;
+	dev-&gt;open			= can_open;
+	dev-&gt;stop			= can_close;
+	dev-&gt;hard_start_xmit		= can_start_xmit;
+	dev-&gt;get_stats			= can_get_stats;
+	dev-&gt;do_ioctl           	= can_ioctl;
 
-	dev-&gt;tx_timeout		= can_tx_timeout;
-	dev-&gt;watchdog_timeo	= TX_TIMEOUT;
+	dev-&gt;tx_timeout			= can_tx_timeout;
+	dev-&gt;watchdog_timeo		= TX_TIMEOUT;
 
+	SET_MODULE_OWNER(dev);
+}
+
+static struct net_device* can_create_netdev(int dev_num)
+{
+	struct net_device	*dev;
+	struct can_priv		*priv;
+
+	if (!(dev = alloc_netdev(sizeof(struct can_priv), CAN_NETDEV_NAME,
+				 can_netdev_setup))) {
+		printk(KERN_ERR &quot;%s: out of memory\n&quot;, CHIP_NAME);
+		return NULL;
+	}
+
+	printk(KERN_INFO &quot;%s: base 0x%lX / irq %d / speed %d / &quot;
+	       &quot;btr 0x%X / rx_probe %d\n&quot;,
+	       drv_name, rbase[dev_num], irq[dev_num],
+	       speed[dev_num], btr[dev_num], rx_probe[dev_num]);
+
+	/* fill net_device structure */
+
+	priv             = netdev_priv(dev);
+
+	dev-&gt;irq         = irq[dev_num];
+	dev-&gt;base_addr   = rbase[dev_num];
+
+	priv-&gt;speed      = speed[dev_num];
+	priv-&gt;btr        = btr[dev_num];
+	priv-&gt;rx_probe   = rx_probe[dev_num];
+	priv-&gt;clock      = clk;
+	priv-&gt;restart_ms = restart_ms;
+	priv-&gt;debug      = debug;
+
 	init_timer(&amp;priv-&gt;timer);
 	priv-&gt;timer.expires = 0;
 
-	//	SET_MODULE_OWNER(dev);
+	if (register_netdev(dev)) {
+		printk(KERN_INFO &quot;%s: register netdev failed\n&quot;, CHIP_NAME);
+		free_netdev(dev);
+		return NULL;
+	}
+
+	return dev;
 }
+
+int can_set_drv_name(void)
+{
+	char *hname = hal_name();
+
+	if (strlen(CHIP_NAME) + strlen(hname) &gt;= DRV_NAME_LEN-1) {
+		printk(KERN_ERR &quot;%s: driver name too long!\n&quot;, CHIP_NAME);
+		return -EINVAL;
+	}
+	sprintf(drv_name, &quot;%s-%s&quot;, CHIP_NAME, hname);
+	return 0;
+}
+
+module_init(sja1000_init_module);
+module_exit(sja1000_exit_module);
+

Modified: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/sja1000.h
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/sja1000.h	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/sja1000.h	2007-03-26 14:15:07 UTC (rev 193)
@@ -51,14 +51,23 @@
 #define SJA1000_H
 
 #define SJA1000_IO_SIZE_BASIC   0x20
-#define SJA1000_IO_SIZE_PELICAN 0x80
+#define SJA1000_IO_SIZE_PELICAN 0x80 /* unused */
 
+#define CHIP_NAME	&quot;sja1000&quot;
+
+#define DRV_NAME_LEN	30 /* for &quot;&lt;chip_name&gt;-&lt;hal_name&gt;&quot; */
+
+#define PROCBASE          &quot;driver&quot; /* /proc/ ... */
+
+#define DEFAULT_HW_CLK	16000000
 #define DEFAULT_SPEED	100 /* kBit/s */
 
-#define TX_TIMEOUT	(HZ/20) /* 50ms */
-#define RESTART_MS      100     /* restart chip on persistent errors in 100ms */
-#define MAX_BUS_ERRORS  200     /* prevent from flooding bus error interrupts */
+#define CAN_NETDEV_NAME	&quot;can%d&quot;
 
+#define TX_TIMEOUT      (50*HZ/1000) /* 50ms */ 
+#define RESTART_MS      100  /* restart chip on persistent errors in 100ms */
+#define MAX_BUS_ERRORS  200  /* prevent from flooding bus error interrupts */
+
 /* SJA1000 registers - manual section 6.4 (Pelican Mode) */
 #define REG_MOD		0x00
 #define REG_CMR		0x01
@@ -150,19 +159,11 @@
 #define SAMPLE_POINT	75
 #define JUMPWIDTH     0x40
 
+/* CAN private data structure */
 
-#define REG_READ(addr)		((struct can_priv*)netdev_priv(dev))-&gt;reg_read(dev,addr)
-#define REG_WRITE(addr,data)	((struct can_priv*)netdev_priv(dev))-&gt;reg_write(dev,addr,data)
-
-#define SJA1000_CHIP_NAME &quot;sja1000&quot;
-#define PROCBASE          &quot;net/drivers&quot; /* /proc/ ... */
-
-/*
- * private data structure:
- * reg_read and reg_write are functions to access the sja1000 registers
- */
 struct can_priv {
 	struct net_device_stats	stats;
+	struct can_device_stats	can_stats;
 	long			open_time;
 	int			clock;
 	int			restart_ms;
@@ -171,9 +172,6 @@
 	int			btr;
 	int			rx_probe;
 	struct timer_list       timer;
-	uint8_t			(*reg_read)(struct net_device *dev, int reg);
-	void			(*reg_write)(struct net_device *dev, int reg, uint8_t val);
-	struct can_device_stats	can_stats;
 	int			state;
 };
 
@@ -185,10 +183,7 @@
 #define STATE_BUS_OFF		5
 #define STATE_RESET_MODE	6
 
-void sja1000_setup(struct net_device *dev);
-void sja1000_proc_init(const char *drv_name, struct net_device **dev, int max);
-void sja1000_proc_delete(const char *drv_name);
+void sja1000_proc_create(const char *drv_name);
+void sja1000_proc_remove(const char *drv_name);
 
-int set_reset_mode(struct net_device *dev);
-
 #endif /* SJA1000_H */

Deleted: branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/trajet-gw2.c
===================================================================
--- branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/trajet-gw2.c	2007-03-26 06:39:20 UTC (rev 192)
+++ branches/ha/candrv/kernel/2.6/drivers/net/can/sja1000/trajet-gw2.c	2007-03-26 14:15:07 UTC (rev 193)
@@ -1,275 +0,0 @@
-/*
- * $Id$
- *
- * trajet-gw2.c - Philips SJA1000 network device driver for TRAJET.GW2
- *
- * Copyright (c) 2003 Matthias Brukner, Trajet Gmbh, Rebenring 33,
- * 38106 Braunschweig, GERMANY
- *
- * Copyright (c) 2002-2005 Volkswagen Group Electronic Research
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, the following disclaimer and
- *    the referenced file 'COPYING'.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of Volkswagen nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * Alternatively, provided that this notice is retained in full, this
- * software may be distributed under the terms of the GNU General
- * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
- * file from the main directory of the linux kernel source.
- *
- * The provided data structures and external interfaces from this code
- * are not restricted to be used by modules with a GPL compatible license.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
- * DAMAGE.
- *
- * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
- *
- */
-
-#include &lt;linux/module.h&gt;
-#include &lt;linux/init.h&gt;
-#include &lt;linux/kernel.h&gt;
-#include &lt;linux/sched.h&gt;
-#include &lt;linux/types.h&gt;
-#include &lt;linux/fcntl.h&gt;
-#include &lt;linux/interrupt.h&gt;
-#include &lt;linux/ptrace.h&gt;
-#include &lt;linux/ioport.h&gt;
-#include &lt;linux/in.h&gt;
-#include &lt;linux/slab.h&gt;
-#include &lt;linux/string.h&gt;
-#include &lt;linux/errno.h&gt;
-#include &lt;linux/netdevice.h&gt;
-#include &lt;linux/skbuff.h&gt;
-#include &lt;asm/io.h&gt;
-
-#include &lt;linux/can.h&gt;
-#include &lt;linux/can/ioctl.h&gt; /* for struct can_device_stats */
-#include &quot;sja1000.h&quot;
-
-#define MAX_CAN		8
-#define CAN_DEV_NAME	&quot;can%d&quot;
-#define DRV_NAME        &quot;sja1000-gw2&quot;
-
-#define DEFAULT_KBIT_PER_SEC 500
-#define SJA1000_HW_CLOCK 20000000
-#define ADDR_GAP	1
-#define RSIZE		(SJA1000_IO_SIZE_PELICAN * (ADDR_GAP + 1))
-
-/* driver and version information */
-static const char *drv_name	= DRV_NAME;
-static const char *drv_version	= &quot;0.0.12&quot;;
-static const char *drv_reldate	= &quot;2005-08-22&quot;;
-static const char *chip_name	= SJA1000_CHIP_NAME;
-
-MODULE_AUTHOR(&quot;Matthias Brukner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">M.Brukner at trajet.de</A>&gt;&quot;);
-MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);
-MODULE_DESCRIPTION(&quot;LLCF SJA1000 network device driver '&quot; DRV_NAME &quot;'&quot;);
-
-/* module parameters */
-static uint32_t base_addr[MAX_CAN] = {
-	(uint32_t)0xf0100200L,
-	(uint32_t)0xf0100300L,
-	(uint32_t)0xf0100400L,
-	(uint32_t)0xf0100500L,
-	0
-};
-static int irq[MAX_CAN] = { 26, 26, 26, 26, 0 };
-static int speed[MAX_CAN] = {
-	DEFAULT_KBIT_PER_SEC, DEFAULT_KBIT_PER_SEC,
-	DEFAULT_KBIT_PER_SEC, DEFAULT_KBIT_PER_SEC,
-	0
-};
-static int btr[MAX_CAN] = { 0 };
-static int rx_probe[MAX_CAN] = { 0 };
-
-static int clk = SJA1000_HW_CLOCK;
-static int debug = 0;
-static int restart_ms = 100;
-
-/* array of all can chips */
-static struct net_device	*can_dev[MAX_CAN];
-
-static int base_addr_n;
-static int irq_n;
-static int speed_n;
-static int btr_n;
-static int rx_probe_n;
-
-module_param_array(base_addr, int, &amp;base_addr_n, 0);
-module_param_array(irq, int, &amp;irq_n, 0);
-module_param_array(speed, int, &amp;speed_n, 0);
-module_param_array(btr, int, &amp;btr_n, 0);
-module_param_array(rx_probe, int, &amp;rx_probe_n, 0);
-
-module_param(clk, int, 0);
-module_param(debug, int, 0);
-module_param(restart_ms, int, 0);
-
-/* special functions to access the chips registers */
-static uint8_t reg_read(struct net_device *dev, int reg)
-{
-	static uint8_t val;
-	void __iomem *addr = (void __iomem *)dev-&gt;base_addr + reg * (ADDR_GAP + 1) + ADDR_GAP;
-
-	val = (uint8_t)readw(addr);
-	rmb();
-
-	return val;
-}
-
-static void reg_write(struct net_device *dev, int reg, uint8_t val)
-{
-	void __iomem *addr = (void __iomem *)dev-&gt;base_addr + reg * (ADDR_GAP + 1) + ADDR_GAP;
-
-	writew(val, addr);
-	wmb();
-}
-
-static struct net_device* sja1000_gw2_probe(uint32_t base, int irq, int speed,
-					    int btr, int rx_probe, int clk,
-					    int debug, int restart_ms)
-{
-	struct net_device	*dev;
-	struct can_priv		*priv;
-
-	if (!(dev = alloc_netdev(sizeof(struct can_priv), CAN_DEV_NAME,
-				 sja1000_setup))) {
-		printk(KERN_ERR &quot;%s: out of memory\n&quot;, chip_name);
-		return NULL;
-	}
-
-	printk(KERN_INFO &quot;%s: base 0x%X / irq %d / speed %d / btr 0x%X / rx_probe %d\n&quot;,
-	       chip_name, base, irq, speed, btr, rx_probe);
-
-	/* fill net_device structure */
-
-	priv             = netdev_priv(dev);
-
-	dev-&gt;irq         = irq;
-	dev-&gt;base_addr   = base;
-
-	priv-&gt;reg_read   = reg_read;
-	priv-&gt;reg_write  = reg_write;
-
-	priv-&gt;speed      = speed;
-	priv-&gt;btr        = btr;
-	priv-&gt;rx_probe   = rx_probe;
-	priv-&gt;clock      = clk;
-	priv-&gt;restart_ms = restart_ms;
-	priv-&gt;debug      = debug;
-
-	if (REG_READ(0) == 0xFF) {
-		printk(KERN_INFO &quot;%s: probing failed\n&quot;, chip_name);
-		goto free_dev;
-	}
-
-	if (register_netdev(dev)) {
-		printk(KERN_INFO &quot;%s: register netdev failed\n&quot;, chip_name);
-		goto free_dev;
-	}
-
-	/* set chip into reset mode */
-	set_reset_mode(dev);
-
-	/* go into Pelican mode, disable clkout, disable comparator */
-	REG_WRITE(REG_CDR, 0xCF);
-
-	/* output control */
-	/* connected to external transceiver */
-	REG_WRITE(REG_OCR, 0x1A);
-
-	printk(KERN_INFO &quot;%s: %s found at 0x%X, irq is %d\n&quot;,
-	       dev-&gt;name, chip_name, (uint32_t)dev-&gt;base_addr, dev-&gt;irq);
-
-	return dev;
-
- free_dev:
-	free_netdev(dev);
-	return NULL;
-}
-
-static __exit void sja1000_gw2_cleanup_module(void)
-{
-	int i;
-
-	for (i = 0; i &lt; MAX_CAN; i++) {
-		if (can_dev[i] != NULL) {
-			struct can_priv *priv = netdev_priv(can_dev[i]);
-			unregister_netdev(can_dev[i]);
-			del_timer(&amp;priv-&gt;timer);
-			iounmap((void __iomem *)can_dev[i]-&gt;base_addr);
-			release_mem_region(base_addr[i], RSIZE);
-			free_netdev(can_dev[i]);
-		}
-	}
-	sja1000_proc_delete(drv_name);
-}
-
-static __init int sja1000_gw2_init_module(void)
-{
-	int i;
-
-	if (clk &lt; 1000 ) /* MHz command line value */
-		clk *= 1000000;
-
-	if (clk &lt; 1000000 ) /* kHz command line value */
-		clk *= 1000;
-
-	printk(KERN_INFO &quot;%s - %s driver v%s (%s)\n&quot;,
-	       chip_name, drv_name, drv_version, drv_reldate);
-	printk(KERN_INFO &quot;%s - options [clk %d.%06d MHz] [restart_ms %dms] [debug %d]\n&quot;,
-	       chip_name, clk/1000000, clk%1000000, restart_ms, debug);
-
-	for (i = 0; base_addr[i]; i++) {
-
-		struct net_device *dev = NULL;
-		void *base;
-
-		printk(KERN_DEBUG &quot;%s: checking for %s on address 0x%X ...\n&quot;,
-		       chip_name, chip_name, base_addr[i]);
-		if (!request_mem_region(base_addr[i], RSIZE, chip_name)) {
-			printk(KERN_ERR &quot;%s: memory already in use\n&quot;, chip_name);
-			sja1000_gw2_cleanup_module();
-			return -EBUSY;
-		}
-
-		base = ioremap(base_addr[i], RSIZE);
-		if (base)
-			dev = sja1000_gw2_probe((uint32_t)base, irq[i], speed[i], btr[i], rx_probe[i], clk, debug, restart_ms);
-
-		if (dev != NULL) {
-			can_dev[i] = dev;
-			sja1000_proc_init(drv_name, can_dev, MAX_CAN);
-		} else {
-			can_dev[i] = NULL;
-			iounmap(base);
-			release_mem_region(base_addr[i], RSIZE);
-		}
-	}
-	return 0;
-}
-
-module_init(sja1000_gw2_init_module);
-module_exit(sja1000_gw2_cleanup_module);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000177.html">r192 - trunk/kernel/2.6/drivers/net/can
</A></li>
	<LI>Next message: <A HREF="000179.html">r194 - in branches/ha/candrv/kernel/2.6/drivers/net/can: hal sja1000
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#178">[ date ]</a>
              <a href="thread.html#178">[ thread ]</a>
              <a href="subject.html#178">[ subject ]</a>
              <a href="author.html#178">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-commit">More information about the Socketcan-commit
mailing list</a><br>
</body></html>
