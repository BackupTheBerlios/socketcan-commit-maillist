<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> r209 - trunk/kernel/2.6/net/can
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-commit/2007-April/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r209%20-%20trunk/kernel/2.6/net/can&In-Reply-To=%3C200704141928.l3EJSbQQ014334%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000192.html">
   <LINK REL="Next"  HREF="000194.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>r209 - trunk/kernel/2.6/net/can</H1>
    <B>hartkopp at mail.berlios.de</B> 
    <A HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r209%20-%20trunk/kernel/2.6/net/can&In-Reply-To=%3C200704141928.l3EJSbQQ014334%40sheep.berlios.de%3E"
       TITLE="r209 - trunk/kernel/2.6/net/can">hartkopp at mail.berlios.de
       </A><BR>
    <I>Sat Apr 14 21:28:37 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000192.html">r208 - trunk/kernel/2.6/drivers/net/can/i82527
</A></li>
        <LI>Next message: <A HREF="000194.html">r210 - trunk/kernel/2.6/drivers/net/can
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#193">[ date ]</a>
              <a href="thread.html#193">[ thread ]</a>
              <a href="subject.html#193">[ subject ]</a>
              <a href="author.html#193">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hartkopp
Date: 2007-04-14 21:28:34 +0200 (Sat, 14 Apr 2007)
New Revision: 209

Modified:
   trunk/kernel/2.6/net/can/af_can.c
   trunk/kernel/2.6/net/can/bcm.c
   trunk/kernel/2.6/net/can/proc.c
   trunk/kernel/2.6/net/can/raw.c
Log:
Cleaned up the code according to the hints from a code review with
Thomas Gleixner. Removed many goto's and variable assignments within 
conditions for that reason. Usage of kzalloc, etc ...
TODO:
- Add kernel doc comments for structs &amp; public (global) functions
- Find a solution for the RCS / version.h stuff (together with Urs)
- Sort the functions to reduce forward declarations for static functions.
- Check for pr_debug as a replacement for local DBG macros
- And some more details on my list ...


Modified: trunk/kernel/2.6/net/can/af_can.c
===================================================================
--- trunk/kernel/2.6/net/can/af_can.c	2007-04-13 14:13:59 UTC (rev 208)
+++ trunk/kernel/2.6/net/can/af_can.c	2007-04-14 19:28:34 UTC (rev 209)
@@ -166,9 +166,7 @@
 module_init(can_init);
 module_exit(can_exit);
 
-/**************************************************/
-/* af_can module init/exit functions              */
-/**************************************************/
+/* af_can module init/exit functions */
 
 static __init int can_init(void)
 {
@@ -179,19 +177,18 @@
 	if (!rcv_cache)
 		return -ENOMEM;
 
-	/* Insert struct dev_rcv_lists for reception on all devices.
-	   This struct is zero initialized which is correct for the 
-	   embedded hlist heads, the dev pointer, and the entries counter.
-	*/
+	/*
+	 * Insert struct dev_rcv_lists for reception on all devices.
+	 * This struct is zero initialized which is correct for the 
+	 * embedded hlist heads, the dev pointer, and the entries counter.
+	 */
 
 	spin_lock_bh(&amp;rcv_lists_lock);
 	hlist_add_head_rcu(&amp;rx_alldev_list.list, &amp;rx_dev_list);
 	spin_unlock_bh(&amp;rcv_lists_lock);
 
-	if (stats_timer) {
-		/* statistics init */
+	if (stats_timer)
 		init_timer(&amp;stattimer);
-	}
 
 	/* procfs init */
 	can_init_proc();
@@ -209,10 +206,8 @@
 	struct dev_rcv_lists *d;
 	struct hlist_node *n, *next;
 
-	if (stats_timer) {
-		/* stop statistics timer */
+	if (stats_timer)
 		del_timer(&amp;stattimer);
-	}
 
 	/* procfs remove */
 	can_remove_proc();
@@ -234,13 +229,12 @@
 	kmem_cache_destroy(rcv_cache);
 }
 
-/**************************************************/
-/* af_can protocol functions                      */
-/**************************************************/
+/* af_can protocol functions */
 
 void can_proto_register(struct can_proto *cp)
 {
 	int proto = cp-&gt;protocol;
+
 	if (proto &lt; 0 || proto &gt;= CAN_NPROTO) {
 		printk(KERN_ERR &quot;CAN: protocol number %d out &quot;
 		       &quot;of range\n&quot;, proto);
@@ -267,6 +261,7 @@
 void can_proto_unregister(struct can_proto *cp)
 {
 	int proto = cp-&gt;protocol;
+
 	if (!proto_tab[proto]) {
 		printk(KERN_ERR &quot;CAN: protocol %d is not registered\n&quot;, proto);
 		return;
@@ -284,7 +279,8 @@
 
 	DBG(&quot;called for %s\n&quot;, dev-&gt;name);
 
-	if (!(n = kmalloc(sizeof(*n), GFP_KERNEL)))
+	n = kmalloc(sizeof(*n), GFP_KERNEL);
+	if (!n)
 		return;
 
 	n-&gt;dev  = dev;
@@ -314,9 +310,7 @@
 	write_unlock(&amp;notifier_lock);
 }
 
-/**************************************************/
-/* af_can socket functions                        */
-/**************************************************/
+/* af_can socket functions */
 
 static void can_sock_destruct(struct sock *sk)
 {
@@ -331,7 +325,8 @@
 {
 	struct sock *sk;
 	struct can_proto *cp;
-	int ret;
+	char module_name[30];
+	int ret = 0;
 
 	DBG(&quot;socket %p, type %d, proto %d\n&quot;, sock, sock-&gt;type, protocol);
 
@@ -344,7 +339,6 @@
 
 	/* try to load protocol module, when CONFIG_KMOD is defined */
 	if (!proto_tab[protocol]) {
-		char module_name[30];
 		sprintf(module_name, &quot;can-proto-%d&quot;, protocol);
 		if (request_module(module_name) == -ENOSYS)
 			printk(KERN_INFO &quot;CAN: request_module(%s) not&quot;
@@ -352,7 +346,8 @@
 	}
 
 	/* check for success and correct type */
-	if (!(cp = proto_tab[protocol]) || cp-&gt;type != sock-&gt;type)
+	cp = proto_tab[protocol];
+	if (!cp || cp-&gt;type != sock-&gt;type)
 		return -EPROTONOSUPPORT;
 
 	if (cp-&gt;capability &gt;= 0 &amp;&amp; !capable(cp-&gt;capability))
@@ -363,15 +358,18 @@
 #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,13)
 	sk = sk_alloc(PF_CAN, GFP_KERNEL, cp-&gt;prot, 1);
 	if (!sk)
-		goto oom;
+		return -ENOMEM;
 #else
 	sk = sk_alloc(PF_CAN, GFP_KERNEL, 1, 0);
 	if (!sk)
-		goto oom;
-	if (cp-&gt;obj_size &amp;&amp;
-	    !(sk-&gt;sk_protinfo = kmalloc(cp-&gt;obj_size, GFP_KERNEL))) {
-		sk_free(sk);
-		goto oom;
+		return -ENOMEM;
+
+	if (cp-&gt;obj_size) {
+		sk-&gt;sk_protinfo = kmalloc(cp-&gt;obj_size, GFP_KERNEL);
+		if (!sk-&gt;sk_protinfo) {
+			sk_free(sk);
+			return -ENOMEM;
+		}
 	}
 	sk_set_owner(sk, proto_tab[protocol]-&gt;owner);
 #endif
@@ -380,7 +378,6 @@
 
 	DBG(&quot;created sock: %p\n&quot;, sk);
 
-	ret = 0;
 #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,13)
 	if (sk-&gt;sk_prot-&gt;init)
 		ret = sk-&gt;sk_prot-&gt;init(sk);
@@ -388,17 +385,14 @@
 	if (cp-&gt;init)
 		ret = cp-&gt;init(sk);
 #endif
+
 	if (ret) {
-		/* we must release sk */
+		/* release sk on errors */
 		sock_orphan(sk);
 		sock_put(sk);
-		return ret;
 	}
 
-	return 0;
-
- oom:
-	return -ENOMEM;
+	return ret;
 }
 
 static int can_notifier(struct notifier_block *nb,
@@ -406,6 +400,8 @@
 {
 	struct net_device *dev = (struct net_device *)data;
 	struct notifier *n;
+	struct dev_rcv_lists *d;
+	int i;
 
 	DBG(&quot;called for %s, msg = %lu\n&quot;, dev-&gt;name, msg);
 
@@ -413,25 +409,27 @@
 		return NOTIFY_DONE;
 
 	switch (msg) {
-		struct dev_rcv_lists *d;
-		int i;
 
 	case NETDEV_REGISTER:
 
-		/* create new dev_rcv_lists for this device */
+		/*
+		 * create new dev_rcv_lists for this device
+		 *
+		 * N.B. zeroing the struct is the correct initialization
+		 * for the embedded hlist_head structs.
+		 * Another list type, e.g. list_head, would require
+		 * explicit initialization.
+		 */
 
 		DBG(&quot;creating new dev_rcv_lists for %s\n&quot;, dev-&gt;name);
-		if (!(d = kmalloc(sizeof(*d),
-				  in_interrupt() ? GFP_ATOMIC : GFP_KERNEL))) {
+
+		d = kzalloc(sizeof(*d),
+			    in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+		if (!d) {
 			printk(KERN_ERR &quot;CAN: allocation of receive &quot;
 			       &quot;list failed\n&quot;);
 			return NOTIFY_DONE;
 		}
-		/* N.B. zeroing the struct is the correct initialization
-			for the embedded hlist_head structs.
-			Another list type, e.g. list_head, would require
-			explicit initialization. */
-		memset(d, 0, sizeof(*d));
 		d-&gt;dev = dev;
 
 		spin_lock_bh(&amp;rcv_lists_lock);
@@ -443,24 +441,22 @@
 	case NETDEV_UNREGISTER:
 		spin_lock_bh(&amp;rcv_lists_lock);
 
-		if (!(d = find_dev_rcv_lists(dev))) {
+		d = find_dev_rcv_lists(dev);
+		if (d) {
+			hlist_del_rcu(&amp;d-&gt;list);
+
+			/* remove all receivers hooked at this netdevice */
+			can_rx_delete_all(&amp;d-&gt;rx_err);
+			can_rx_delete_all(&amp;d-&gt;rx_all);
+			can_rx_delete_all(&amp;d-&gt;rx_fil);
+			can_rx_delete_all(&amp;d-&gt;rx_inv);
+			can_rx_delete_all(&amp;d-&gt;rx_eff);
+			for (i = 0; i &lt; 2048; i++)
+				can_rx_delete_all(&amp;d-&gt;rx_sff[i]);
+		} else
 			printk(KERN_ERR &quot;CAN: notifier: receive list not &quot;
 			       &quot;found for dev %s\n&quot;, dev-&gt;name);
-			goto unreg_out;
-		}
 
-		hlist_del_rcu(&amp;d-&gt;list);
-
-		/* remove all receivers hooked at this netdevice */
-		can_rx_delete_all(&amp;d-&gt;rx_err);
-		can_rx_delete_all(&amp;d-&gt;rx_all);
-		can_rx_delete_all(&amp;d-&gt;rx_fil);
-		can_rx_delete_all(&amp;d-&gt;rx_inv);
-		can_rx_delete_all(&amp;d-&gt;rx_eff);
-		for (i = 0; i &lt; 2048; i++)
-			can_rx_delete_all(&amp;d-&gt;rx_sff[i]);
-
-	unreg_out:
 		spin_unlock_bh(&amp;rcv_lists_lock);
 
 		if (d)
@@ -484,8 +480,10 @@
 	struct sock *sk = sock-&gt;sk;
 
 	switch (cmd) {
+
 	case SIOCGSTAMP:
 		return sock_get_timestamp(sk, (struct timeval __user *)arg);
+
 	default:
 #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,16)
 		return -ENOIOCTLCMD;
@@ -493,34 +491,47 @@
 		return dev_ioctl(cmd, (void __user *)arg);
 #endif
 	}
-	return 0;
 }
 
-/**************************************************/
-/* af_can tx path                                 */
-/**************************************************/
+/* af_can tx path */
 
 int can_send(struct sk_buff *skb, int loop)
 {
 	int err;
 
-	if (loop) { /* local loopback (default) */
-		*(struct sock **)skb-&gt;cb = skb-&gt;sk; /* tx sock reference */
+	if (loop) {
+		/* local loopback of sent CAN frames (default) */
 
+		/* indication for the CAN driver: do loopback */
+		*(struct sock **)skb-&gt;cb = skb-&gt;sk;
+
+		/*
+		 * The reference to the originating sock may be also required
+		 * by the receiving socket to indicate (and ignore) his own
+		 * sent data. Example: can_raw sockopt CAN_RAW_RECV_OWN_MSGS
+		 */
+
 		/* interface not capabable to do the loopback itself? */
 		if (!(skb-&gt;dev-&gt;flags &amp; IFF_LOOPBACK)) {
 			struct sk_buff *newskb = skb_clone(skb, GFP_ATOMIC);
+
+			/* perform the local loopback here */
 			newskb-&gt;protocol  = htons(ETH_P_CAN);
 			newskb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
-			netif_rx(newskb); /* perform local loopback here */
+			netif_rx(newskb);
 		}
+	} else {
+		/* indication for the CAN driver: no loopback required */
+		*(struct sock **)skb-&gt;cb = NULL;
+	}
+
+	if (skb-&gt;dev-&gt;flags &amp; IFF_UP) {
+		/* send to netdevice */
+		err = dev_queue_xmit(skb);
+		if (err &gt; 0)
+			err = net_xmit_errno(err);
 	} else
-		*(struct sock **)skb-&gt;cb = NULL; /* no loopback required */
-
-	if (!(skb-&gt;dev-&gt;flags &amp; IFF_UP))
 		err = -ENETDOWN;
-	else if ((err = dev_queue_xmit(skb)) &gt; 0)  /* send to netdevice */
-		err = net_xmit_errno(err);
 
 	/* update statistics */
 	stats.tx_frames++;
@@ -529,9 +540,7 @@
 	return err;
 }
 
-/**************************************************/
-/* af_can rx path                                 */
-/**************************************************/
+/* af_can rx path */
 
 int can_rx_register(struct net_device *dev, canid_t can_id, canid_t mask,
 		    void (*func)(struct sk_buff *, void *), void *data,
@@ -547,40 +556,38 @@
 	DBG(&quot;dev %p, id %03X, mask %03X, callback %p, data %p, ident %s\n&quot;,
 	    dev, can_id, mask, func, data, ident);
 
-	if (!(r = kmem_cache_alloc(rcv_cache, GFP_KERNEL))) {
-		ret = -ENOMEM;
-		goto out;
-	}
+	r = kmem_cache_alloc(rcv_cache, GFP_KERNEL);
+	if (!r)
+		return -ENOMEM;
 
 	spin_lock_bh(&amp;rcv_lists_lock);
 
-	if (!(d = find_dev_rcv_lists(dev))) {
+	d = find_dev_rcv_lists(dev);
+	if (d) {
+		rl = find_rcv_list(&amp;can_id, &amp;mask, d);
+
+		r-&gt;can_id  = can_id;
+		r-&gt;mask    = mask;
+		r-&gt;matches = 0;
+		r-&gt;func    = func;
+		r-&gt;data    = data;
+		r-&gt;ident   = ident;
+
+		hlist_add_head_rcu(&amp;r-&gt;list, rl);
+		d-&gt;entries++;
+
+		pstats.rcv_entries++;
+		if (pstats.rcv_entries_max &lt; pstats.rcv_entries)
+			pstats.rcv_entries_max = pstats.rcv_entries;
+	} else {
 		DBG(&quot;receive list not found for dev %s, id %03X, mask %03X\n&quot;,
 		    DNAME(dev), can_id, mask);
 		kmem_cache_free(rcv_cache, r);
 		ret = -ENODEV;
-		goto out_unlock;
 	}
 
-	rl = find_rcv_list(&amp;can_id, &amp;mask, d);
+	spin_unlock_bh(&amp;rcv_lists_lock);
 
-	r-&gt;can_id  = can_id;
-	r-&gt;mask    = mask;
-	r-&gt;matches = 0;
-	r-&gt;func    = func;
-	r-&gt;data    = data;
-	r-&gt;ident   = ident;
-
-	hlist_add_head_rcu(&amp;r-&gt;list, rl);
-	d-&gt;entries++;
-
-	pstats.rcv_entries++;
-	if (pstats.rcv_entries_max &lt; pstats.rcv_entries)
-		pstats.rcv_entries_max = pstats.rcv_entries;
-
- out_unlock:
-	spin_unlock_bh(&amp;rcv_lists_lock);
- out:
 	return ret;
 }
 
@@ -610,7 +617,7 @@
 int can_rx_unregister(struct net_device *dev, canid_t can_id, canid_t mask,
 		      void (*func)(struct sk_buff *, void *), void *data)
 {
-	struct receiver *r;
+	struct receiver *r = NULL;
 	struct hlist_head *rl;
 	struct hlist_node *next;
 	struct dev_rcv_lists *d;
@@ -619,11 +626,10 @@
 	DBG(&quot;dev %p, id %03X, mask %03X, callback %p, data %p\n&quot;,
 	    dev, can_id, mask, func, data);
 
-	r = NULL;
-
 	spin_lock_bh(&amp;rcv_lists_lock);
 
-	if (!(d = find_dev_rcv_lists(dev))) {
+	d = find_dev_rcv_lists(dev);
+	if (!d) {
 		DBG(&quot;receive list not found for dev %s, id %03X, mask %03X\n&quot;,
 		    DNAME(dev), can_id, mask);
 		ret = -ENODEV;
@@ -632,9 +638,10 @@
 
 	rl = find_rcv_list(&amp;can_id, &amp;mask, d);
 
-	/*  Search the receiver list for the item to delete.  This should
-	 *  exist, since no receiver may be unregistered that hasn't
-	 *  been registered before.
+	/*
+	 * Search the receiver list for the item to delete.  This should
+	 * exist, since no receiver may be unregistered that hasn't
+	 * been registered before.
 	 */
 
 	hlist_for_each_entry(r, next, rl, list) {
@@ -643,9 +650,10 @@
 			break;
 	}
 
-	/*  Check for bug in CAN protocol implementations:
-	 *  If no matching list item was found, the list cursor variable next
-	 *  will be NULL, while r will point to the last item of the list.
+	/*
+	 * Check for bug in CAN protocol implementations:
+	 * If no matching list item was found, the list cursor variable next
+	 * will be NULL, while r will point to the last item of the list.
 	 */
 
 	if (!next) {
@@ -699,7 +707,8 @@
 	matches = can_rcv_filter(&amp;rx_alldev_list, skb);
 
 	/* find receive list for this device */
-	if ((d = find_dev_rcv_lists(dev)))
+	d = find_dev_rcv_lists(dev);
+	if (d)
 		matches += can_rcv_filter(d, skb);
 
 	rcu_read_unlock();
@@ -802,21 +811,23 @@
 	struct dev_rcv_lists *d;
 	struct hlist_node *n;
 
-	/* find receive list for this device */
-
-	/*  The hlist_for_each_entry*() macros curse through the list
-	 *  using the pointer variable n and set d to the containing
-	 *  struct in each list iteration.  Therefore, after list
-	 *  iteration, d is unmodified when the list is empty, and it
-	 *  points to last list element, when the list is non-empty
-	 *  but no match in the loop body is found.  I.e. d is *not*
-	 *  NULL when no match is found.  We can, however, use the
-	 *  cursor variable n to decide if a match was found.
+	/*
+	 * find receive list for this device
+	 *
+	 * The hlist_for_each_entry*() macros curse through the list
+	 * using the pointer variable n and set d to the containing
+	 * struct in each list iteration.  Therefore, after list
+	 * iteration, d is unmodified when the list is empty, and it
+	 * points to last list element, when the list is non-empty
+	 * but no match in the loop body is found.  I.e. d is *not*
+	 * NULL when no match is found.  We can, however, use the
+	 * cursor variable n to decide if a match was found.
 	 */
 
-	hlist_for_each_entry(d, n, &amp;rx_dev_list, list)
+	hlist_for_each_entry(d, n, &amp;rx_dev_list, list) {
 		if (d-&gt;dev == dev)
 			break;
+	}
 
 	return n ? d : NULL;
 }
@@ -845,10 +856,12 @@
 	if (!(*mask)) /* mask == 0 =&gt; no condition testing at receive time */
 		return &amp;d-&gt;rx_all;
 
-	/* use extra filterset for the subscription of exactly *one* can_id */
+	/* use extra filterset for the subscription of exactly *ONE* can_id */
 	if (*can_id &amp; CAN_EFF_FLAG) {
-		if (*mask == (CAN_EFF_MASK | CAN_EFF_FLAG))
-			return &amp;d-&gt;rx_eff; /* use-case for hash-table here? */
+		if (*mask == (CAN_EFF_MASK | CAN_EFF_FLAG)) {
+			/* RFC: a use-case for hash-tables in the future? */
+			return &amp;d-&gt;rx_eff;
+		}
 	} else {
 		if (*mask == CAN_SFF_MASK)
 			return &amp;d-&gt;rx_sff[*can_id];
@@ -857,9 +870,7 @@
 	return &amp;d-&gt;rx_fil;  /* default: filter via can_id/can_mask */
 }
 
-/**************************************************/
-/* af_can utility stuff                           */
-/**************************************************/
+/* af_can utility stuff */
 
 unsigned long timeval2jiffies(struct timeval *tv, int round_up)
 {
@@ -867,24 +878,25 @@
 	unsigned long sec  = tv-&gt;tv_sec;
 	unsigned long usec = tv-&gt;tv_usec;
 
-	if (sec &gt; ULONG_MAX / HZ)          /* check for overflow */
+	/* check for overflow */
+	if (sec &gt; ULONG_MAX / HZ)
 		return ULONG_MAX;
 
-	if (round_up)                      /* any usec below one HZ? */
-		usec += 1000000 / HZ - 1;  /* pump it up */
+	/* any usec below one HZ? =&gt; pump it up */
+	if (round_up)
+		usec += 1000000 / HZ - 1;
 
 	jif = usec / (1000000 / HZ);
 
-	if (sec * HZ &gt; ULONG_MAX - jif)    /* check for overflow */
+	/* check for overflow */
+	if (sec * HZ &gt; ULONG_MAX - jif)
 		return ULONG_MAX;
 	else
 		return jif + sec * HZ;
 }
 
 
-/**************************************************/
-/* af_can debugging stuff                         */
-/**************************************************/
+/* af_can debugging stuff */
 
 #ifdef CONFIG_CAN_DEBUG_CORE
 
@@ -902,7 +914,8 @@
 	buf[len++] = ' ';
 	va_end(ap);
 
-	if ((dlc = cf-&gt;can_dlc) &gt; 8)
+	dlc = cf-&gt;can_dlc;
+	if (dlc &gt; 8)
 		dlc = 8;
 
 	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)

Modified: trunk/kernel/2.6/net/can/bcm.c
===================================================================
--- trunk/kernel/2.6/net/can/bcm.c	2007-04-13 14:13:59 UTC (rev 208)
+++ trunk/kernel/2.6/net/can/bcm.c	2007-04-14 19:28:34 UTC (rev 209)
@@ -258,9 +258,7 @@
 
 }
 
-/**************************************************/
-/* initial settings at socket creation time       */
-/**************************************************/
+/* initial settings at socket creation time */
 
 static int bcm_init(struct sock *sk)
 {
@@ -277,9 +275,7 @@
 	return 0;
 }
 
-/**************************************************/
-/* handling of netdevice problems                 */
-/**************************************************/
+/* handling of netdevice problems */
 
 static void bcm_notifier(unsigned long msg, void *data)
 {
@@ -300,9 +296,7 @@
 	}
 }
 
-/**************************************************/
-/* standard socket functions                      */
-/**************************************************/
+/* standard socket functions */
 
 static int bcm_release(struct socket *sock)
 {
@@ -322,10 +316,13 @@
 	list_for_each_entry_safe(op, next, &amp;bo-&gt;rx_ops, list) {
 		DBG(&quot;removing rx_op %p for can_id %03X\n&quot;, op, op-&gt;can_id);
 
-		/* Don't care if we're bound or not (due to netdev problems) */
-		/* can_rx_unregister() is always a save thing to do here     */
+		/*
+		 * Don't care if we're bound or not (due to netdev problems)
+		 * can_rx_unregister() is always a save thing to do here.
+		 */
 		if (op-&gt;ifindex) {
 			struct net_device *dev = dev_get_by_index(op-&gt;ifindex);
+
 			if (dev) {
 				can_rx_unregister(dev, op-&gt;can_id,
 						  REGMASK(op-&gt;can_id),
@@ -348,6 +345,7 @@
 	/* remove device notifier */
 	if (bo-&gt;ifindex) {
 		struct net_device *dev = dev_get_by_index(bo-&gt;ifindex);
+
 		if (dev) {
 			can_dev_unregister(dev, bcm_notifier, sk);
 			dev_put(dev);
@@ -372,6 +370,7 @@
 	/* bind a device to this socket */
 	if (addr-&gt;can_ifindex) {
 		struct net_device *dev = dev_get_by_index(addr-&gt;can_ifindex);
+
 		if (!dev) {
 			DBG(&quot;could not find device index %d\n&quot;,
 			    addr-&gt;can_ifindex);
@@ -417,11 +416,14 @@
 
 	/* check for alternative ifindex for this bcm_op */
 
-	if (!ifindex &amp;&amp; msg-&gt;msg_name) { /* no bound device as default */
+	if (!ifindex &amp;&amp; msg-&gt;msg_name) {
+		/* no bound device as default =&gt; check msg_name */
 		struct sockaddr_can *addr = 
 			(struct sockaddr_can *)msg-&gt;msg_name;
+
 		if (addr-&gt;can_family != AF_CAN)
 			return -EINVAL;
+
 		ifindex = addr-&gt;can_ifindex; /* ifindex from sendto() */
 
 		if (ifindex &amp;&amp; !dev_get_by_index(ifindex)) {
@@ -432,8 +434,8 @@
 
 	/* read message head information */
 
-	if ((ret = memcpy_fromiovec((u8*)&amp;msg_head, msg-&gt;msg_iov,
-				    MHSIZ)) &lt; 0)
+	ret = memcpy_fromiovec((u8*)&amp;msg_head, msg-&gt;msg_iov, MHSIZ);
+	if (ret &lt; 0)
 		return ret;
 
 	DBG(&quot;opcode %d for can_id %03X\n&quot;, msg_head.opcode, msg_head.can_id);
@@ -468,21 +470,22 @@
 
 	case TX_READ:
 
-		/* reuse msg_head for the reply */
-		msg_head.opcode  = TX_STATUS; /* reply to TX_READ */
+		/* reuse msg_head for the reply to TX_READ */
+		msg_head.opcode  = TX_STATUS;
 		ret = bcm_read_op(&amp;bo-&gt;tx_ops, &amp;msg_head, ifindex);
 		break;
 
 	case RX_READ:
 
-		/* reuse msg_head for the reply */
-		msg_head.opcode  = RX_STATUS; /* reply to RX_READ */
+		/* reuse msg_head for the reply to RX_READ */
+		msg_head.opcode  = RX_STATUS;
 		ret = bcm_read_op(&amp;bo-&gt;rx_ops, &amp;msg_head, ifindex);
 		break;
 
 	case TX_SEND:
 
-		if (msg_head.nframes &lt; 1) /* we need at least one can_frame */
+		/* we need at least one can_frame */
+		if (msg_head.nframes &lt; 1)
 			return -EINVAL;
 
 		ret = bcm_tx_send(msg, ifindex, sk);
@@ -511,16 +514,18 @@
 
 	noblock =  flags &amp; MSG_DONTWAIT;
 	flags   &amp;= ~MSG_DONTWAIT;
-	if (!(skb = skb_recv_datagram(sk, flags, noblock, &amp;error))) {
+	skb = skb_recv_datagram(sk, flags, noblock, &amp;error);
+	if (!skb)
 		return error;
-	}
 
 	DBG(&quot;delivering skbuff %p\n&quot;, skb);
 	DBG_SKB(skb);
 
 	if (skb-&gt;len &lt; size)
 		size = skb-&gt;len;
-	if ((err = memcpy_toiovec(msg-&gt;msg_iov, skb-&gt;data, size)) &lt; 0) {
+
+	err = memcpy_toiovec(msg-&gt;msg_iov, skb-&gt;data, size);
+	if (err &lt; 0) {
 		skb_free_datagram(sk, skb);
 		return err;
 	}
@@ -549,9 +554,7 @@
 	return mask;
 }
 
-/**************************************************/
-/* helper functions for bcm_sendmsg()             */
-/**************************************************/
+/* helper functions for bcm_sendmsg() */
 
 static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
 			int ifindex, struct sock *sk)
@@ -560,31 +563,37 @@
 	struct bcm_op *op;
 	int i, err;
 
-	if (!ifindex) /* we need a real device to send frames */
+	/* we need a real device to send frames */
+	if (!ifindex)
 		return -ENODEV;
 
-	if (msg_head-&gt;nframes &lt; 1) /* we need at least one can_frame */
+	/* we need at least one can_frame */
+	if (msg_head-&gt;nframes &lt; 1)
 		return -EINVAL;
 
 	/* check the given can_id */
 
-	if ((op = bcm_find_op(&amp;bo-&gt;tx_ops, msg_head-&gt;can_id, ifindex))) {
+	op = bcm_find_op(&amp;bo-&gt;tx_ops, msg_head-&gt;can_id, ifindex);
+	if (op) {
 
 		/* update existing BCM operation */
 
 		DBG(&quot;TX_SETUP: modifying existing tx_op %p for can_id %03X\n&quot;,
 		    op, msg_head-&gt;can_id);
 
-		/* Do we need more space for the can_frames than currently */
-		/* allocated? -&gt; This is a _really_ unusual use-case and   */
-		/* therefore (complexity / locking) it is not supported.   */
+		/*
+		 * Do we need more space for the can_frames than currently
+		 * allocated? -&gt; This is a _really_ unusual use-case and
+		 * therefore (complexity / locking) it is not supported.
+		 */
 		if (msg_head-&gt;nframes &gt; op-&gt;nframes)
 			return -E2BIG;
 
 		/* update can_frames content */
 		for (i = 0; i &lt; msg_head-&gt;nframes; i++) {
-			if ((err = memcpy_fromiovec((u8*)&amp;op-&gt;frames[i],
-						    msg-&gt;msg_iov, CFSIZ)) &lt; 0)
+			err = memcpy_fromiovec((u8*)&amp;op-&gt;frames[i],
+					       msg-&gt;msg_iov, CFSIZ);
+			if (err &lt; 0)
 				return err;
 
 			if (msg_head-&gt;flags &amp; TX_CP_CAN_ID) {
@@ -596,27 +605,26 @@
 	} else {
 		/* insert new BCM operation for the given can_id */
 
-		if (!(op = kmalloc(OPSIZ, GFP_KERNEL)))
+		op = kzalloc(OPSIZ, GFP_KERNEL);
+		if (!op)
 			return -ENOMEM;
 
-		memset(op, 0, OPSIZ); /* init to zero, e.g. for timers */
-
 		DBG(&quot;TX_SETUP: creating new tx_op %p for can_id %03X\n&quot;,
 		    op, msg_head-&gt;can_id);
 
 		op-&gt;can_id    = msg_head-&gt;can_id;
 
 		/* create array for can_frames and copy the data */
-		if (!(op-&gt;frames = kmalloc(msg_head-&gt;nframes * CFSIZ,
-					   GFP_KERNEL))) {
+		op-&gt;frames = kmalloc(msg_head-&gt;nframes * CFSIZ, GFP_KERNEL);
+		if (!op-&gt;frames) {
 			kfree(op);
 			return -ENOMEM;
 		}
 
 		for (i = 0; i &lt; msg_head-&gt;nframes; i++) {
-			if ((err = memcpy_fromiovec((u8*)&amp;op-&gt;frames[i],
-						    msg-&gt;msg_iov,
-						    CFSIZ)) &lt; 0) {
+			err = memcpy_fromiovec((u8*)&amp;op-&gt;frames[i],
+					       msg-&gt;msg_iov, CFSIZ);
+			if (err &lt; 0) {
 				kfree(op-&gt;frames);
 				kfree(op);
 				return err;
@@ -672,9 +680,9 @@
 
 		/* set timer values */
 
-		op-&gt;count   = msg_head-&gt;count;
-		op-&gt;ival1   = msg_head-&gt;ival1;
-		op-&gt;ival2   = msg_head-&gt;ival2;
+		op-&gt;count = msg_head-&gt;count;
+		op-&gt;ival1 = msg_head-&gt;ival1;
+		op-&gt;ival2 = msg_head-&gt;ival2;
 		op-&gt;j_ival1 = timeval2jiffies(&amp;msg_head-&gt;ival1, 1);
 		op-&gt;j_ival2 = timeval2jiffies(&amp;msg_head-&gt;ival2, 1);
 
@@ -745,26 +753,28 @@
 	}
 
 	/* check the given can_id */
+	op = bcm_find_op(&amp;bo-&gt;rx_ops, msg_head-&gt;can_id, ifindex);
+	if (op) {
 
-	if ((op = bcm_find_op(&amp;bo-&gt;rx_ops, msg_head-&gt;can_id, ifindex))) {
-
 		/* update existing BCM operation */
 
 		DBG(&quot;RX_SETUP: modifying existing rx_op %p for can_id %03X\n&quot;,
 		    op, msg_head-&gt;can_id);
 
-		/* Do we need more space for the can_frames than currently */
-		/* allocated? -&gt; This is a _really_ unusual use-case and   */
-		/* therefore (complexity / locking) it is not supported.   */
+		/*
+		 * Do we need more space for the can_frames than currently
+		 * allocated? -&gt; This is a _really_ unusual use-case and
+		 * therefore (complexity / locking) it is not supported.
+		 */
 		if (msg_head-&gt;nframes &gt; op-&gt;nframes)
 			return -E2BIG;
 
 		if (msg_head-&gt;nframes) {
 			/* update can_frames content */
-			if ((err = memcpy_fromiovec((u8*)op-&gt;frames,
-						    msg-&gt;msg_iov,
-						    msg_head-&gt;nframes
-						    * CFSIZ) &lt; 0))
+			err = memcpy_fromiovec((u8*)op-&gt;frames,
+					       msg-&gt;msg_iov,
+					       msg_head-&gt;nframes * CFSIZ);
+			if (err &lt; 0)
 				return err;
 
 			/* clear last_frames to indicate 'nothing received' */
@@ -778,11 +788,10 @@
 	} else {
 		/* insert new BCM operation for the given can_id */
 
-		if (!(op = kmalloc(OPSIZ, GFP_KERNEL)))
+		op = kzalloc(OPSIZ, GFP_KERNEL);
+		if (!op)
 			return -ENOMEM;
 
-		memset(op, 0, OPSIZ); /* init to zero, e.g. for timers */
-
 		DBG(&quot;RX_SETUP: creating new rx_op %p for can_id %03X\n&quot;,
 		    op, msg_head-&gt;can_id);
 
@@ -792,46 +801,43 @@
 		if (msg_head-&gt;nframes) {
 
 			/* create array for can_frames and copy the data */
-			if (!(op-&gt;frames = kmalloc(msg_head-&gt;nframes * CFSIZ,
-						   GFP_KERNEL))) {
+			op-&gt;frames = kmalloc(msg_head-&gt;nframes * CFSIZ,
+					     GFP_KERNEL);
+			if (!op-&gt;frames) {
 				kfree(op);
 				return -ENOMEM;
 			}
 
-			if ((err = memcpy_fromiovec((u8*)op-&gt;frames,
-						    msg-&gt;msg_iov,
-						    msg_head-&gt;nframes
-						    * CFSIZ)) &lt; 0) {
+			err = memcpy_fromiovec((u8*)op-&gt;frames, msg-&gt;msg_iov,
+					       msg_head-&gt;nframes * CFSIZ);
+			if (err &lt; 0) {
 				kfree(op-&gt;frames);
 				kfree(op);
 				return err;
 			}
 
-			/* create array for received can_frames */
-			if (!(op-&gt;last_frames = kmalloc(msg_head-&gt;nframes
-							* CFSIZ,
-							GFP_KERNEL))) {
+			/* create and init array for received can_frames */
+			op-&gt;last_frames = kzalloc(msg_head-&gt;nframes * CFSIZ,
+						  GFP_KERNEL);
+			if (!op-&gt;last_frames) {
 				kfree(op-&gt;frames);
 				kfree(op);
 				return -ENOMEM;
 			}
-
-			/* clear last_frames to indicate 'nothing received' */
-			memset(op-&gt;last_frames, 0, msg_head-&gt;nframes * CFSIZ);
 		} else {
-			/* op-&gt;frames = NULL due to memset */
+			/* op-&gt;frames = NULL due to memset in kzalloc() */
 
-			/* even when we have the RX_FILTER_ID case, we need */
-			/* to store the last frame for the throttle feature */
+			/*
+			 * even when we have the RX_FILTER_ID case, we need
+			 * to store the last frame for the throttle feature
+			 */
 
-			/* create array for received can_frames */
-			if (!(op-&gt;last_frames = kmalloc(CFSIZ, GFP_KERNEL))) {
+			/* create and init array for received can_frames */
+			op-&gt;last_frames = kzalloc(CFSIZ, GFP_KERNEL);
+			if (!op-&gt;last_frames) {
 				kfree(op);
 				return -ENOMEM;
 			}
-
-			/* clear last_frames to indicate 'nothing received' */
-			memset(op-&gt;last_frames, 0, CFSIZ);
 		}
 
 		op-&gt;sk = sk; /* bcm_delete_rx_op() needs this */
@@ -875,9 +881,11 @@
 		del_timer(&amp;op-&gt;thrtimer);
 		del_timer(&amp;op-&gt;timer);
 
-		/* funny feature in RX(!)_SETUP only for RTR-mode: */
-		/* copy can_id into frame BUT without RTR-flag to  */
-		/* prevent a full-load-loopback-test ... ;-]       */
+		/*
+		 * funny feature in RX(!)_SETUP only for RTR-mode:
+		 * copy can_id into frame BUT without RTR-flag to
+		 * prevent a full-load-loopback-test ... ;-]
+		 */
 		if ((op-&gt;flags &amp; TX_CP_CAN_ID) ||
 		    (op-&gt;frames[0].can_id == op-&gt;can_id))
 			op-&gt;frames[0].can_id = op-&gt;can_id &amp; ~CAN_RTR_FLAG;
@@ -887,9 +895,9 @@
 
 			/* set timer value */
 
-			op-&gt;ival1   = msg_head-&gt;ival1;
+			op-&gt;ival1 = msg_head-&gt;ival1;
+			op-&gt;ival2 = msg_head-&gt;ival2;
 			op-&gt;j_ival1 = timeval2jiffies(&amp;msg_head-&gt;ival1, 1);
-			op-&gt;ival2   = msg_head-&gt;ival2;
 			op-&gt;j_ival2 = timeval2jiffies(&amp;msg_head-&gt;ival2, 1);
 
 			DBG(&quot;RX_SETUP: SETTIMER j_ival1=%ld j_ival2=%ld\n&quot;,
@@ -902,16 +910,18 @@
 			}
 
 			/* free currently blocked msgs ? */
-			if (op-&gt;thrtimer.expires) { /* blocked by timer? */
+			if (op-&gt;thrtimer.expires) {
 				DBG(&quot;RX_SETUP: unblocking throttled msgs.\n&quot;);
 				del_timer(&amp;op-&gt;thrtimer);
 				/* send blocked msgs hereafter */
 				op-&gt;thrtimer.expires = jiffies + 2;
 				add_timer(&amp;op-&gt;thrtimer);
 			}
-			/* if (op-&gt;j_ival2) is zero, no (new) throttling     */
-			/* will happen. For details see functions            */
-			/* bcm_rx_update_and_send() and bcm_rx_thr_handler() */
+			/*
+			 * if (op-&gt;j_ival2) is zero, no (new) throttling
+			 * will happen. For details see functions
+			 * bcm_rx_update_and_send() and bcm_rx_thr_handler()
+			 */
 		}
 
 		if ((op-&gt;flags &amp; STARTTIMER) &amp;&amp; op-&gt;j_ival1) {
@@ -968,16 +978,16 @@
 	if (!skb)
 		return -ENOMEM;
 
-	if ((err = memcpy_fromiovec(skb_put(skb, CFSIZ), msg-&gt;msg_iov,
-				    CFSIZ)) &lt; 0) {
+	err = memcpy_fromiovec(skb_put(skb, CFSIZ), msg-&gt;msg_iov, CFSIZ);
+	if (err &lt; 0) {
 		kfree_skb(skb);
 		return err;
 	}
 
 	DBG_FRAME(&quot;BCM: TX_SEND: sending frame&quot;,
 		  (struct can_frame *)skb-&gt;data);
+
 	dev = dev_get_by_index(ifindex);
-
 	if (!dev) {
 		kfree_skb(skb);
 		return -ENODEV;
@@ -997,7 +1007,8 @@
 	struct bcm_op *op;
 	int ret;
 
-	if ((op = bcm_find_op(ops, msg_head-&gt;can_id, ifindex))) {
+	op = bcm_find_op(ops, msg_head-&gt;can_id, ifindex);
+	if (op) {
 
 		DBG(&quot;TRX_READ: sending status for can_id %03X\n&quot;,
 		    msg_head-&gt;can_id);
@@ -1022,9 +1033,7 @@
 	return ret;
 }
 
-/**************************************************/
-/* procfs functions                               */
-/**************************************************/
+/* procfs functions */
 
 static char *bcm_proc_getifname(int ifindex)
 {
@@ -1126,9 +1135,7 @@
 	return len;
 }
 
-/**************************************************/
-/* bcm_op handling tx path                        */
-/**************************************************/
+/* bcm_op handling tx path */
 
 static void bcm_can_tx(struct bcm_op *op)
 {
@@ -1138,28 +1145,33 @@
 
 	DBG_FRAME(&quot;BCM: bcm_can_tx: sending frame&quot;, cf);
 
+	/* no target device? =&gt; exit */
 	if (!op-&gt;ifindex)
-		return; /* no target device -&gt; exit */
+		return;
 
 	dev = dev_get_by_index(op-&gt;ifindex);
 
-	if (!dev)
-		return; /* should this bcm_op remove itself here? */
+	if (!dev) {
+		/* RFC: should this bcm_op remove itself here? */
+		return;
+	}
 
 	skb = alloc_skb(CFSIZ,
 			in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
 
 	if (!skb)
-		goto out; /* no memory */
+		goto out;
 
 	memcpy(skb_put(skb, CFSIZ), cf, CFSIZ);
 
+	/* send with loopback */
 	skb-&gt;dev = dev;
 	skb-&gt;sk = op-&gt;sk;
-	can_send(skb, 1); /* send with loopback */
+	can_send(skb, 1);
 
+	/* update statistics */
 	op-&gt;currframe++;
-	op-&gt;frames_abs++; /* statistics */
+	op-&gt;frames_abs++;
 
 	/* reached last frame? */
 	if (op-&gt;currframe &gt;= op-&gt;nframes)
@@ -1211,7 +1223,8 @@
 		    (char*) op-&gt;timer.data,
 		    (unsigned int) op-&gt;timer.expires);
 
-		bcm_can_tx(op); /* send (next) frame */
+		/* send (next) frame */
+		bcm_can_tx(op);
 	} else {
 		if (op-&gt;j_ival2) {
 			op-&gt;timer.expires = jiffies + op-&gt;j_ival2;
@@ -1222,7 +1235,8 @@
 			    (char*) op-&gt;timer.data,
 			    (unsigned int) op-&gt;timer.expires);
 
-			bcm_can_tx(op); /* send (next) frame */
+			/* send (next) frame */
+			bcm_can_tx(op);
 		} else
 			DBG(&quot;no timer restart\n&quot;);
 	}
@@ -1231,9 +1245,7 @@
 
 }
 
-/**************************************************/
-/* bcm_op handling rx path                        */
-/**************************************************/
+/* bcm_op handling rx path */
 
 static void bcm_rx_handler(struct sk_buff *skb, void *data)
 {
@@ -1241,16 +1253,19 @@
 	struct can_frame rxframe;
 	int i;
 
-	del_timer(&amp;op-&gt;timer); /* disable timeout */
+	/* disable timeout */
+	del_timer(&amp;op-&gt;timer);
 
 	DBG(&quot;Called with bcm_op %p\n&quot;, op);
 
 	if (skb-&gt;len == sizeof(rxframe)) {
 		memcpy(&amp;rxframe, skb-&gt;data, sizeof(rxframe));
-		skb_get_timestamp(skb, &amp;op-&gt;rx_stamp); /* save rx timestamp */
+		/* save rx timestamp */
+		skb_get_timestamp(skb, &amp;op-&gt;rx_stamp);
 		/* save originator for recvfrom() */
 		op-&gt;rx_ifindex = skb-&gt;dev-&gt;ifindex;
-		op-&gt;frames_abs++; /* statistics */
+		/* update statistics */
+		op-&gt;frames_abs++;
 		kfree_skb(skb);
 		DBG(&quot;got can_frame with can_id %03X\n&quot;, rxframe.can_id);
 	} else {
@@ -1267,32 +1282,42 @@
 		return;
 	}
 
-	if (op-&gt;flags &amp; RX_RTR_FRAME) { /* send reply for RTR-request */
+	if (op-&gt;flags &amp; RX_RTR_FRAME) {
+		/* send reply for RTR-request */
 		DBG(&quot;RTR-request\n&quot;);
-		bcm_can_tx(op); /* send op-&gt;frames[0] to CAN device */
+
+		/* send op-&gt;frames[0] to CAN device */
+		bcm_can_tx(op);
 		return;
 	}
 
-	if (op-&gt;flags &amp; RX_FILTER_ID) { /* the easiest case */
+	if (op-&gt;flags &amp; RX_FILTER_ID) {
+		/* the easiest case */
 		DBG(&quot;Easy does it with RX_FILTER_ID\n&quot;);
+
 		bcm_rx_update_and_send(op, &amp;op-&gt;last_frames[0], &amp;rxframe);
 		bcm_rx_starttimer(op);
 		return;
 	}
 
-	if (op-&gt;nframes == 1) { /* simple compare with index 0 */
+	if (op-&gt;nframes == 1) {
+		/* simple compare with index 0 */
 		DBG(&quot;Simple compare\n&quot;);
+
 		bcm_rx_cmp_to_index(op, 0, &amp;rxframe);
 		bcm_rx_starttimer(op);
 		return;
 	}
 
-	if (op-&gt;nframes &gt; 1) { /* multiplex compare */
-
+	if (op-&gt;nframes &gt; 1) {
+		/* multiplex compare */
 		DBG(&quot;Multiplex compare\n&quot;);
-		/* find the first multiplex mask that fits */
-		/* MUX-mask is in index 0 */
 
+		/*
+		 * find the first multiplex mask that fits.
+		 * Remark: The MUX-mask is stored in index 0
+		 */
+
 		for (i=1; i &lt; op-&gt;nframes; i++) {
 
 			if ((GET_U64(&amp;op-&gt;frames[0]) &amp; GET_U64(&amp;rxframe)) ==
@@ -1310,10 +1335,13 @@
 static void bcm_rx_cmp_to_index(struct bcm_op *op, int index,
 				struct can_frame *rxdata)
 {
-	/* no one uses the MSBs of can_dlc for comparation, */
-	/* so we use it here to detect the first time of reception */
+	/*
+	 * no one uses the MSBs of can_dlc for comparation,
+	 * so we use it here to detect the first time of reception
+	 */
 
-	if (!(op-&gt;last_frames[index].can_dlc &amp; RX_RECV)) { /* first time? */
+	if (!(op-&gt;last_frames[index].can_dlc &amp; RX_RECV)) {
+		/* received data for the first time =&gt; send update to user */
 		DBG(&quot;first time :)\n&quot;);
 		bcm_rx_update_and_send(op, &amp;op-&gt;last_frames[index], rxdata);
 		return;
@@ -1357,15 +1385,20 @@
 	unsigned long nexttx = op-&gt;j_lastmsg + op-&gt;j_ival2;
 
 	memcpy(lastdata, rxdata, CFSIZ);
-	lastdata-&gt;can_dlc |= RX_RECV; /* mark as used */
 
+	/* mark as used */
+	lastdata-&gt;can_dlc |= RX_RECV;
+
 	/* throttle bcm_rx_changed ? */
-	if ((op-&gt;thrtimer.expires) || /* somebody else is already waiting OR */
-	    ((op-&gt;j_ival2) &amp;&amp; (nexttx &gt; jiffies))) {      /* we have to wait */
+	if ((op-&gt;thrtimer.expires) ||
+	    ((op-&gt;j_ival2) &amp;&amp; (nexttx &gt; jiffies))) {
+		/* we are already waiting OR we have to start waiting */
 
-		lastdata-&gt;can_dlc |= RX_THR; /* mark as 'throttled' */
+		/* mark as 'throttled' */
+		lastdata-&gt;can_dlc |= RX_THR;
 
-		if (!(op-&gt;thrtimer.expires)) { /* start only the first time */
+		if (!(op-&gt;thrtimer.expires)) {
+			/* start the timer only the first time */
 			op-&gt;thrtimer.expires = nexttx;
 			add_timer(&amp;op-&gt;thrtimer);
 
@@ -1374,8 +1407,10 @@
 			    (char*) op-&gt;thrtimer.data,
 			    (unsigned int) op-&gt;thrtimer.expires);
 		}
-	} else
-		bcm_rx_changed(op, rxdata); /* send RX_CHANGED to the user */
+	} else {
+		/* send RX_CHANGED to the user */
+		bcm_rx_changed(op, rxdata);
+	}
 }
 
 static void bcm_rx_starttimer(struct bcm_op *op)
@@ -1403,10 +1438,13 @@
 	struct bcm_msg_head head;
 
 	op-&gt;j_lastmsg = jiffies;
-	op-&gt;frames_filtered++; /* statistics */
 
+	/* update statistics */
+	op-&gt;frames_filtered++;
+
+	/* prevent statistics overflow */
 	if (op-&gt;frames_filtered &gt; ULONG_MAX/100)
-		op-&gt;frames_filtered = op-&gt;frames_abs = 0; /* restart */
+		op-&gt;frames_filtered = op-&gt;frames_abs = 0;
 
 	DBG(&quot;setting j_lastmsg to 0x%08X for rx_op %p\n&quot;,
 	    (unsigned int) op-&gt;j_lastmsg, op);
@@ -1457,7 +1495,8 @@
 	struct bcm_op *op = (struct bcm_op*)data;
 	int i = 0;
 
-	op-&gt;thrtimer.expires = 0; /* mark disabled / consumed timer */
+	/* mark disabled / consumed timer */
+	op-&gt;thrtimer.expires = 0;
 
 	if (op-&gt;nframes &gt; 1){
 
@@ -1499,6 +1538,7 @@
 		return;
 
 	memcpy(skb_put(skb, sizeof(*head)), head, sizeof(*head));
+
 	/* can_frames starting here */
 	firstframe = (struct can_frame *) skb-&gt;tail;
 
@@ -1514,33 +1554,38 @@
 	if (head-&gt;nframes){
 		memcpy(skb_put(skb, datalen), frames, datalen);
 
-		/* the BCM uses the can_dlc-element of the can_frame */
-		/* structure for internal purposes. This is only     */
-		/* relevant for updates that are generated by the    */
-		/* BCM, where nframes is 1                           */
+		/*
+		 * the BCM uses the can_dlc-element of the can_frame
+		 * structure for internal purposes. This is only
+		 * relevant for updates that are generated by the
+		 * BCM, where nframes is 1
+		 */
 		if (head-&gt;nframes == 1)
 			firstframe-&gt;can_dlc &amp;= BCM_CAN_DLC_MASK;
 	}
-	if ((err = sock_queue_rcv_skb(sk, skb)) &lt; 0) {
+
+	err = sock_queue_rcv_skb(sk, skb);
+	if (err &lt; 0) {
 		struct bcm_opt *bo = bcm_sk(sk);
+
 		DBG(&quot;sock_queue_rcv_skb failed: %d\n&quot;, err);
 		kfree_skb(skb);
-		bo-&gt;dropped_usr_msgs++; /* don't care about overflows */
+		/* don't care about overflows in this statistic */
+		bo-&gt;dropped_usr_msgs++;
 	}
 }
 
-/**************************************************/
 /* bcm_op handling: find &amp; delete bcm_op elements */
-/**************************************************/
 
 static struct bcm_op *bcm_find_op(struct list_head *ops, canid_t can_id,
 				  int ifindex)
 {
 	struct bcm_op *op;
 
-	list_for_each_entry(op, ops, list)
+	list_for_each_entry(op, ops, list) {
 		if ((op-&gt;can_id == can_id) &amp;&amp; (op-&gt;ifindex == ifindex))
 			return op;
+	}
 
 	return NULL;
 }
@@ -1554,12 +1599,15 @@
 			DBG(&quot;removing rx_op %p for can_id %03X\n&quot;,
 			    op, op-&gt;can_id);
 
-			/* Don't care if we're bound or not (due to netdev */
-			/* problems) can_rx_unregister() is always a save  */
-			/* thing to do here.                               */
+			/*
+			 * Don't care if we're bound or not (due to netdev
+			 * problems) can_rx_unregister() is always a save
+			 * thing to do here.
+			 */
 			if (op-&gt;ifindex) {
 				struct net_device *dev =
 					dev_get_by_index(op-&gt;ifindex);
+
 				if (dev) {
 					can_rx_unregister(dev, op-&gt;can_id,
 							  REGMASK(op-&gt;can_id),

Modified: trunk/kernel/2.6/net/can/proc.c
===================================================================
--- trunk/kernel/2.6/net/can/proc.c	2007-04-13 14:13:59 UTC (rev 208)
+++ trunk/kernel/2.6/net/can/proc.c	2007-04-14 19:28:34 UTC (rev 209)
@@ -157,8 +157,10 @@
 		/* the statistics are updated every second (timer triggered) */
 		stattimer.function = can_stat_update;
 		stattimer.data = 0;
-		stattimer.expires = jiffies + HZ; /* every second */
-		add_timer(&amp;stattimer); /* start statistics timer */
+		/* update every second */
+		stattimer.expires = jiffies + HZ;
+		/* start statistics timer */
+		add_timer(&amp;stattimer);
 	}
 }
 
@@ -208,7 +210,7 @@
 
 	rcu_read_lock();
 	hlist_for_each_entry_rcu(r, n, rx_list, list) {
-		char *fmt = r-&gt;can_id &amp; CAN_EFF_FLAG ? /* EFF &amp; CAN_ID_ALL */
+		char *fmt = (r-&gt;can_id &amp; CAN_EFF_FLAG)?
 			&quot;   %-5s  %08X  %08x  %08x  %08x  %8ld  %s\n&quot; :
 			&quot;   %-5s     %03X    %08x  %08x  %08x  %8ld  %s\n&quot;;
 
@@ -218,6 +220,7 @@
 				r-&gt;matches, r-&gt;ident);
 
 		/* does a typical line fit into the current buffer? */
+
 		/* 100 Bytes before end of buffer */
 		if (len &gt; PAGE_SIZE - 100) {
 			/* mark output cut off */
@@ -233,8 +236,10 @@
 
 static int can_print_recv_banner(char *page, int len)
 {
-	/*                  can1.  00000000  00000000  00000000
-			   .......          0  tp20 */
+	/*
+	 *                  can1.  00000000  00000000  00000000
+	 *                 .......          0  tp20
+	 */
 	len += snprintf(page + len, PAGE_SIZE - len,
 			&quot;  device   can_id   can_mask  function&quot;
 			&quot;  userdata   matches  ident\n&quot;);
@@ -363,8 +368,9 @@
 			len += snprintf(page + len, PAGE_SIZE - len,
 					&quot;  (%s: no entry)\n&quot;, DNAME(d-&gt;dev));
 
+		/* exit on end of buffer? */
 		if (len &gt; PAGE_SIZE - 100)
-			break; /* exit on end of buffer */
+			break;
 	}
 	rcu_read_unlock();
 
@@ -396,8 +402,9 @@
 			len += snprintf(page + len, PAGE_SIZE - len,
 					&quot;  (%s: no entry)\n&quot;, DNAME(d-&gt;dev));
 
+		/* exit on end of buffer? */
 		if (len &gt; PAGE_SIZE - 100)
-			break; /* exit on end of buffer */
+			break;
 	}
 	rcu_read_unlock();
 
@@ -429,8 +436,9 @@
 			len += snprintf(page + len, PAGE_SIZE - len,
 					&quot;  (%s: no entry)\n&quot;, DNAME(d-&gt;dev));
 
+		/* exit on end of buffer? */
 		if (len &gt; PAGE_SIZE - 100)
-			break; /* exit on end of buffer */
+			break;
 	}
 	rcu_read_unlock();
 
@@ -475,8 +483,9 @@
 			len += snprintf(page + len, PAGE_SIZE - len,
 					&quot;  (%s: no entry)\n&quot;, DNAME(d-&gt;dev));
 
+		/* exit on end of buffer? */
 		if (len &gt; PAGE_SIZE - 100)
-			break; /* exit on end of buffer */
+			break;
 	}
 	rcu_read_unlock();
 
@@ -508,8 +517,9 @@
 			len += snprintf(page + len, PAGE_SIZE - len,
 					&quot;  (%s: no entry)\n&quot;, DNAME(d-&gt;dev));
 
+		/* exit on end of buffer? */
 		if (len &gt; PAGE_SIZE - 100)
-			break; /* exit on end of buffer */
+			break;
 	}
 	rcu_read_unlock();
 
@@ -541,8 +551,9 @@
 			len += snprintf(page + len, PAGE_SIZE - len,
 					&quot;  (%s: no entry)\n&quot;, DNAME(d-&gt;dev));
 
+		/* exit on end of buffer? */
 		if (len &gt; PAGE_SIZE - 100)
-			break; /* exit on end of buffer */
+			break;
 	}
 	rcu_read_unlock();
 
@@ -609,8 +620,6 @@
 {
 	unsigned long j = jiffies; /* snapshot */
 
-	//DBG(&quot;CAN: can_stat_update() jiffies = %ld\n&quot;, j);
-
 	if (j &lt; stats.jiffies_init) /* jiffies overflow */
 		can_init_stats(2);
 
@@ -618,7 +627,7 @@
 
 	/* prevent overflow in calc_rate() */
 	if (stats.rx_frames &gt; (ULONG_MAX / HZ))
-		can_init_stats(3); /* restart */
+		can_init_stats(3);
 
 	/* matches overflow - very improbable */
 	if (stats.matches &gt; (ULONG_MAX / 100))

Modified: trunk/kernel/2.6/net/can/raw.c
===================================================================
--- trunk/kernel/2.6/net/can/raw.c	2007-04-13 14:13:59 UTC (rev 208)
+++ trunk/kernel/2.6/net/can/raw.c	2007-04-14 19:28:34 UTC (rev 209)
@@ -123,14 +123,15 @@
 };
 
 
-/* A raw socket has a list of can_filters attached to it, each receiving
-   the CAN frames matching that filter.  If the filter list is empty,
-   no CAN frames will be received by the socket.  The default after
-   opening the socket, is to have one filter which receives all frames.
-   The filter list is allocated dynamically with the exception of the
-   list containing only one item.  This common case is optimized by
-   storing the single filter in dfilter, to avoid using dynamic memory.
-*/
+/*
+ * A raw socket has a list of can_filters attached to it, each receiving
+ * the CAN frames matching that filter.  If the filter list is empty,
+ * no CAN frames will be received by the socket.  The default after
+ * opening the socket, is to have one filter which receives all frames.
+ * The filter list is allocated dynamically with the exception of the
+ * list containing only one item.  This common case is optimized by
+ * storing the single filter in dfilter, to avoid using dynamic memory.
+ */
 
 struct raw_opt {
 	int bound;
@@ -149,7 +150,7 @@
 #define RAW_CAP CAP_NET_RAW
 #endif
 
-#undef CAN_RAW_SUPPORT_REBIND /* use bind on already bound socket */
+#undef CAN_RAW_SUPPORT_REBIND /* allow bind on already bound socket */
 
 #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,13)
 struct raw_sock {
@@ -236,6 +237,7 @@
 	/* remove current filters &amp; unregister */
 	if (ro-&gt;bound)
 		raw_remove_filters(dev, sk);
+
 	if (ro-&gt;count &gt; 1)
 		kfree(ro-&gt;filter);
 
@@ -316,9 +318,11 @@
 
 	ro-&gt;ifindex = addr-&gt;can_ifindex;
 
-	raw_add_filters(dev, sk); /* filters set by default/setsockopt */
+	/* filters set by default/setsockopt */
+	raw_add_filters(dev, sk);
 
-	if (ro-&gt;err_mask) /* error frame filter set by setsockopt */
+	/* error frame filter set by setsockopt */
+	if (ro-&gt;err_mask)
 		can_rx_register(dev, 0, ro-&gt;err_mask | CAN_ERR_FLAG,
 				raw_rcv, sk, IDENT);
 
@@ -381,15 +385,20 @@
 
 		count = optlen / sizeof(struct can_filter);
 
-		if (count &gt; 1) { /* does not fit into dfilter */
-			if (!(filter = kmalloc(optlen, GFP_KERNEL)))
+		if (count &gt; 1) {
+			/* filter does not fit into dfilter =&gt; alloc space */
+			filter = kmalloc(optlen, GFP_KERNEL);
+			if (!filter)
 				return -ENOMEM;
-			if ((err = copy_from_user(filter, optval, optlen))) {
+
+			err = copy_from_user(filter, optval, optlen);
+			if (err) {
 				kfree(filter);
 				return err;
 			}
 		} else if (count == 1) {
-			if ((err = copy_from_user(&amp;sfilter, optval, optlen)))
+			err = copy_from_user(&amp;sfilter, optval, optlen);
+			if (err)
 				return err;
 		}
 
@@ -399,10 +408,12 @@
 		/* remove current filters &amp; unregister */
 		if (ro-&gt;bound)
 			raw_remove_filters(dev, sk);
+
 		if (ro-&gt;count &gt; 1)
 			kfree(ro-&gt;filter);
 
-		if (count == 1) { /* copy data for single filter */
+		if (count == 1) {
+			/* copy filter data for single filter */
 			ro-&gt;dfilter = sfilter;
 			filter = &amp;ro-&gt;dfilter;
 		}
@@ -421,7 +432,9 @@
 	case CAN_RAW_ERR_FILTER:
 		if (optlen != sizeof(err_mask))
 			return -EINVAL;
-		if ((err = copy_from_user(&amp;err_mask, optval, optlen)))
+
+		err = copy_from_user(&amp;err_mask, optval, optlen);
+		if (err)
 			return err;
 
 		err_mask &amp;= CAN_ERR_MASK;
@@ -448,15 +461,21 @@
 	case CAN_RAW_LOOPBACK:
 		if (optlen != sizeof(ro-&gt;loopback))
 			return -EINVAL;
-		if ((err = copy_from_user(&amp;ro-&gt;loopback, optval, optlen)))
+
+		err = copy_from_user(&amp;ro-&gt;loopback, optval, optlen);
+		if (err)
 			return err;
+
 		break;
 
 	case CAN_RAW_RECV_OWN_MSGS:
 		if (optlen != sizeof(ro-&gt;recv_own_msgs))
 			return -EINVAL;
-		if ((err = copy_from_user(&amp;ro-&gt;recv_own_msgs, optval, optlen)))
+
+		err = copy_from_user(&amp;ro-&gt;recv_own_msgs, optval, optlen);
+		if (err)
 			return err;
+
 		break;
 
 	default:
@@ -603,24 +622,28 @@
 	if (msg-&gt;msg_name) {
 		struct sockaddr_can *addr =
 			(struct sockaddr_can *)msg-&gt;msg_name;
+
 		if (addr-&gt;can_family != AF_CAN)
 			return -EINVAL;
+
 		ifindex = addr-&gt;can_ifindex;
 	} else
 		ifindex = ro-&gt;ifindex;
 
-	if (!(dev = dev_get_by_index(ifindex))) {
+	dev = dev_get_by_index(ifindex);
+	if (!dev) {
 		DBG(&quot;device %d not found\n&quot;, ifindex);
 		return -ENXIO;
 	}
 
-	if (!(skb = alloc_skb(size, GFP_KERNEL))) {
+	skb = alloc_skb(size, GFP_KERNEL);
+	if (!skb) {
 		dev_put(dev);
 		return -ENOMEM;
 	}
 
-	if ((err = memcpy_fromiovec(skb_put(skb, size),
-				    msg-&gt;msg_iov, size)) &lt; 0) {
+	err = memcpy_fromiovec(skb_put(skb, size), msg-&gt;msg_iov, size);
+	if (err &lt; 0) {
 		kfree_skb(skb);
 		dev_put(dev);
 		return err;
@@ -654,7 +677,8 @@
 	noblock =  flags &amp; MSG_DONTWAIT;
 	flags   &amp;= ~MSG_DONTWAIT;
 
-	if (!(skb = skb_recv_datagram(sk, flags, noblock, &amp;error)))
+	skb = skb_recv_datagram(sk, flags, noblock, &amp;error);
+	if (!skb)
 		return error;
 
 	DBG(&quot;delivering skbuff %p\n&quot;, skb);
@@ -665,7 +689,8 @@
 	else
 		size = skb-&gt;len;
 
-	if ((error = memcpy_toiovec(msg-&gt;msg_iov, skb-&gt;data, size)) &lt; 0) {
+	error = memcpy_toiovec(msg-&gt;msg_iov, skb-&gt;data, size);
+	if (error &lt; 0) {
 		skb_free_datagram(sk, skb);
 		return error;
 	}
@@ -694,7 +719,8 @@
 	DBG_SKB(skb);
 
 	if (!ro-&gt;recv_own_msgs) {
-		if (*(struct sock **)skb-&gt;cb == sk) { /* tx sock reference */
+		/* check the received tx sock reference */
+		if (*(struct sock **)skb-&gt;cb == sk) {
 			DBG(&quot;trashed own tx msg\n&quot;);
 			kfree_skb(skb);
 			return;
@@ -706,7 +732,8 @@
 	addr-&gt;can_family  = AF_CAN;
 	addr-&gt;can_ifindex = skb-&gt;dev-&gt;ifindex;
 
-	if ((error = sock_queue_rcv_skb(sk, skb)) &lt; 0) {
+	error = sock_queue_rcv_skb(sk, skb);
+	if (error &lt; 0) {
 		DBG(&quot;sock_queue_rcv_skb failed: %d\n&quot;, error);
 		DBG(&quot;freeing skbuff %p\n&quot;, skb);
 		kfree_skb(skb);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000192.html">r208 - trunk/kernel/2.6/drivers/net/can/i82527
</A></li>
	<LI>Next message: <A HREF="000194.html">r210 - trunk/kernel/2.6/drivers/net/can
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#193">[ date ]</a>
              <a href="thread.html#193">[ thread ]</a>
              <a href="subject.html#193">[ subject ]</a>
              <a href="author.html#193">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-commit">More information about the Socketcan-commit
mailing list</a><br>
</body></html>
