<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> r123 - trunk/can-utils
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-commit/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r123%20-%20trunk/can-utils&In-Reply-To=%3C200701011829.l01ITu0H026447%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000108.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>r123 - trunk/can-utils</H1>
    <B>hartkopp at mail.berlios.de</B> 
    <A HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r123%20-%20trunk/can-utils&In-Reply-To=%3C200701011829.l01ITu0H026447%40sheep.berlios.de%3E"
       TITLE="r123 - trunk/can-utils">hartkopp at mail.berlios.de
       </A><BR>
    <I>Mon Jan  1 19:29:56 CET 2007</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000108.html">r124 - trunk/kernel/2.6/net/can
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#107">[ date ]</a>
              <a href="thread.html#107">[ thread ]</a>
              <a href="subject.html#107">[ subject ]</a>
              <a href="author.html#107">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hartkopp
Date: 2007-01-01 19:29:52 +0100 (Mon, 01 Jan 2007)
New Revision: 123

Added:
   trunk/can-utils/cangen.c
   trunk/can-utils/log2asc.c
   trunk/can-utils/log2long.c
Modified:
   trunk/can-utils/Makefile
   trunk/can-utils/candump.c
   trunk/can-utils/cansend.c
   trunk/can-utils/lib.c
   trunk/can-utils/lib.h
Log:
- added error frame support in lib.c
- added sprint_* functions for CAN-frame output in lib.c / lib.h
- added comments / cosmetics

candump.c:
- removed support for the output in ASC representation (moved to log2asc.c)
- added option '-l' for logfile creation e.g. 'candump-2007-01-01_164123.log'
- added funtionality to terminate candump by pressing [ENTER] (not only ^C)
- added error frame support
- added color support even when reading from 'any'
- three different color levels (e.g. -c -c -c)
- making use if lib.c

cangen.c:
-  CAN frames generator for testing purposes (e.g. on vcanx)
(nice when you're on vacancy at the baltic sea and have no real CAN source :)

log2long.c:
- convert compact CAN frame representation into user readable representation

log2asc.c:
- convert compact CAN frame logfile to ASC logfile for 3rd party CAN tools

Next step: Create a tool to replay candump logfiles.


Modified: trunk/can-utils/Makefile
===================================================================
--- trunk/can-utils/Makefile	2006-12-14 12:58:00 UTC (rev 122)
+++ trunk/can-utils/Makefile	2007-01-01 18:29:52 UTC (rev 123)
@@ -43,7 +43,7 @@
 CFLAGS    = -O2 -Wall -Wno-parentheses -I../kernel/2.6/include \
 	    -fno-strict-aliasing
 
-PROGRAMS = candump can-sniffer cansend
+PROGRAMS = candump can-sniffer cansend cangen log2long log2asc
 
 all: $(PROGRAMS)
 
@@ -51,8 +51,16 @@
 	rm -f $(PROGRAMS) *.o
 
 distclean:
-	rm -f $(PROGRAMS) *~
+	rm -f $(PROGRAMS) *.o *~
 
-cansend.o: lib.h
+cansend.o:  lib.h
+cangen.o:   lib.h
+candump.o:  lib.h
+log2long.o: lib.h
+log2asc.o:  lib.h
 
-cansend: cansend.o lib.o
+cansend:  cansend.o  lib.o
+cangen:   cangen.o   lib.o
+candump:  candump.o  lib.o
+log2long: log2long.o lib.o
+log2asc:  log2asc.o  lib.o

Modified: trunk/can-utils/candump.c
===================================================================
--- trunk/can-utils/candump.c	2006-12-14 12:58:00 UTC (rev 122)
+++ trunk/can-utils/candump.c	2007-01-01 18:29:52 UTC (rev 123)
@@ -66,9 +66,8 @@
 #include &lt;linux/can/raw.h&gt;
 
 #include &quot;terminal.h&quot;
+#include &quot;lib.h&quot;
 
-#define USE_RECVFROM /* use read() or recvfrom() syscall */
-
 #define MAXDEV 6 /* change sscanf()'s manually if changed here */
 #define ANYDEV &quot;any&quot;
 #define ANL &quot;\r\n&quot; /* newline in ASC mode */
@@ -81,9 +80,13 @@
 #define MAGENTA ATTBOLD FGMAGENTA
 #define CYAN    ATTBOLD FGCYAN
 
-static const char col_on [MAXDEV][19] = {BOLD, MAGENTA, GREEN, BLUE, CYAN, RED};
-static const char col_off [] = ATTRESET;
+const char col_on [MAXDEV][19] = {BOLD, MAGENTA, GREEN, BLUE, CYAN, RED};
+const char col_off [] = ATTRESET;
 
+static char devname[MAXDEV][IFNAMSIZ+1];
+static int  dindex[MAXDEV];
+static int  max_devname_len;
+
 #define MAXANI 8
 const char anichar[MAXANI] = {'|', '/', '-', '\\', '|', '/', '-', '\\'};
 
@@ -97,16 +100,16 @@
     fprintf(stderr, &quot;Options: -m &lt;mask&gt;   (default 0x00000000)\n&quot;);
     fprintf(stderr, &quot;         -v &lt;value&gt;  (default 0x00000000)\n&quot;);
     fprintf(stderr, &quot;         -i &lt;0|1&gt;    (inv_filter)\n&quot;);
+    fprintf(stderr, &quot;         -e &lt;emask&gt;  (mask for error frames)\n&quot;);
     fprintf(stderr, &quot;         -t &lt;type&gt;   (timestamp: Absolute/Delta/Zero)\n&quot;);
     fprintf(stderr, &quot;         -c          (color mode)\n&quot;);
+    fprintf(stderr, &quot;         -a          (enable additional ASCII output)\n&quot;);
     fprintf(stderr, &quot;         -s &lt;level&gt;  (silent mode - 1: animation 2: nothing)\n&quot;);
     fprintf(stderr, &quot;         -b &lt;can&gt;    (bridge mode - send received frames to &lt;can&gt;)\n&quot;);
-    fprintf(stderr, &quot;         -a          (create ASC compatible output)\n&quot;);
-    fprintf(stderr, &quot;         -1          (increment interface numbering in ASC mode)\n&quot;);
-    fprintf(stderr, &quot;         -A          (enable ASCII output)\n&quot;);
+    fprintf(stderr, &quot;         -l          (log CAN-frames into file)\n&quot;);
     fprintf(stderr, &quot;\n&quot;);
     fprintf(stderr, &quot;When using more than one CAN interface the options\n&quot;);
-    fprintf(stderr, &quot;m/v/i have comma seperated values e.g. '-m 0,7FF,0'\n&quot;);
+    fprintf(stderr, &quot;m/v/i/e have comma seperated values e.g. '-m 0,7FF,0'\n&quot;);
     fprintf(stderr, &quot;Use interface name '%s' to receive from all can-interfaces\n&quot;, ANYDEV);
 }
 
@@ -115,6 +118,45 @@
     running = 0;
 }
 
+int idx2dindex(int ifidx, int socket) {
+
+    int i;
+    struct ifreq ifr;
+
+    for (i=0; i&lt;MAXDEV; i++) {
+	if (dindex[i] == ifidx)
+	    return i;
+    }
+
+    /* create new interface index cache entry */
+
+    for (i=0; i &lt; MAXDEV; i++)
+	if (!dindex[i]) /* free entry */
+	    break;
+
+    if (i == MAXDEV) {
+	printf(&quot;BUG in interface index cache! MAXDEV?\n&quot;);
+	exit(1);
+    }
+
+    dindex[i] = ifidx;
+
+    ifr.ifr_ifindex = ifidx;
+    if (ioctl(socket, SIOCGIFNAME, &amp;ifr) &lt; 0)
+	perror(&quot;SIOCGIFNAME&quot;);
+
+    if (max_devname_len &lt; strlen(ifr.ifr_name))
+	max_devname_len = strlen(ifr.ifr_name);
+
+    strcpy(devname[i], ifr.ifr_name);
+
+#ifdef DEBUG
+    printf(&quot;new index %d (%s)\n&quot;, i, devname[i]);
+#endif
+
+    return i;
+}
+
 int main(int argc, char **argv)
 {
     fd_set rdfs;
@@ -123,15 +165,13 @@
     canid_t mask[MAXDEV] = {0};
     canid_t value[MAXDEV] = {0};
     int inv_filter[MAXDEV] = {0};
-    char devname[MAXDEV][IFNAMSIZ];
+    can_err_mask_t err_mask[MAXDEV] = {0};
     unsigned char timestamp = 0;
     unsigned char silent = 0;
     unsigned char silentani = 0;
     unsigned char color = 0;
     unsigned char ascii = 0;
-    unsigned char asc = 0;
-    unsigned char asc_inc_channel = 0;
-    int max_devname_len = 0;
+    unsigned char log = 0;
     int opt, ret;
     int currmax = 1; /* we assume at least one can bus ;-) */
     struct sockaddr_can addr;
@@ -139,9 +179,8 @@
     struct can_frame frame;
     int nbytes, i, j;
     struct ifreq ifr;
-
-    time_t currtime;
     struct timeval tv, last_tv;
+    FILE *logfile = NULL;
 
     signal(SIGTERM, sigterm);
     signal(SIGHUP, sigterm);
@@ -149,7 +188,7 @@
 
     last_tv.tv_sec = 0; /* init */
 
-    while ((opt = getopt(argc, argv, &quot;m:v:i:b:s:ca1At:&quot;)) != -1) {
+    while ((opt = getopt(argc, argv, &quot;m:v:i:e:t:cas:b:l&quot;)) != -1) {
 	switch (opt) {
 	case 'm':
 	    i = sscanf(optarg, &quot;%x,%x,%x,%x,%x,%x&quot;,
@@ -175,6 +214,36 @@
 		currmax = i;
 	    break;
 
+	case 'e':
+	    i = sscanf(optarg, &quot;%x,%x,%x,%x,%x,%x&quot;,
+		       &amp;err_mask[0], &amp;err_mask[1], &amp;err_mask[2],
+		       &amp;err_mask[3], &amp;err_mask[4], &amp;err_mask[5]);
+	    if (i &gt; currmax)
+		currmax = i;
+	    break;
+
+	case 't':
+	    timestamp = optarg[0];
+	    if ((timestamp != 'a') &amp;&amp; (timestamp != 'A') &amp;&amp;
+		(timestamp != 'd') &amp;&amp; (timestamp != 'z')) {
+		printf(&quot;%s: unknown timestamp mode '%c' - ignored\n&quot;,
+		       basename(argv[0]), optarg[0]);
+		timestamp = 0;
+	    }
+	    break;
+
+	case 'c':
+	    color++;
+	    break;
+
+	case 'a':
+	    ascii = 1;
+	    break;
+
+	case 's':
+	    silent = atoi(optarg);
+	    break;
+
 	case 'b':
 	    if (strlen(optarg) &gt;= IFNAMSIZ) {
 		printf(&quot;Name of CAN device '%s' is too long!\n\n&quot;, optarg);
@@ -203,40 +272,14 @@
 	    }
 	    break;
 	    
-	case 's':
-	    silent = atoi(optarg);
+	case 'l':
+	    log = 1;
 	    break;
 
-	case 'c':
-	    color = 1;
-	    break;
-
-	case 'a':
-	    asc = 1;
-	    break;
-
-	case '1':
-	    asc_inc_channel = 1;
-	    break;
-
-	case 'A':
-	    ascii = 1;
-	    break;
-
-	case 't':
-	    timestamp = optarg[0];
-	    if ((timestamp != 'a') &amp;&amp; (timestamp != 'A') &amp;&amp; (timestamp != 'd') &amp;&amp; (timestamp != 'z')) {
-		printf(&quot;%s: unknown timestamp mode '%c' - ignored\n&quot;,
-		       basename(argv[0]), optarg[0]);
-		timestamp = 0;
-	    }
-	    break;
-
-	case '?':
-	    break;
-
 	default:
 	    fprintf(stderr, &quot;Unknown option %c\n&quot;, opt);
+	    print_usage(basename(argv[0]));
+	    exit(1);
 	    break;
 	}
     }
@@ -262,8 +305,9 @@
     for (i=0; i&lt;currmax; i++) {
 
 #ifdef DEBUG
-	printf(&quot;open %d '%s' m%08X v%08X i%d.\n&quot;,
-	       i, argv[optind+i], mask[i], value[i], inv_filter[i]);
+	printf(&quot;open %d '%s' m%08X v%08X i%d e%d.\n&quot;,
+	       i, argv[optind+i], mask[i], value[i],
+	       inv_filter[i], err_mask[i]);
 #endif
 
 	if ((s[i] = socket(PF_CAN, SOCK_RAW, CAN_RAW)) &lt; 0) {
@@ -273,19 +317,24 @@
 
 	if (mask[i] || value[i]) {
 
-	    if (!(asc)) /* this output is not asc compatible! */
-		printf(&quot;CAN ID filter[%d] for %s set to mask = %08X, value = %08X %s\n&quot;,
-		       i, argv[optind+i], mask[i], value[i],
-		       (inv_filter[i]) ? &quot;(inv_filter)&quot; : &quot;&quot;);
+	    printf(&quot;CAN ID filter[%d] for %s set to &quot;
+		   &quot;mask = %08X, value = %08X %s\n&quot;,
+		   i, argv[optind+i], mask[i], value[i],
+		   (inv_filter[i]) ? &quot;(inv_filter)&quot; : &quot;&quot;);
 
 	    rfilter.can_id   = value[i];
 	    rfilter.can_mask = mask[i];
 	    if (inv_filter[i])
 		rfilter.can_id |= CAN_INV_FILTER;
 
-	    setsockopt(s[i], SOL_CAN_RAW, CAN_RAW_FILTER, &amp;rfilter, sizeof(rfilter));
+	    setsockopt(s[i], SOL_CAN_RAW, CAN_RAW_FILTER,
+		       &amp;rfilter, sizeof(rfilter));
 	}
 
+	if (err_mask[i])
+	    setsockopt(s[i], SOL_CAN_RAW, CAN_RAW_ERR_FILTER,
+		       &amp;err_mask[i], sizeof(err_mask[i]));
+
 	j = strlen(argv[optind+i]);
 
 	if (!(j &lt; IFNAMSIZ)) {
@@ -293,8 +342,6 @@
 	    return 1;
 	}
 
-	strcpy(devname[i], argv[optind+i]);
-
 	if (j &gt; max_devname_len)
 	    max_devname_len = j; /* for nice printing */
 
@@ -302,8 +349,10 @@
 
 	if (strcmp(ANYDEV, argv[optind+i])) {
 	    strcpy(ifr.ifr_name, argv[optind+i]);
-	    if (ioctl(s[i], SIOCGIFINDEX, &amp;ifr) &lt; 0)
+	    if (ioctl(s[i], SIOCGIFINDEX, &amp;ifr) &lt; 0) {
 		perror(&quot;SIOCGIFINDEX&quot;);
+		exit(1);
+	    }
 	    addr.can_ifindex = ifr.ifr_ifindex;
 	}
 	else
@@ -315,31 +364,39 @@
 	}
     }
 
-    if (asc) {
-	char datestring[40];
+    if (log) {
+	time_t currtime;
+	struct tm now;
+	char fname[sizeof(&quot;candump-2006-11-20_202026.log&quot;)+1];
 
-	/* print banner for ASC mode */
-
-	if (timestamp != 'd') /* delta time is allowed, else ... */
-	    timestamp = 'z'; /* ASC-files always start with zero time */
-
 	if (time(&amp;currtime) == (time_t)-1) {
 	    perror(&quot;time&quot;);
 	    return 1;
 	}
-	strncpy(datestring, ctime(&amp;currtime), 39); /* copy to private buffer */
-	datestring[strlen(datestring)-1] = 0; /* chop off trailing newline */
-	printf(&quot;date %s%s&quot;, datestring, ANL); /* print with own new line representation */
 
-	printf(&quot;base hex  timestamps %s%s&quot;, (timestamp == 'd')?&quot;relative&quot;:&quot;absolute&quot;, ANL);
-	printf(&quot;no internal events logged%s&quot;, ANL);
-	fflush(stdout);
+	localtime_r(&amp;currtime, &amp;now);
+
+	sprintf(fname, &quot;candump-%04d-%02d-%02d_%02d%02d%02d.log&quot;,
+	       now.tm_year + 1900,
+	       now.tm_mon + 1,
+	       now.tm_mday,
+	       now.tm_hour,
+	       now.tm_min,
+	       now.tm_sec);
+
+	printf(&quot;\nEnabling Logfile '%s'\n\n&quot;, fname);
+
+	logfile = fopen(fname, &quot;w&quot;);
+	if (!logfile) {
+	    perror(&quot;logfile&quot;);
+	    return 1;
+	}
     }
 
     while (running) {
 
 	FD_ZERO(&amp;rdfs);
-
+	FD_SET(0, &amp;rdfs);
 	for (i=0; i&lt;currmax; i++)
 	    FD_SET(s[i], &amp;rdfs);
 
@@ -349,155 +406,118 @@
 	    continue;
 	}
 
-	for (i=0; i&lt;currmax; i++) {
+	if (FD_ISSET(0, &amp;rdfs)) {
+	    running = 0; /* stop with input from stdin */
+	    getchar();
+	}
 
+	for (i=0; i&lt;currmax; i++) {  /* check all CAN RAW sockets */
+
 	    if (FD_ISSET(s[i], &amp;rdfs)) {
 
-#ifdef USE_RECVFROM
 		socklen_t len = sizeof(addr);
-		if ((nbytes = recvfrom(s[i], &amp;frame, sizeof(struct can_frame), 0, (struct sockaddr*)&amp;addr, &amp;len)) &lt; 0) {
-#else
-		if ((nbytes = read(s[i], &amp;frame, sizeof(struct can_frame))) &lt; 0) {
-#endif
+		int idx;
+
+		if ((nbytes = recvfrom(s[i], &amp;frame,
+				       sizeof(struct can_frame), 0,
+				       (struct sockaddr*)&amp;addr, &amp;len)) &lt; 0) {
 		    perror(&quot;read&quot;);
 		    return 1;
-		} else if (nbytes &lt; sizeof(struct can_frame)) {
+		}
+
+		if (nbytes &lt; sizeof(struct can_frame)) {
 		    fprintf(stderr, &quot;read: incomplete CAN frame\n&quot;);
 		    return 1;
-		} else {
-		    if (bridge) {
-			if ((nbytes = write(bridge, &amp;frame, sizeof(struct can_frame))) &lt; 0) {
-			    perror(&quot;bridge write&quot;);
-			    return 1;
-			} else if (nbytes &lt; sizeof(struct can_frame)) {
-			    fprintf(stderr, &quot;bridge write: incomplete CAN frame\n&quot;);
-			    return 1;
-			}
+		}
+
+		if (bridge) {
+		    if ((nbytes = write(bridge, &amp;frame,
+					sizeof(struct can_frame))) &lt; 0) {
+			perror(&quot;bridge write&quot;);
+			return 1;
+		    } else if (nbytes &lt; sizeof(struct can_frame)) {
+			fprintf(stderr,&quot;bridge write: incomplete CAN frame\n&quot;);
+			return 1;
 		    }
+		}
 		    
-		    if (silent){
-		      if (silent == 1)
-			printf(&quot;%c\b&quot;, anichar[silentani%=MAXANI]), silentani++;
-		    }
-		    else {
-		      
-			switch (timestamp) {
+		if (timestamp || log)
+		    if (ioctl(s[i], SIOCGSTAMP, &amp;tv) &lt; 0)
+			perror(&quot;SIOCGSTAMP&quot;);
 
-			case 'a': /* absolute with timestamp */
-			    if (ioctl(s[i], SIOCGSTAMP, &amp;tv) &lt; 0)
-				perror(&quot;SIOCGSTAMP&quot;);
-			    if (asc)
-				printf(&quot;%4ld.%04ld &quot;, tv.tv_sec, tv.tv_usec/100);
-			    else
-				printf(&quot;(%ld.%06ld) &quot;, tv.tv_sec, tv.tv_usec);
-			    break;
 
-			case 'A': /* absolute with date */
-			    {
-				struct tm tm;
-				char timestring[25];
-				if (ioctl(s[i], SIOCGSTAMP, &amp;tv) &lt; 0)
-				    perror(&quot;SIOCGSTAMP&quot;);
-				tm = *localtime(&amp;tv.tv_sec);
-				strftime(timestring, 24, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm);
-				if (asc)
-				    printf(&quot;%s.%04ld &quot;, timestring, tv.tv_usec/100);
-				else
-				    printf(&quot;(%s.%06ld) &quot;, timestring, tv.tv_usec);
-			    }
-			    break;
+		idx = idx2dindex(addr.can_ifindex, s[i]);
 
-			case 'd': /* delta */
-			case 'z': /* starting with zero */
-			    {
-				struct timeval diff;
+		if (log) {
+		    /* log CAN frame with absolute timestamp &amp; device */
+		    fprintf(logfile, &quot;(%ld.%06ld) &quot;, tv.tv_sec, tv.tv_usec);
+		    fprintf(logfile, &quot;%*s&quot;, max_devname_len, devname[idx]);
+		    fprintf(logfile, &quot; &quot;);
+		    /* without seperator as logfile use-case is parsing */
+		    fprint_canframe(logfile, &amp;frame, &quot;\n&quot;, 0);
+		}
 
-				if (ioctl(s[i], SIOCGSTAMP, &amp;tv) &lt; 0)
-				    perror(&quot;SIOCGSTAMP&quot;);
-				if (last_tv.tv_sec == 0)   /* first init */
-				    last_tv = tv;
-				diff.tv_sec  = tv.tv_sec  - last_tv.tv_sec;
-				diff.tv_usec = tv.tv_usec - last_tv.tv_usec;
-				if (diff.tv_usec &lt; 0)
-				    diff.tv_sec--, diff.tv_usec += 1000000;
-				if (diff.tv_sec &lt; 0)
-				    diff.tv_sec = diff.tv_usec = 0;
-				if (asc)
-				    printf(&quot;%4ld.%04ld &quot;, diff.tv_sec, diff.tv_usec/100);
-				else
-				    printf(&quot;(%ld.%06ld) &quot;, diff.tv_sec, diff.tv_usec);
-				
-				if (timestamp == 'd')
-				    last_tv = tv; /* update for delta calculation */
-			    }
-			    break;
+		if (silent){
+		    if (silent == 1) {
+			printf(&quot;%c\b&quot;, anichar[silentani%=MAXANI]);
+			silentani++;
+		    }
+		    continue;
+		}
+		      
+		printf(&quot; %s&quot;,(color&gt;2)?col_on[idx]:&quot;&quot;);
 
-			default: /* no timestamp output */
-			    break;
-			}
+		switch (timestamp) {
 
-			if (asc) {
-			    char id[10];
+		case 'a': /* absolute with timestamp */
+		    printf(&quot;(%ld.%06ld) &quot;, tv.tv_sec, tv.tv_usec);
+		    break;
 
-			    printf(&quot;%-2d &quot;, i + asc_inc_channel); /* channel number - left aligned */
+		case 'A': /* absolute with date */
+		    {
+			struct tm tm;
+			char timestring[25];
 
-			    sprintf(id, &quot;%X%c&quot;, frame.can_id &amp; CAN_EFF_MASK,
-				    (frame.can_id &amp; CAN_EFF_FLAG)?'x':' ');
-			    printf(&quot;%-15s Rx   &quot;, id);
+			tm = *localtime(&amp;tv.tv_sec);
+			strftime(timestring, 24, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm);
+			printf(&quot;(%s.%06ld) &quot;, timestring, tv.tv_usec);
+		    }
+		    break;
 
-			    if (frame.can_id &amp; CAN_RTR_FLAG)
-				printf(&quot;r&quot;); /* RTR frame: nothing else to print */
-			    else {
-				printf(&quot;d %d &quot;, frame.can_dlc); /* data frame */
+		case 'd': /* delta */
+		case 'z': /* starting with zero */
+		    {
+			struct timeval diff;
 
-				for (j = 0; j &lt; frame.can_dlc; j++) {
-				    printf(&quot;%02X &quot;, frame.data[j]);
-				}
-			    }
-			    printf(&quot;%s&quot;, ANL);
-			}
-			else {
-			    printf(&quot; %s&quot;,(color)?col_on[i]:&quot;&quot;);
-#ifdef USE_RECVFROM
-			    ifr.ifr_ifindex = addr.can_ifindex;
-			    if (ioctl(s[i], SIOCGIFNAME, &amp;ifr) &lt; 0)
-				perror(&quot;SIOCGIFNAME&quot;);
+			if (last_tv.tv_sec == 0)   /* first init */
+			    last_tv = tv;
+			diff.tv_sec  = tv.tv_sec  - last_tv.tv_sec;
+			diff.tv_usec = tv.tv_usec - last_tv.tv_usec;
+			if (diff.tv_usec &lt; 0)
+			    diff.tv_sec--, diff.tv_usec += 1000000;
+			if (diff.tv_sec &lt; 0)
+			    diff.tv_sec = diff.tv_usec = 0;
+			printf(&quot;(%ld.%06ld) &quot;, diff.tv_sec, diff.tv_usec);
+				
+			if (timestamp == 'd')
+			    last_tv = tv; /* update for delta calculation */
+		    }
+		    break;
 
-			    if (max_devname_len &lt; strlen(ifr.ifr_name))
-				max_devname_len = strlen(ifr.ifr_name);
+		default: /* no timestamp output */
+		    break;
+		}
 
-			    printf(&quot;%*s&quot;, max_devname_len, ifr.ifr_name);
-#else
-			    printf(&quot;%*s&quot;, max_devname_len, devname[i]); /* device name */
-#endif
-			    printf(&quot;%s  &quot;,(color)?col_off:&quot;&quot;);
-			    if (frame.can_id &amp; CAN_EFF_FLAG)
-				printf(&quot;%8X  &quot;, frame.can_id &amp; CAN_EFF_MASK);
-			    else
-				printf(&quot;%3X  &quot;, frame.can_id &amp; CAN_SFF_MASK);
+		printf(&quot; %s&quot;,(color &amp;&amp; (color&lt;3))?col_on[idx]:&quot;&quot;);
+		printf(&quot;%*s&quot;, max_devname_len, devname[idx]);
+		printf(&quot;%s  &quot;,(color&lt;2)?col_off:&quot;&quot;);
 
-			    printf(&quot;[%d] &quot;, frame.can_dlc);
+		fprint_long_canframe(stdout, &amp;frame, NULL, ascii);
 
-			    for (j = 0; j &lt; frame.can_dlc; j++) {
-				printf(&quot;%02X &quot;, frame.data[j]);
-			    }
-			    if (ascii) {
-				printf(&quot;%*s&quot;, 3*(8-frame.can_dlc)+3, &quot;'&quot;);
-				for (j = 0; j &lt; frame.can_dlc; j++)
-				    if ((frame.data[j] &gt; 0x1F) &amp;&amp; (frame.data[j] &lt; 0x7F))
-					putchar(frame.data[j]);
-				    else
-					putchar('.');
-				printf(&quot;' &quot;);
-			    }
-			    if (frame.can_id &amp; CAN_RTR_FLAG)
-				printf(&quot;remote request&quot;);
-			    printf(&quot;\n&quot;);
-			}
-		    }
-		    fflush(stdout);
-		}
+		printf(&quot;%s&quot;,(color&gt;1)?col_off:&quot;&quot;);
+		printf(&quot;\n&quot;);
 	    }
+	    fflush(stdout);
 	}
     }
 
@@ -507,5 +527,8 @@
     if (bridge)
       close(bridge);
 
+    if (log)
+	fclose(logfile);
+
     return 0;
 }

Added: trunk/can-utils/cangen.c
===================================================================
--- trunk/can-utils/cangen.c	2006-12-14 12:58:00 UTC (rev 122)
+++ trunk/can-utils/cangen.c	2007-01-01 18:29:52 UTC (rev 123)
@@ -0,0 +1,262 @@
+/*
+ *  $Id$
+ */
+
+/*
+ * cangen.c - CAN frames generator for testing purposes
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
+ *
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;string.h&gt;
+#include &lt;signal.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;libgen.h&gt;
+#include &lt;time.h&gt;
+#include &lt;errno.h&gt;
+
+#include &lt;sys/time.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/ioctl.h&gt;
+#include &lt;sys/uio.h&gt;
+#include &lt;net/if.h&gt;
+
+#include &lt;linux/can.h&gt;
+#include &lt;linux/can/raw.h&gt;
+#include &quot;lib.h&quot;
+
+#define DEFAULT_GAP 200 /* ms */
+
+extern int optind, opterr, optopt;
+
+static volatile int running = 1;
+
+void print_usage(char *prg)
+{
+    fprintf(stderr, &quot;\n%s: generate random CAN frames\n\n&quot;, prg);
+    fprintf(stderr, &quot;Usage: %s [can-interface]\n&quot;, prg);
+    fprintf(stderr, &quot;Options: -g &lt;ms&gt;       (gap in milli seconds)  &quot;
+	    &quot;default: %d\n&quot;, DEFAULT_GAP);
+    fprintf(stderr, &quot;         -e            (extended frame mode)   &quot;
+	    &quot;default: standard frame format \n&quot;);
+    fprintf(stderr, &quot;         -I            (fixed CAN ID)          &quot;
+	    &quot;default: 0x123\n&quot;);
+    fprintf(stderr, &quot;         -D            (fixed CAN Data)        &quot;
+	    &quot;default: 01 23 45 67 89 AB CD EF\n&quot;);
+    fprintf(stderr, &quot;         -L            (fixed CAN DLC)         &quot;
+	    &quot;default: 8\n&quot;);
+    fprintf(stderr, &quot;         -f &lt;canframe&gt; (other fixed CAN frame) &quot;
+	    &quot;default: 123#0123456789ABCDEF\n&quot;);
+    fprintf(stderr, &quot;         -v            (verbose)               &quot;
+	    &quot;default: don't print sent frames\n&quot;);
+}
+
+void sigterm(int signo)
+{
+    running = 0;
+}
+
+int main(int argc, char **argv)
+{
+    unsigned long gap = DEFAULT_GAP; 
+    unsigned char extended = 0;
+    unsigned char fix_id = 0;
+    unsigned char fix_data = 0;
+    unsigned char fix_dlc = 0;
+    unsigned char default_frame = 1;
+    unsigned char verbose = 0;
+
+    int opt;
+    int s; /* socket */
+
+    struct sockaddr_can addr;
+    static struct can_frame frame;
+    int nbytes;
+    struct ifreq ifr;
+
+    struct timespec ts;
+
+    signal(SIGTERM, sigterm);
+    signal(SIGHUP, sigterm);
+    signal(SIGINT, sigterm);
+
+    while ((opt = getopt(argc, argv, &quot;g:eIDLf:v&quot;)) != -1) {
+	switch (opt) {
+	case 'g':
+	    gap = strtoul(optarg, NULL, 10);
+	    break;
+
+	case 'e':
+	    extended = 1;
+	    break;
+
+	case 'I':
+	    fix_id = 1;
+	    break;
+
+	case 'D':
+	    fix_data = 1;
+	    break;
+
+	case 'L':
+	    fix_dlc = 1;
+	    break;
+
+	case 'f':
+	    default_frame = 0;
+	    if (parse_canframe(optarg, &amp;frame)) {
+		fprintf(stderr, &quot;'%s' is a wrong CAN frame format.\n&quot;, optarg);
+		exit(1);
+	    }
+	    break;
+
+	case 'v':
+	    verbose = 1;
+	    break;
+
+	default:
+	    print_usage(basename(argv[0]));
+	    exit(1);
+	    break;
+	}
+    }
+
+    if (optind == argc) {
+	print_usage(basename(argv[0]));
+	exit(0);
+    }
+
+    ts.tv_sec = gap / 1000;
+    ts.tv_nsec = (gap % 1000) * 1000000;
+
+
+    if (default_frame) {
+	if (extended)
+	    frame.can_id = 0x12345678 | CAN_EFF_FLAG;
+	else
+	    frame.can_id = 0x123;
+
+	frame.can_dlc = 8;
+
+	frame.data[0] = 0x01;
+	frame.data[1] = 0x23;
+	frame.data[2] = 0x45;
+	frame.data[3] = 0x67;
+	frame.data[4] = 0x89;
+	frame.data[5] = 0xAB;
+	frame.data[6] = 0xCD;
+	frame.data[7] = 0xEF;
+    }
+
+    if ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) &lt; 0) {
+	perror(&quot;socket&quot;);
+	return 1;
+    }
+
+    addr.can_family = AF_CAN;
+
+    strcpy(ifr.ifr_name, argv[optind]);
+    if (ioctl(s, SIOCGIFINDEX, &amp;ifr) &lt; 0)
+	perror(&quot;SIOCGIFINDEX&quot;);
+    addr.can_ifindex = ifr.ifr_ifindex;
+
+    /* disable default receive filter on this RAW socket */
+    /* This is obsolete as we do not read from the socket at all, but for */
+    /* this reason we can remove the receive list in the Kernel to save a */
+    /* little (really a very little!) CPU usage.                          */
+    setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
+
+    if (bind(s, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) {
+	perror(&quot;bind&quot;);
+	return 1;
+    }
+
+    while (running) {
+
+	if (!fix_id) {
+	    frame.can_id = random();
+	    if (extended) {
+		frame.can_id &amp;= CAN_EFF_MASK;
+		frame.can_id |= CAN_EFF_FLAG;
+	    } else
+		frame.can_id &amp;= CAN_SFF_MASK;
+	}
+
+	if (!fix_dlc) {
+	    frame.can_dlc = random() &amp; 0xF;
+	    if (frame.can_dlc &amp; 8)
+		frame.can_dlc = 8; /* for about 50% of the frames */
+	}
+
+	if (!fix_data) {
+	    /* that's what the 64 bit alignment of data[] is for ... :) */
+	    *(unsigned long*)(&amp;frame.data[0]) = random();
+	    *(unsigned long*)(&amp;frame.data[4]) = random();
+	}
+
+	if ((nbytes = write(s, &amp;frame, sizeof(struct can_frame))) &lt; 0) {
+	    perror(&quot;write&quot;);
+	    return 1;
+	} else if (nbytes &lt; sizeof(struct can_frame)) {
+	    fprintf(stderr, &quot;write: incomplete CAN frame\n&quot;);
+	    return 1;
+	}
+
+	if (gap) /* gap == 0 =&gt; performance test :-] */
+	    if (nanosleep(&amp;ts, NULL))
+		return 1;
+		    
+	if (verbose)
+#if 0
+	    fprint_long_canframe(stdout, &amp;frame, &quot;\n&quot;, 1);
+#else
+	    fprint_canframe(stdout, &amp;frame, &quot;\n&quot;, 1);
+#endif
+    }
+
+    close(s);
+
+    return 0;
+}


Property changes on: trunk/can-utils/cangen.c
___________________________________________________________________
Name: svn:keywords
   + Id

Modified: trunk/can-utils/cansend.c
===================================================================
--- trunk/can-utils/cansend.c	2006-12-14 12:58:00 UTC (rev 122)
+++ trunk/can-utils/cansend.c	2007-01-01 18:29:52 UTC (rev 123)
@@ -109,7 +109,7 @@
       return 1;
     }
 
-    //fprint_canframe(stdout, &amp;frame, &quot;\n&quot;);
+    //fprint_long_canframe(stdout, &amp;frame, &quot;\n&quot;, 0);
 
     close(s);
 

Modified: trunk/can-utils/lib.c
===================================================================
--- trunk/can-utils/lib.c	2006-12-14 12:58:00 UTC (rev 122)
+++ trunk/can-utils/lib.c	2007-01-01 18:29:52 UTC (rev 123)
@@ -52,11 +52,16 @@
 #include &lt;sys/socket.h&gt; /* for sa_family_t */
 #include &lt;linux/can.h&gt;
 
+#include &quot;lib.h&quot;
+
 #define CANID_DELIM '#'
 #define DATA_SEPERATOR '.'
 
-static int asc2nibble(char c){
+#define MAX_CANFRAME      &quot;12345678#01.23.45.67.89.AB.CD.EF&quot;
+#define MAX_LONG_CANFRAME &quot;12345678  [8] 01 23 45 67 89 AB CD EF   '........'&quot;
 
+static int asc2nibble(char c) {
+
     if ((c &gt;= '0') &amp;&amp; (c &lt;= '9'))
 	return c - '0';
 
@@ -69,7 +74,7 @@
     return 16; /* error */
 }
 
-int parse_canframe(char *cs, struct can_frame *cf){
+int parse_canframe(char *cs, struct can_frame *cf) {
     /* documentation see lib.h */
 
     int i, idx, dlc, len, tmp;
@@ -85,17 +90,18 @@
     if (!((cs[3] == CANID_DELIM) || (cs[8] == CANID_DELIM)))
 	return 1;
 
-    if (cs[8] == CANID_DELIM) {
+    if (cs[8] == CANID_DELIM) { /* 8 digits */
 
 	idx = 9;
-	cf-&gt;can_id = CAN_EFF_FLAG;
 	for (i=0; i&lt;8; i++){
 	    if ((tmp = asc2nibble(cs[i])) &gt; 0x0F)
 		return 1;
 	    cf-&gt;can_id |= (tmp &lt;&lt; (7-i)*4);
 	}
+	if (!(cf-&gt;can_id &amp; CAN_ERR_FLAG)) /* 8 digits but no errorframe?  */
+	    cf-&gt;can_id |= CAN_EFF_FLAG;   /* then it is an extended frame */
 
-    } else {
+    } else { /* 3 digits */
 
 	idx = 4;
 	for (i=0; i&lt;3; i++){
@@ -132,24 +138,96 @@
     return 0;
 }
 
-void fprint_canframe(FILE *stream , struct can_frame *cf, char *eol){
+void fprint_canframe(FILE *stream , struct can_frame *cf, char *eol, int sep) {
     /* documentation see lib.h */
 
-    int i;
+    char buf[sizeof(MAX_CANFRAME)+1]; /* max length */
 
-    if (cf-&gt;can_id &amp; CAN_EFF_FLAG)
-	fprintf(stream, &quot;%8X  &quot;, cf-&gt;can_id &amp; CAN_EFF_MASK);
+    sprint_canframe(buf, cf, sep);
+    fprintf(stream, &quot;%s&quot;, buf);
+    if (eol)
+	fprintf(stream, &quot;%s&quot;, eol);
+}
+
+void sprint_canframe(char *buf , struct can_frame *cf, int sep) {
+    /* documentation see lib.h */
+
+    int i,offset;
+
+    if (cf-&gt;can_id &amp; CAN_ERR_FLAG) {
+	sprintf(buf, &quot;%08X#&quot;, cf-&gt;can_id &amp; (CAN_ERR_MASK|CAN_ERR_FLAG));
+	offset = 9;
+    } else if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
+	sprintf(buf, &quot;%08X#&quot;, cf-&gt;can_id &amp; CAN_EFF_MASK);
+	offset = 9;
+    } else {
+	sprintf(buf, &quot;%03X#&quot;, cf-&gt;can_id &amp; CAN_SFF_MASK);
+	offset = 4;
+    }
+
+    if (cf-&gt;can_id &amp; CAN_RTR_FLAG) /* there are no ERR frames with RTR */
+	sprintf(buf+offset, &quot;R&quot;);
     else
-	fprintf(stream, &quot;%3X  &quot;, cf-&gt;can_id &amp; CAN_SFF_MASK);
+	for (i = 0; i &lt; cf-&gt;can_dlc; i++) {
+	    sprintf(buf+offset, &quot;%02X&quot;, cf-&gt;data[i]);
+	    offset += 2;
+	    if (sep &amp;&amp; (i+1 &lt; cf-&gt;can_dlc))
+		sprintf(buf+offset++, &quot;.&quot;);
+	}
 
-    fprintf(stream, &quot;[%d] &quot;, cf-&gt;can_dlc);
 
-    for (i = 0; i &lt; cf-&gt;can_dlc; i++) {
-	fprintf(stream, &quot;%02X &quot;, cf-&gt;data[i]);
-    }
-    if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
-	fprintf(stream, &quot;remote request&quot;);
+}
+
+void fprint_long_canframe(FILE *stream , struct can_frame *cf, char *eol, int ascii) {
+    /* documentation see lib.h */
+
+    char buf[sizeof(MAX_LONG_CANFRAME)+1]; /* max length */
+
+    sprint_long_canframe(buf, cf, ascii);
+    fprintf(stream, &quot;%s&quot;, buf);
     if (eol)
 	fprintf(stream, &quot;%s&quot;, eol);
 }
 
+void sprint_long_canframe(char *buf , struct can_frame *cf, int ascii) {
+    /* documentation see lib.h */
+
+    int i, offset;
+
+    if (cf-&gt;can_id &amp; CAN_ERR_FLAG) {
+	sprintf(buf, &quot;%8X  &quot;, cf-&gt;can_id &amp; (CAN_ERR_MASK|CAN_ERR_FLAG));
+	offset = 10;
+    } else if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
+	sprintf(buf, &quot;%8X  &quot;, cf-&gt;can_id &amp; CAN_EFF_MASK);
+	offset = 10;
+    } else {
+	sprintf(buf, &quot;%3X  &quot;, cf-&gt;can_id &amp; CAN_SFF_MASK);
+	offset = 5;
+    }
+
+    sprintf(buf+offset, &quot;[%d]&quot;, cf-&gt;can_dlc);
+    offset += 3;
+
+    if (cf-&gt;can_id &amp; CAN_RTR_FLAG) /* there are no ERR frames with RTR */
+	sprintf(buf+offset, &quot; remote request&quot;);
+    else {
+	for (i = 0; i &lt; cf-&gt;can_dlc; i++) {
+	    sprintf(buf+offset, &quot; %02X&quot;, cf-&gt;data[i]);
+	    offset += 3;
+	}
+	if (cf-&gt;can_id &amp; CAN_ERR_FLAG)
+	    sprintf(buf+offset, &quot;%*s&quot;, 3*(8-cf-&gt;can_dlc)+13, &quot;ERRORFRAME&quot;);
+	else if (ascii) {
+	    sprintf(buf+offset, &quot;%*s&quot;, 3*(8-cf-&gt;can_dlc)+4, &quot;'&quot;);
+	    offset += 3*(8-cf-&gt;can_dlc)+4;
+
+	    for (i = 0; i &lt; cf-&gt;can_dlc; i++)
+		if ((cf-&gt;data[i] &gt; 0x1F) &amp;&amp; (cf-&gt;data[i] &lt; 0x7F))
+		    buf[offset++] = cf-&gt;data[i];
+		else
+		    buf[offset++] = '.';
+	    sprintf(buf+offset, &quot;'&quot;);
+	} 
+    }
+}
+

Modified: trunk/can-utils/lib.h
===================================================================
--- trunk/can-utils/lib.h	2006-12-14 12:58:00 UTC (rev 122)
+++ trunk/can-utils/lib.h	2007-01-01 18:29:52 UTC (rev 123)
@@ -68,19 +68,48 @@
  * 123#1122334455667788 -&gt; standard CAN-Id = 0x123, dlc = 8
  * 123#11.22.33.44.55.66.77.88 -&gt; standard CAN-Id = 0x123, dlc = 8
  * 123#11.2233.44556677.88 -&gt; standard CAN-Id = 0x123, dlc = 8
+ * 32345678#112233 -&gt; error frame with CAN_ERR_FLAG (0x2000000) set
  *
+ * Simple facts on this compact ASCII CAN frame representation:
+ *
+ * - 3 digits: standard frame format
+ * - 8 digits: extendend frame format OR error frame
+ * - 8 digits with CAN_ERR_FLAG (0x2000000) set: error frame
+ * - an error frame is never a RTR frame
+ * 
  */
 
-void fprint_canframe(FILE *stream , struct can_frame *cf, char *eol);
+void fprint_canframe(FILE *stream , struct can_frame *cf, char *eol, int sep);
+void sprint_canframe(char *buf , struct can_frame *cf, int sep);
 /*
+ * Creates a CAN frame hexadecimal output in compact format.
+ * The CAN data[] is seperated by '.' when sep != 0.
+ *
+ * 12345678#112233 -&gt; exended CAN-Id = 0x12345678, dlc = 3, data, sep = 0
+ * 12345678#R -&gt; exended CAN-Id = 0x12345678, RTR
+ * 123#11.22.33.44.55.66.77.88 -&gt; standard CAN-Id = 0x123, dlc = 8, sep = 1
+ * 32345678#112233 -&gt; error frame with CAN_ERR_FLAG (0x2000000) set
+ *
+ * Examples:
+ *
+ * fprint_canframe(stdout, &amp;frame, &quot;\n&quot;, 0); // with eol to STDOUT
+ * fprint_canframe(stderr, &amp;frame, NULL, 0); // no eol to STDERR
+ *
+ */
+
+void fprint_long_canframe(FILE *stream , struct can_frame *cf, char *eol, int ascii);
+void sprint_long_canframe(char *buf , struct can_frame *cf, int ascii);
+/*
  * Creates a CAN frame hexadecimal output in user readable format.
  *
  * 12345678  [3] 11 22 33 -&gt; exended CAN-Id = 0x12345678, dlc = 3, data
  * 12345678  [0] remote request -&gt; exended CAN-Id = 0x12345678, RTR
+ * 14B0DC51  [8] 4A 94 E8 2A EC 58 55 62   'J..*.XUb' -&gt; (with ASCII output)
+ * 20001111  [7] C6 23 7B 32 69 98 3C      ERRORFRAME -&gt; (CAN_ERR_FLAG set)
  *
  * Examples:
  *
- * fprint_canframe(stdout, &amp;frame, &quot;\n&quot;); // with eol to STDOUT
- * fprint_canframe(stderr, &amp;frame, NULL); // no eol to STDERR
+ * fprint_long_canframe(stdout, &amp;frame, &quot;\n&quot;, 0); // with eol to STDOUT
+ * fprint_long_canframe(stderr, &amp;frame, NULL, 0); // no eol to STDERR
  *
  */

Added: trunk/can-utils/log2asc.c
===================================================================
--- trunk/can-utils/log2asc.c	2006-12-14 12:58:00 UTC (rev 122)
+++ trunk/can-utils/log2asc.c	2007-01-01 18:29:52 UTC (rev 123)
@@ -0,0 +1,180 @@
+/*
+ *  $Id$
+ */
+
+/*
+ * log2asc.c - convert compact CAN frame logfile to ASC logfile
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
+ *
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+#include &lt;time.h&gt;
+#include &lt;libgen.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;net/if.h&gt;
+#include &lt;linux/can.h&gt;
+
+#include &quot;lib.h&quot;
+
+extern int optind, opterr, optopt;
+
+void print_usage(char *prg)
+{
+    fprintf(stderr, &quot;Usage: %s [can-interfaces]\n&quot;, prg);
+    fprintf(stderr, &quot;Options: -I &lt;infile&gt;  (default stdin)\n&quot;);
+    fprintf(stderr, &quot;         -O &lt;outfile&gt; (default stdout)\n&quot;);
+    fprintf(stderr, &quot;         -n (set newline to cr/lf - default lf)\n&quot;);
+}
+
+int main(int argc, char **argv)
+{
+    char buf[100], device[100], ascframe[100], id[10];
+
+    struct can_frame cf;
+    static struct timeval tv, start_tv;
+    FILE *infile = stdin;
+    FILE *outfile = stdout;
+    static int maxdev, devno, i, crlf, opt;
+
+    while ((opt = getopt(argc, argv, &quot;I:O:n&quot;)) != -1) {
+	switch (opt) {
+	case 'I':
+	    infile = fopen(optarg, &quot;r&quot;);
+	    if (!infile) {
+		perror(&quot;infile&quot;);
+		return 1;
+	    }
+	    break;
+
+	case 'O':
+	    outfile = fopen(optarg, &quot;w&quot;);
+	    if (!outfile) {
+		perror(&quot;outfile&quot;);
+		return 1;
+	    }
+	    break;
+
+	case 'n':
+	    crlf = 1;
+	    break;
+
+	default:
+	    fprintf(stderr, &quot;Unknown option %c\n&quot;, opt);
+	    print_usage(basename(argv[0]));
+	    return 1;
+	    break;
+	}
+    }
+
+    maxdev = argc - optind; /* find real number of CAN devices */
+
+    if (!maxdev) {
+	fprintf(stderr, &quot;no CAN interfaces defined!\n&quot;);
+	print_usage(basename(argv[0]));
+	return 1;
+    }
+	
+    //printf(&quot;Found %d CAN devices!\n&quot;, maxdev);
+
+    while (fgets(buf, 99, infile)) {
+	if (sscanf(buf, &quot;(%ld.%ld) %s %s&quot;, &amp;tv.tv_sec, &amp;tv.tv_usec,
+		   device, ascframe) != 4)
+	    return 1;
+
+	if (!start_tv.tv_sec) { /* print banner */
+	    start_tv = tv;
+	    fprintf(outfile, &quot;date %s&quot;, ctime(&amp;start_tv.tv_sec));
+	    fprintf(outfile, &quot;base hex  timestamps absolute%s&quot;,
+		    (crlf)?&quot;\r\n&quot;:&quot;\n&quot;);
+	    fprintf(outfile, &quot;no internal events logged%s&quot;,
+		    (crlf)?&quot;\r\n&quot;:&quot;\n&quot;);
+	}
+
+	for (i=0, devno=0; i&lt;maxdev; i++) {
+	    if (!strcmp(device, argv[optind+i])) {
+		devno = i+1; /* start with channel '1' */
+		break;
+	    }
+	}
+
+	if (devno) { /* only convert for selected CAN devices */
+	    if (parse_canframe(ascframe, &amp;cf))
+		return 1;
+
+	    tv.tv_sec  = tv.tv_sec - start_tv.tv_sec;
+	    tv.tv_usec = tv.tv_usec - start_tv.tv_usec;
+	    if (tv.tv_usec &lt; 0)
+		tv.tv_sec--, tv.tv_usec += 1000000;
+	    if (tv.tv_sec &lt; 0)
+		tv.tv_sec = tv.tv_usec = 0;
+	    fprintf(outfile, &quot;%4ld.%04ld &quot;, tv.tv_sec, tv.tv_usec/100);
+
+	    fprintf(outfile, &quot;%-2d &quot;, devno); /* channel number left aligned */
+
+	    if (cf.can_id &amp; CAN_ERR_FLAG)
+		fprintf(outfile, &quot;(errorframe)&quot;);
+	    else {
+		sprintf(id, &quot;%X%c&quot;, cf.can_id &amp; CAN_EFF_MASK,
+			(cf.can_id &amp; CAN_EFF_FLAG)?'x':' ');
+		fprintf(outfile, &quot;%-15s Rx   &quot;, id);
+		
+		if (cf.can_id &amp; CAN_RTR_FLAG)
+		    fprintf(outfile, &quot;r&quot;); /* RTR frame */
+		else {
+		    fprintf(outfile, &quot;d %d&quot;, cf.can_dlc); /* data frame */
+		    
+		    for (i = 0; i &lt; cf.can_dlc; i++) {
+			fprintf(outfile, &quot; %02X&quot;, cf.data[i]);
+		    }
+		}
+	    }
+	    if (crlf)
+		fprintf(outfile, &quot;\r&quot;);
+	    fprintf(outfile, &quot;\n&quot;);
+	}
+    }
+    fflush(outfile);
+
+    return 0;
+}


Property changes on: trunk/can-utils/log2asc.c
___________________________________________________________________
Name: svn:keywords
   + Id

Added: trunk/can-utils/log2long.c
===================================================================
--- trunk/can-utils/log2long.c	2006-12-14 12:58:00 UTC (rev 122)
+++ trunk/can-utils/log2long.c	2007-01-01 18:29:52 UTC (rev 123)
@@ -0,0 +1,71 @@
+/*
+ *  $Id$
+ */
+
+/*
+ * log2long.c - convert compact CAN frame representation into user readable
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
+ *
+ */
+
+#include &lt;stdio.h&gt;
+
+#include &lt;net/if.h&gt;
+#include &lt;linux/can.h&gt;
+
+#include &quot;lib.h&quot;
+
+int main(int argc, char **argv)
+{
+    char buf[100], timestamp[100], device[100], ascframe[100];
+    struct can_frame cf;
+
+    while (fgets(buf, 99, stdin)) {
+	if (sscanf(buf, &quot;%s %s %s&quot;, timestamp, device, ascframe) != 3)
+	    return 1;
+	if (parse_canframe(ascframe, &amp;cf))
+	    return 1;
+	sprint_long_canframe(ascframe, &amp;cf, 1); /* with ASCII output */
+	printf(&quot;%s  %s  %s\n&quot;, timestamp, device, ascframe);
+    }
+
+    return 0;
+}


Property changes on: trunk/can-utils/log2long.c
___________________________________________________________________
Name: svn:keywords
   + Id


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000108.html">r124 - trunk/kernel/2.6/net/can
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#107">[ date ]</a>
              <a href="thread.html#107">[ thread ]</a>
              <a href="subject.html#107">[ subject ]</a>
              <a href="author.html#107">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-commit">More information about the Socketcan-commit
mailing list</a><br>
</body></html>
