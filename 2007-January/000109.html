<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> r125 - trunk/can-utils
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-commit/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r125%20-%20trunk/can-utils&In-Reply-To=%3C200701061543.l06FhDHe031488%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000108.html">
   <LINK REL="Next"  HREF="000110.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>r125 - trunk/can-utils</H1>
    <B>hartkopp at mail.berlios.de</B> 
    <A HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r125%20-%20trunk/can-utils&In-Reply-To=%3C200701061543.l06FhDHe031488%40sheep.berlios.de%3E"
       TITLE="r125 - trunk/can-utils">hartkopp at mail.berlios.de
       </A><BR>
    <I>Sat Jan  6 16:43:13 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000108.html">r124 - trunk/kernel/2.6/net/can
</A></li>
        <LI>Next message: <A HREF="000110.html">r126 - trunk/can-utils
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#109">[ date ]</a>
              <a href="thread.html#109">[ thread ]</a>
              <a href="subject.html#109">[ subject ]</a>
              <a href="author.html#109">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hartkopp
Date: 2007-01-06 16:43:12 +0100 (Sat, 06 Jan 2007)
New Revision: 125

Added:
   trunk/can-utils/canplayer.c
Modified:
   trunk/can-utils/Makefile
   trunk/can-utils/candump.c
Log:
Minor fix and cosmetics in color handling in candump.c .

Added new tool 'canplayer' to replay logfiles generated by candump -l .

Features of canplayer:

- Input from stdin or file.
- throttling of the replay to get nearly original timestamps / message gaps
- mapping and selection of CAN interfaces (assignment)
  e.g. canplay -I logfile vcan2=can2 vcan0=can1 can2=can3
  means: send frames received on can1 in the logfile to vcan0 and so on ...
- if no assignment is made the original interfaces are used for replay
- handling of multiple CAN interfaces simultaneously (if in logfile)
- option: throttle disable (do not look on timestamps =&gt; very FAST replay!)
- option: change the 'sleep time' in milli seconds

Remarks:
canplayer uses nanosleep() for throttling which means that the resolution of
the canplayer is about 1ms (Kernel HZ = 1000) or 10ms (Kernel HZ = 100).
After each nanosleep() all the CAN frames are send that had to be transmitted
until the timestamp at the current time. Giving e.g. the option '-g 500' for
500ms let's you see the behaviour. Using nanosleep() makes canplay a very
performant tool with minimum CPU load.

To transfer CAN frames over a TCP/IP network you may now say something like:
candump -&gt; netcat -&gt; netcat -&gt; canplayer


Modified: trunk/can-utils/Makefile
===================================================================
--- trunk/can-utils/Makefile	2007-01-05 16:57:53 UTC (rev 124)
+++ trunk/can-utils/Makefile	2007-01-06 15:43:12 UTC (rev 125)
@@ -43,7 +43,7 @@
 CFLAGS    = -O2 -Wall -Wno-parentheses -I../kernel/2.6/include \
 	    -fno-strict-aliasing
 
-PROGRAMS = candump can-sniffer cansend cangen log2long log2asc
+PROGRAMS = candump can-sniffer cansend canplayer cangen log2long log2asc
 
 all: $(PROGRAMS)
 
@@ -53,14 +53,16 @@
 distclean:
 	rm -f $(PROGRAMS) *.o *~
 
-cansend.o:  lib.h
-cangen.o:   lib.h
-candump.o:  lib.h
-log2long.o: lib.h
-log2asc.o:  lib.h
+cansend.o:   lib.h
+cangen.o:    lib.h
+candump.o:   lib.h
+canplayer.o: lib.h
+log2long.o:  lib.h
+log2asc.o:   lib.h
 
-cansend:  cansend.o  lib.o
-cangen:   cangen.o   lib.o
-candump:  candump.o  lib.o
-log2long: log2long.o lib.o
-log2asc:  log2asc.o  lib.o
+cansend:   cansend.o   lib.o
+cangen:    cangen.o    lib.o
+candump:   candump.o   lib.o
+canplayer: canplayer.o lib.o
+log2long:  log2long.o  lib.o
+log2asc:   log2asc.o   lib.o

Modified: trunk/can-utils/candump.c
===================================================================
--- trunk/can-utils/candump.c	2007-01-05 16:57:53 UTC (rev 124)
+++ trunk/can-utils/candump.c	2007-01-06 15:43:12 UTC (rev 125)
@@ -465,7 +465,7 @@
 		    continue;
 		}
 		      
-		printf(&quot; %s&quot;,(color&gt;2)?col_on[idx]:&quot;&quot;);
+		printf(&quot; %s&quot;, (color&gt;2)?col_on[idx]:&quot;&quot;);
 
 		switch (timestamp) {
 
@@ -508,13 +508,13 @@
 		    break;
 		}
 
-		printf(&quot; %s&quot;,(color &amp;&amp; (color&lt;3))?col_on[idx]:&quot;&quot;);
+		printf(&quot; %s&quot;, (color &amp;&amp; (color&lt;3))?col_on[idx]:&quot;&quot;);
 		printf(&quot;%*s&quot;, max_devname_len, devname[idx]);
-		printf(&quot;%s  &quot;,(color&lt;2)?col_off:&quot;&quot;);
+		printf(&quot;%s  &quot;, (color==1)?col_off:&quot;&quot;);
 
 		fprint_long_canframe(stdout, &amp;frame, NULL, ascii);
 
-		printf(&quot;%s&quot;,(color&gt;1)?col_off:&quot;&quot;);
+		printf(&quot;%s&quot;, (color&gt;1)?col_off:&quot;&quot;);
 		printf(&quot;\n&quot;);
 	    }
 	    fflush(stdout);

Added: trunk/can-utils/canplayer.c
===================================================================
--- trunk/can-utils/canplayer.c	2007-01-05 16:57:53 UTC (rev 124)
+++ trunk/can-utils/canplayer.c	2007-01-06 15:43:12 UTC (rev 125)
@@ -0,0 +1,394 @@
+/*
+ *  $Id$
+ */
+
+/*
+ * canplayer.c - replay a compact CAN frame logfile to CAN devices
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">socketcan-users at lists.berlios.de</A>&gt;
+ *
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+#include &lt;time.h&gt;
+#include &lt;libgen.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;net/if.h&gt;
+#include &lt;sys/ioctl.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;linux/can.h&gt;
+#include &lt;linux/can/raw.h&gt;
+
+#include &quot;lib.h&quot;
+
+#define DEFAULT_GAP 1 /* ms */
+#define CHANNELS 20   /* anyone using more than 20 CAN interfaces at a time? */
+#define BUFSZ 100     /* for one line in the logfile */
+
+struct assignment {
+    char txif[IFNAMSIZ];
+    int  txifidx;
+    char rxif[IFNAMSIZ];
+};
+static struct assignment asgn[CHANNELS];
+
+extern int optind, opterr, optopt;
+
+void print_usage(char *prg)
+{
+    fprintf(stderr, &quot;\nUsage: %s &lt;options&gt; [interface assignment]*\n\n&quot;, prg);
+    fprintf(stderr, &quot;Options:              -I &lt;infile&gt;  (default stdin)\n&quot;);
+    fprintf(stderr, &quot;                      -t           (ignore timestamps: &quot;
+	    &quot;send frames immediately)\n&quot;);
+    fprintf(stderr, &quot;                      -g &lt;ms&gt;      (gap in milli &quot;
+	    &quot;seconds - default: %d ms)\n&quot;, DEFAULT_GAP);
+    fprintf(stderr, &quot;                      -v           (verbose: print &quot;
+	    &quot;sent CAN frames)\n\n&quot;);
+    fprintf(stderr, &quot;Interface assignment:  0..n assignments like &quot;
+	    &quot;&lt;write-if&gt;=&lt;log-if&gt;\n&quot;);
+    fprintf(stderr, &quot;e.g. vcan2=can0 ( send frames received from can0 on &quot;
+	    &quot;vcan2 )\n&quot;);
+    fprintf(stderr, &quot;No assignments =&gt; send frames to the interface(s) they &quot;
+	    &quot;had been received from.\n\n&quot;);
+}
+
+/* copied from /usr/src/linux/include/linux/time.h ...
+ * lhs &lt; rhs:  return &lt;0
+ * lhs == rhs: return 0
+ * lhs &gt; rhs:  return &gt;0
+ */
+static inline int timeval_compare(struct timeval *lhs, struct timeval *rhs)
+{
+    if (lhs-&gt;tv_sec &lt; rhs-&gt;tv_sec)
+	return -1;
+    if (lhs-&gt;tv_sec &gt; rhs-&gt;tv_sec)
+	return 1;
+    return lhs-&gt;tv_usec - rhs-&gt;tv_usec;
+}
+
+static inline int frames_to_send(struct timeval *today, struct timeval *diff,
+				 struct timeval *log)
+{
+    /* return value &lt;0 when log + diff &lt; today */
+
+    struct timeval cmp;
+
+    cmp.tv_sec  = log-&gt;tv_sec  + diff-&gt;tv_sec;
+    cmp.tv_usec = log-&gt;tv_usec + diff-&gt;tv_usec;
+
+    if (cmp.tv_usec &gt; 1000000) {
+	cmp.tv_usec -= 1000000;
+	cmp.tv_sec++;
+    }
+
+    return timeval_compare(&amp;cmp, today);
+}
+
+int get_txidx(char *logif_name) {
+
+    int i;
+
+    for (i=0; i&lt;CHANNELS; i++) {
+	if (asgn[i].rxif[0] == 0) /* end of table content */
+	    break;
+	if (strcmp(asgn[i].rxif, logif_name) == 0) /* found device name */
+	    break;
+    }
+
+    if ((i == CHANNELS) || (asgn[i].rxif[0] == 0))
+	return 0; /* not found */
+
+    return asgn[i].txifidx; /* return interface index */
+}
+
+char *get_txname(char *logif_name) {
+
+    int i;
+
+    for (i=0; i&lt;CHANNELS; i++) {
+	if (asgn[i].rxif[0] == 0) /* end of table content */
+	    break;
+	if (strcmp(asgn[i].rxif, logif_name) == 0) /* found device name */
+	    break;
+    }
+
+    if ((i == CHANNELS) || (asgn[i].rxif[0] == 0))
+	return 0; /* not found */
+
+    return asgn[i].txif; /* return interface name */
+}
+
+int add_assignment(char *mode, int socket, char *txname, char *rxname,
+		   int verbose) {
+
+    struct ifreq ifr;
+    int i;
+
+    /* find free entry */
+    for (i=0; i&lt;CHANNELS; i++) {
+	if (asgn[i].txif[0] == 0)
+	    break;
+    }
+
+    if (i == CHANNELS) {
+	fprintf(stderr, &quot;Assignment table exceeded!\n&quot;);
+	return 1;
+    }
+
+    if (strlen(txname) &gt;= IFNAMSIZ) {
+	fprintf(stderr, &quot;write-if interface name '%s' too long!&quot;, txname);
+	return 1;
+    }
+    strcpy(asgn[i].txif, txname);
+
+    if (strlen(rxname) &gt;= IFNAMSIZ) {
+	fprintf(stderr, &quot;log-if interface name '%s' too long!&quot;, rxname);
+	return 1;
+    }
+    strcpy(asgn[i].rxif, rxname);
+
+    strcpy(ifr.ifr_name, txname);
+    if (ioctl(socket, SIOCGIFINDEX, &amp;ifr) &lt; 0) {
+	perror(&quot;SIOCGIFINDEX&quot;);
+	fprintf(stderr, &quot;write-if interface name '%s' is wrong!\n&quot;, txname);
+	return 1;
+    }
+    asgn[i].txifidx = ifr.ifr_ifindex;
+
+    if (verbose &gt; 1) /* use -v -v to see this */
+	printf(&quot;added %s assignment: log-if=%s write-if=%s write-if-idx=%d\n&quot;,
+	       mode, asgn[i].rxif, asgn[i].txif, asgn[i].txifidx);
+
+    return 0;
+}
+
+int main(int argc, char **argv)
+{
+    static char buf[BUFSZ], device[BUFSZ], ascframe[BUFSZ];
+    struct sockaddr_can addr;
+    static struct can_frame frame;
+    static struct timeval today_tv, log_tv, diff_tv;
+    struct timespec sleep_ts;
+    int s; /* CAN_RAW socket */
+    FILE *infile = stdin;
+    unsigned long gap = DEFAULT_GAP; 
+    int use_timestamps = 1;
+    static int verbose, opt, loops;
+    int assignments; /* assignments defined on the commandline */
+    int txidx;       /* sendto() interface index */
+    int nbytes, i, j;
+
+    while ((opt = getopt(argc, argv, &quot;I:tg:v&quot;)) != -1) {
+	switch (opt) {
+	case 'I':
+	    infile = fopen(optarg, &quot;r&quot;);
+	    if (!infile) {
+		perror(&quot;infile&quot;);
+		return 1;
+	    }
+	    break;
+
+	case 't':
+	    use_timestamps = 0;
+	    break;
+
+	case 'g':
+	    gap = strtoul(optarg, NULL, 10);
+	    break;
+
+	case 'v':
+	    verbose++;
+	    break;
+
+	default:
+	    print_usage(basename(argv[0]));
+	    return 1;
+	    break;
+	}
+    }
+
+    assignments = argc - optind; /* find real number of user assignments */
+
+    sleep_ts.tv_sec  =  gap / 1000;
+    sleep_ts.tv_nsec = (gap % 1000) * 1000000;
+
+    /* open socket */
+    if ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) &lt; 0) {
+	perror(&quot;socket&quot;);
+	return 1;
+    }
+
+    addr.can_family  = AF_CAN;
+    addr.can_ifindex = 0;
+
+    /* disable unneeded default receive filter on this RAW socket */
+    setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
+
+    if (bind(s, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) {
+	perror(&quot;bind&quot;);
+	return 1;
+    }
+
+    if (assignments) {
+	/* add &amp; check user assginments from commandline */
+	for (i=0; i&lt;assignments; i++) {
+	    if (strlen(argv[optind+i]) &gt;= BUFSZ) {
+		fprintf(stderr, &quot;Assignment too long!\n&quot;);
+		print_usage(basename(argv[0]));
+		return 1;
+	    }
+	    strcpy(buf, argv[optind+i]);
+	    for (j=0; j&lt;BUFSZ; j++) { /* find '=' in assignment */
+		if (buf[j] == '=')
+		    break;
+	    }
+	    if (buf[j] != '=') {
+		fprintf(stderr, &quot;'=' missing in assignment!\n&quot;);
+		print_usage(basename(argv[0]));
+		return 1;
+	    }
+	    buf[j] = 0; /* cut string in two pieces */
+	    if (add_assignment(&quot;user&quot;, s, &amp;buf[0], &amp;buf[j+1], verbose))
+		return 1;
+	}
+    }
+
+    if (!fgets(buf, BUFSZ-1, infile)) /* read first frame from logfile */
+	goto out; /* nothing to read */
+
+    if (sscanf(buf, &quot;(%ld.%ld) %s %s&quot;, &amp;log_tv.tv_sec, &amp;log_tv.tv_usec,
+	       device, ascframe) != 4)
+	return 1;
+
+    if (use_timestamps) { /* throttle sending due to logfile timestamps */
+
+	gettimeofday(&amp;today_tv, NULL);
+
+	/* omit crazy comparations with negative diff_tv */
+	if (timeval_compare(&amp;today_tv, &amp;log_tv) &lt; 1) {
+	    fprintf(stderr, &quot;logfile timestamps newer than time of day!\n&quot;);
+	    return 1;
+	}
+
+	/* create diff_tv so that log_tv + diff_tv = today_tv */
+	diff_tv.tv_sec  = today_tv.tv_sec  - log_tv.tv_sec;
+	diff_tv.tv_usec = today_tv.tv_usec - log_tv.tv_usec;
+	if (diff_tv.tv_usec &lt; 0)
+	    diff_tv.tv_sec--, diff_tv.tv_usec += 1000000;
+    }
+
+    while (1) {
+
+	while ((!use_timestamps) ||
+	       (frames_to_send(&amp;today_tv, &amp;diff_tv, &amp;log_tv) &lt; 0)) {
+
+	    /* log_tv/device/ascframe are valid here */
+
+	    if (strlen(device) &gt;= IFNAMSIZ) {
+		fprintf(stderr, &quot;log interface name '%s' too long!&quot;, device);
+		return 1;
+	    }
+
+	    txidx = get_txidx(device); /* get ifindex for sending the frame */
+ 
+	    if ((!txidx) &amp;&amp; (!assignments)) {
+		/* ifindex not found and no user assignments */
+		/* =&gt; assign this device automatically       */
+		if (add_assignment(&quot;auto&quot;, s, device, device, verbose))
+		    return 1;
+		txidx = get_txidx(device);
+	    }
+
+	    if (txidx) { /* only send to valid CAN devices */
+
+		if (parse_canframe(ascframe, &amp;frame)) {
+		    fprintf(stderr, &quot;wrong CAN frame format: '%s'!&quot;, ascframe);
+		    return 1;
+		}
+
+		addr.can_family  = AF_CAN;
+		addr.can_ifindex = txidx; /* send via this interface */
+ 
+		nbytes = sendto(s, &amp;frame, sizeof(struct can_frame), 0,
+				(struct sockaddr*)&amp;addr, sizeof(addr));
+
+		if (nbytes != sizeof(struct can_frame)) {
+		    perror(&quot;sendto&quot;);
+		    return 1;
+		}
+
+		if (verbose) {
+		    printf(&quot;%s (%s) &quot;, get_txname(device), device);
+		    fprint_long_canframe(stdout, &amp;frame, &quot;\n&quot;, 1);
+		}
+	    }
+
+	    /* read next frame from logfile */
+	    if (!fgets(buf, BUFSZ-1, infile))
+		goto out; /* nothing to read */
+
+	    if (sscanf(buf, &quot;(%ld.%ld) %s %s&quot;, &amp;log_tv.tv_sec, &amp;log_tv.tv_usec,
+		       device, ascframe) != 4)
+		return 1;
+
+	    if (use_timestamps) /* save a syscall if possible */
+		gettimeofday(&amp;today_tv, NULL);
+	}
+
+	if (nanosleep(&amp;sleep_ts, NULL))
+	    return 1;
+
+	loops++; /* private statistics */
+	gettimeofday(&amp;today_tv, NULL);
+    }
+
+ out:
+
+    close(s);
+    fclose(infile);
+
+    if (verbose &gt; 1) /* use -v -v to see this */
+	printf(&quot;%d loops\n&quot;, loops);
+
+    return 0;
+}


Property changes on: trunk/can-utils/canplayer.c
___________________________________________________________________
Name: svn:keywords
   + Id


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000108.html">r124 - trunk/kernel/2.6/net/can
</A></li>
	<LI>Next message: <A HREF="000110.html">r126 - trunk/can-utils
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#109">[ date ]</a>
              <a href="thread.html#109">[ thread ]</a>
              <a href="subject.html#109">[ subject ]</a>
              <a href="author.html#109">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-commit">More information about the Socketcan-commit
mailing list</a><br>
</body></html>
