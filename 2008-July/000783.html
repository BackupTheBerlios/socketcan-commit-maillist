<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> r803 - in trunk/kernel/2.6/drivers/net/can: . softing
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-commit/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r803%20-%20in%20trunk/kernel/2.6/drivers/net/can%3A%20.%20softing&In-Reply-To=%3C200807011009.m61A9E5o004981%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000782.html">
   <LINK REL="Next"  HREF="000784.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>r803 - in trunk/kernel/2.6/drivers/net/can: . softing</H1>
    <B>hartkopp at mail.berlios.de</B> 
    <A HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r803%20-%20in%20trunk/kernel/2.6/drivers/net/can%3A%20.%20softing&In-Reply-To=%3C200807011009.m61A9E5o004981%40sheep.berlios.de%3E"
       TITLE="r803 - in trunk/kernel/2.6/drivers/net/can: . softing">hartkopp at mail.berlios.de
       </A><BR>
    <I>Tue Jul  1 12:09:14 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000782.html">r802 - trunk/kernel/2.6/net/can
</A></li>
        <LI>Next message: <A HREF="000784.html">r804 - trunk/can-utils
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#783">[ date ]</a>
              <a href="thread.html#783">[ thread ]</a>
              <a href="subject.html#783">[ subject ]</a>
              <a href="author.html#783">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hartkopp
Date: 2008-07-01 12:09:12 +0200 (Tue, 01 Jul 2008)
New Revision: 803

Added:
   trunk/kernel/2.6/drivers/net/can/softing/
   trunk/kernel/2.6/drivers/net/can/softing/Makefile
   trunk/kernel/2.6/drivers/net/can/softing/softing.h
   trunk/kernel/2.6/drivers/net/can/softing/softing_cs.c
   trunk/kernel/2.6/drivers/net/can/softing/softing_fw.c
   trunk/kernel/2.6/drivers/net/can/softing/softing_main.c
Modified:
   trunk/kernel/2.6/drivers/net/can/Kconfig
   trunk/kernel/2.6/drivers/net/can/Makefile
Log:
Added Softing driver contributed by Kurt Van Dijck (EIA Electronics).


Modified: trunk/kernel/2.6/drivers/net/can/Kconfig
===================================================================
--- trunk/kernel/2.6/drivers/net/can/Kconfig	2008-07-01 09:16:34 UTC (rev 802)
+++ trunk/kernel/2.6/drivers/net/can/Kconfig	2008-07-01 10:09:12 UTC (rev 803)
@@ -113,6 +113,16 @@
 	This driver is for the the PCIcanx and PCIcan cards (1, 2 or
 	4 channel) from Kvaser (<A HREF="http://www.kvaser.com">http://www.kvaser.com</A>).
 
+config CAN_SOFTING
+	tristate &quot;Softing Gmbh CAN generic support&quot;
+	depends on CAN_DEV
+	---help---
+	  generic softing CAN cards
+
+config CAN_SOFTING_CS
+	tristate &quot;Softing CAN pcmcia cards&quot;
+	depends on CAN_SOFTING &amp;&amp; PCMCIA
+
 config CAN_MSCAN
 	depends on CAN_DEV &amp;&amp; (PPC || M68K || M68KNOMMU)
 	tristate &quot;Support for a Freescale MSCAN based chips&quot;

Modified: trunk/kernel/2.6/drivers/net/can/Makefile
===================================================================
--- trunk/kernel/2.6/drivers/net/can/Makefile	2008-07-01 09:16:34 UTC (rev 802)
+++ trunk/kernel/2.6/drivers/net/can/Makefile	2008-07-01 10:09:12 UTC (rev 803)
@@ -14,6 +14,8 @@
 export CONFIG_CAN_SJA1000_OLD=m
 export CONFIG_CAN_I82527_OLD=m
 export CONFIG_CAN_SJA1000=m
+export CONFIG_CAN_SOFTING=m
+export CONFIG_CAN_SOFTING_CS=m
 
 modules modules_install clean:
 	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
@@ -29,6 +31,7 @@
 can-dev-y			:= dev.o sysfs.o
 
 obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
+obj-$(CONFIG_CAN_SOFTING)	+= softing/
 obj-$(CONFIG_CAN_MSCAN)		+= mscan/
 obj-$(CONFIG_CAN_SJA1000_OLD)	+= old/sja1000/
 obj-$(CONFIG_CAN_I82527_OLD)	+= old/i82527/

Added: trunk/kernel/2.6/drivers/net/can/softing/Makefile
===================================================================
--- trunk/kernel/2.6/drivers/net/can/softing/Makefile	2008-07-01 09:16:34 UTC (rev 802)
+++ trunk/kernel/2.6/drivers/net/can/softing/Makefile	2008-07-01 10:09:12 UTC (rev 803)
@@ -0,0 +1,20 @@
+# Makefile for softing CAN driver
+
+ifeq ($(KERNELRELEASE),)
+# necessary when used outside kernel
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+softing-y := softing_main.o softing_fw.o
+obj-$(CONFIG_CAN_SOFTING)        += softing.o
+obj-$(CONFIG_CAN_SOFTING_CS)     += softing_cs.o
+
+endif

Added: trunk/kernel/2.6/drivers/net/can/softing/softing.h
===================================================================
--- trunk/kernel/2.6/drivers/net/can/softing/softing.h	2008-07-01 09:16:34 UTC (rev 802)
+++ trunk/kernel/2.6/drivers/net/can/softing/softing.h	2008-07-01 10:09:12 UTC (rev 803)
@@ -0,0 +1,266 @@
+/*
+ * softing common interfaces
+ *
+ * by Kurt Van Dijck, 06-2008
+ */
+
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/can.h&gt;
+#include &lt;linux/can/dev.h&gt;
+
+struct softing;
+struct sofing_desc;
+
+/* special attribute, so we should not rely on the -&gt;priv pointers
+ * before knowing how to interpret these
+ */
+struct softing_attribute;
+
+struct softing_priv {
+	struct can_priv can;	/* must be the first member! */
+	struct net_device *netdev;
+	struct softing *card;
+	struct {
+		int pending;
+		/* variables wich hold the circular buffer */
+		int echo_put;
+		int echo_get;
+	} tx;
+	int index;
+	u8 sample;
+	u8 output;
+	u16 chip;
+	struct attribute_group sysfs;
+};
+#define netdev2softing(netdev)	((struct softing_priv *)netdev_priv(netdev))
+
+struct softing_desc {
+	unsigned int manf;
+	unsigned int prod;
+	/* generation
+	 * 1st with NEC or SJA1000
+	 * 8bit, exclusive interrupt, ...
+	 * 2nd only SJA11000
+	 * 16bit, shared interrupt
+	 */
+	int generation;
+	unsigned int freq;	/*crystal in MHz */
+	unsigned int max_brp;
+	unsigned int max_sjw;
+	unsigned long dpram_size;
+	char name[32];
+	struct {
+		unsigned long offs;
+		unsigned long addr;
+		char fw[32];
+	} boot, load, app;
+};
+
+struct softing {
+	int nbus;
+	struct softing_priv *bus[2];
+	spinlock_t	 spin; /* protect this structure &amp; DPRAM access */
+
+	struct {
+		/* indication of firmware status */
+		int up;
+		/* protection of the 'up' variable */
+		struct mutex lock;
+	} fw;
+	struct {
+		int nr;
+		int shared;
+		int requested;
+		struct tasklet_struct bh;
+		int svc_count;
+	} irq;
+	struct {
+		int pending;
+		int last_bus;
+		/* keep the bus that last tx'd a message,
+		 * in order to let every netdev queue resume
+		 */
+	} tx;
+	struct {
+		unsigned long phys;
+		unsigned long size;
+		unsigned char *virt;
+		unsigned char *end;
+		struct softing_fct  *fct;
+		struct softing_info *info;
+		struct softing_rx  *rx;
+		struct softing_tx  *tx;
+		struct softing_irq *irq;
+		unsigned short *command;
+		unsigned short *receipt;
+	} dpram;
+	struct {
+		unsigned short manf;
+		unsigned short prod;
+		u32  serial, fw, hw, lic;
+		u16  chip [2];
+		u32  freq;
+		const char *name;
+	} id;
+	const struct softing_desc		*desc;
+	struct {
+		int (*reset)	 (struct softing *, int);
+		int (*enable_irq)(struct softing *, int);
+	} fn;
+	struct device *dev;
+	/* sysfs */
+	struct attribute_group sysfs;
+	struct softing_attribute *attr;
+	struct attribute **grp;
+};
+
+extern int	mk_softing(struct softing *);
+/* fields that must be set already are :
+ * ncan
+ * id.manf
+ * id.prod
+ * fn.reset
+ * fn.enable_irq
+ */
+extern void rm_softing(struct softing *);
+/* usefull functions during operation */
+
+extern const struct softing_desc *
+	softing_lookup_desc(unsigned int manf, unsigned int prod);
+
+extern int softing_default_output(struct softing *card
+			, struct softing_priv *priv);
+extern u32 softing_time2usec(struct softing *card, u32 raw);
+
+extern int softing_fct_cmd(struct softing *card
+			, int cmd, int vector, const char *msg);
+
+extern int softing_bootloader_command(struct softing *card
+			, int command, const char *msg);
+
+/* Load firmware after reset */
+extern int softing_load_fw(const char *file, struct softing *card,
+			unsigned char *virt, unsigned int size, int offset);
+
+/* Load final application firmware after bootloader */
+extern int softing_load_app_fw(const char *file, struct softing *card);
+
+extern int softing_reset_chip(struct softing *card);
+
+/* enable or disable irq
+ * only called with fw.lock locked
+ */
+extern int softing_card_irq(struct softing *card, int enable);
+
+/* called when tx queue is flushed */
+extern void softing_flush_echo_skb(struct softing_priv *priv);
+
+/* reinitaliase the card, apply -1 for bus[01] for 'no change' */
+extern int softing_reinit(struct softing *card, int bus0, int bus1);
+
+/* SOFTING DPRAM mappings */
+struct softing_rx {
+	u8  fifo[16][32];
+	u8  dummy1;
+	u16 rd;
+	u16 dummy2;
+	u16 wr;
+	u16  dummy3;
+	u16 lost_msg;
+} __attribute__((packed));
+
+#define TXMAX	31
+struct softing_tx {
+	u8  fifo[32][16];
+	u8  dummy1;
+	u16 rd;
+	u16 dummy2;
+	u16 wr;
+	u8  dummy3;
+} __attribute__((packed));
+
+struct softing_irq {
+	u8 to_host;
+	u8 to_card;
+} __attribute__((packed));
+
+struct softing_fct {
+	s16 param[20]; /* 0 is index */
+	s16 returned;
+	u8  dummy;
+	u16 host_access;
+} __attribute__((packed));
+
+struct softing_info {
+	u8  dummy1;
+	u16 bus_state;
+	u16 dummy2;
+	u16 bus_state2;
+	u16 dummy3;
+	u16 error_state;
+	u16 dummy4;
+	u16 error_state2;
+	u16 dummy5;
+	u16 reset;
+	u16 dummy6;
+	u16 clear_rcv_fifo;
+	u16 dummy7;
+	u16 dummyxx;
+	u16 dummy8;
+	u16 time_reset;
+	u8  dummy9;
+	u32 time;
+	u32 time_wrap;
+	u8  wr_start;
+	u8  wr_end;
+	u8  dummy10;
+	u16 dummy12;
+	u16 dummy12x;
+	u16 dummy13;
+	u16 reset_rcv_fifo;
+	u8  dummy14;
+	u8  reset_xmt_fifo;
+	u8  read_fifo_levels;
+	u16 rcv_fifo_level;
+	u16 xmt_fifo_level;
+} __attribute__((packed));
+
+/* DPRAM return codes */
+#define RES_NONE 0
+#define RES_OK	 1
+#define RES_NOK  2
+#define RES_UNKNOWN 3
+/* DPRAM flags */
+#define CMD_TX		0x01
+#define CMD_ACK 0x02
+#define CMD_XTD 0x04
+#define CMD_RTR 0x08
+#define CMD_ERR 0x10
+#define CMD_BUS2	0x80
+
+/* debug */
+extern int softing_debug;
+
+#define mod_alert(fmt,arg...) { \
+	if (softing_debug &gt;= 0) \
+		printk(KERN_ALERT &quot;[%s] %s:&quot; fmt &quot;\n&quot; \
+			, THIS_MODULE-&gt;name \
+			, __func__ \
+			, ##arg); \
+	}
+#define mod_info(fmt,arg...) { \
+	if (softing_debug &gt;= 1) \
+		printk(KERN_INFO	&quot;[%s] %s:&quot; fmt &quot;\n&quot;\
+			, THIS_MODULE-&gt;name \
+			, __func__ \
+			, ##arg); \
+	}
+#define mod_trace(fmt,arg...) { \
+	if (softing_debug &gt;= 2) \
+		printk(KERN_DEBUG &quot;[%s] %s:&quot; fmt &quot;\n&quot; \
+			, THIS_MODULE-&gt;name \
+			, __func__ \
+			, ##arg); \
+	}
+

Added: trunk/kernel/2.6/drivers/net/can/softing/softing_cs.c
===================================================================
--- trunk/kernel/2.6/drivers/net/can/softing/softing_cs.c	2008-07-01 09:16:34 UTC (rev 802)
+++ trunk/kernel/2.6/drivers/net/can/softing/softing_cs.c	2008-07-01 10:09:12 UTC (rev 803)
@@ -0,0 +1,487 @@
+/*
+* drivers/net/can/softing/softing_cs.c
+*
+* Copyright (C) 2008
+*
+* - Kurt Van Dijck, EIA Electronics
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the version 2 of the GNU General Public License
+* as published by the Free Software Foundation
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/moduleparam.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/ptrace.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/string.h&gt;
+#include &lt;linux/timer.h&gt;
+#include &lt;linux/major.h&gt;
+#include &lt;linux/io.h&gt;
+
+#include &lt;pcmcia/cs_types.h&gt;
+#include &lt;pcmcia/cs.h&gt;
+#include &lt;pcmcia/cistpl.h&gt;
+#include &lt;pcmcia/ciscode.h&gt;
+#include &lt;pcmcia/ds.h&gt;
+#include &lt;pcmcia/cisreg.h&gt;
+
+#include &lt;asm/system.h&gt;
+
+#include &quot;softing.h&quot;
+
+struct softing_cs {
+	struct io_req_t  io ;
+	struct irq_req_t irq;
+	window_handle_t  win;
+	config_req_t	  conf;
+	struct softing	 softing;
+};
+#define softing2cs(x) container_of((x), struct softing_cs, softing)
+
+struct lookup {
+	int i;
+	const char *a;
+};
+
+static const char __devinit *lookup_mask(const struct lookup *lp, int *i)
+{
+	for (; lp-&gt;a; ++lp) {
+		if (lp-&gt;i &amp; *i) {
+			*i &amp;= ~lp-&gt;i;
+			return lp-&gt;a;
+		}
+	}
+	return 0;
+}
+
+static int card_reset_via_pcmcia(struct softing *sdev, int v)
+{
+	struct pcmcia_device *pcmcia = to_pcmcia_dev(sdev-&gt;dev);
+	conf_reg_t reg;
+	reg.Function = 0; /* socket */
+	reg.Action	 = CS_WRITE;
+	reg.Offset	 = 2;
+	reg.Value	 = v ? 0 : 0x20;
+	return pcmcia_access_configuration_register(pcmcia, &amp;reg);
+}
+
+static int card_reset_via_dpram(struct softing *sdev, int v)
+{
+	if (v) {
+		spin_lock_bh(&amp;sdev-&gt;spin);
+		sdev-&gt;dpram.virt[0xe00] &amp;= ~1;
+		spin_unlock_bh(&amp;sdev-&gt;spin);
+		card_reset_via_pcmcia(sdev, v);
+	} else {
+		card_reset_via_pcmcia(sdev, v);
+		spin_lock_bh(&amp;sdev-&gt;spin);
+		sdev-&gt;dpram.virt[0xe00] |=  1;
+		spin_unlock_bh(&amp;sdev-&gt;spin);
+	}
+	return 0;
+}
+
+static int card_enable_irq_via_pcmcia(struct softing *sdev, int v)
+{
+	int ret;
+	struct pcmcia_device *pcmcia = to_pcmcia_dev(sdev-&gt;dev);
+	conf_reg_t reg;
+	memset(&amp;reg, 0, sizeof(reg));
+	reg.Function = 0; /* socket */
+	reg.Action	 = CS_WRITE;
+	reg.Offset	 = 0;
+	reg.Value	 = v ? 0x60 : 0;
+	ret = pcmcia_access_configuration_register(pcmcia, &amp;reg);
+	if (ret)
+		mod_alert(&quot;failed %u&quot;, ret);
+	return ret;
+}
+
+/* TODO: in 2.6.26, __devinitconst works*/
+static const __devinitdata struct lookup pcmcia_io_attr[] = {
+	{ IO_DATA_PATH_WIDTH_AUTO	, &quot;[auto]&quot;	, },
+	{ IO_DATA_PATH_WIDTH_8		, &quot;8bit&quot;	, },
+	{ IO_DATA_PATH_WIDTH_16		, &quot;16bit&quot;	, },
+	{ 0, 0, },
+};
+
+static const __devinitdata struct lookup pcmcia_mem_attr[] = {
+	{ WIN_ADDR_SPACE_IO	, &quot;IO&quot;		, },
+	{ WIN_MEMORY_TYPE_AM	, &quot;typeAM&quot;	, },
+	{ WIN_ENABLE		, &quot;enable&quot;	, },
+	{ WIN_DATA_WIDTH_8	, &quot;8bit&quot;	, },
+	{ WIN_DATA_WIDTH_16	, &quot;16bit&quot;	, },
+	{ WIN_DATA_WIDTH_32	, &quot;32bit&quot;	, },
+	{ WIN_PAGED		, &quot;paged&quot;	, },
+	{ WIN_SHARED		, &quot;shared&quot;	, },
+	{ WIN_FIRST_SHARED	, &quot;first_shared&quot;, },
+	{ WIN_USE_WAIT		, &quot;wait&quot;	, },
+	{ WIN_STRICT_ALIGN	, &quot;strict_align&quot;, },
+	{ WIN_MAP_BELOW_1MB	, &quot;below_1MB&quot;	, },
+	{ WIN_PREFETCH		, &quot;prefetch&quot;	, },
+	{ WIN_CACHEABLE		, &quot;cacheable&quot;	, },
+	{ 0, 0, },
+};
+
+static int __devinit
+dev_config(struct pcmcia_device *pcmcia, struct softing_cs *csdev)
+{
+	struct softing *sdev = &amp;csdev-&gt;softing;
+	cistpl_cftable_entry_t *cf;
+	int ret;
+	int last_ret = 0;
+	int last_fn  = 0;
+	struct {
+		tuple_t tuple;
+		unsigned char buff[64];
+		cisparse_t parse;
+	} cfg;
+	config_info_t config;
+	cistpl_cftable_entry_t def_cf = { 0, };
+	win_req_t req;
+	memreq_t map;
+
+	mod_info(&quot;%s&quot;, pcmcia-&gt;devname);
+
+	cfg.tuple.Attributes		= 0;
+	cfg.tuple.TupleData		= (cisdata_t *)cfg.buff;
+	cfg.tuple.TupleDataMax	= sizeof(cfg.buff);
+	cfg.tuple.TupleOffset	= 0;
+	/* Get configuration register information */
+	cfg.tuple.DesiredTuple	= CISTPL_CONFIG;
+	if (pcmcia_get_first_tuple(pcmcia, &amp;cfg.tuple))
+		goto cs_failed;
+	if (pcmcia_get_tuple_data(pcmcia, &amp;cfg.tuple))
+		goto cs_failed;
+	if (pcmcia_parse_tuple(pcmcia, &amp;cfg.tuple, &amp;cfg.parse))
+		goto cs_failed;
+	csdev-&gt;conf.ConfigBase = cfg.parse.config.base;
+	csdev-&gt;conf.Present	  = cfg.parse.config.rmask[0];
+
+	/* get current Vcc */
+	ret = pcmcia_get_configuration_info(pcmcia, &amp;config);
+	if (ret != CS_SUCCESS)
+		goto cs_failed;
+
+	cf = &amp;cfg.parse.cftable_entry;
+	cfg.tuple.DesiredTuple	= CISTPL_CFTABLE_ENTRY;
+
+	if (pcmcia_get_first_tuple(pcmcia, &amp;cfg.tuple))
+		goto cs_failed;
+	do {
+		if (pcmcia_get_tuple_data(pcmcia, &amp;cfg.tuple)
+			|| pcmcia_parse_tuple(pcmcia, &amp;cfg.tuple, &amp;cfg.parse))
+			goto do_next;
+		if (cf-&gt;flags &amp; CISTPL_CFTABLE_DEFAULT)
+			def_cf = *cf;
+		if (!cf-&gt;index)
+			goto do_next;
+		csdev-&gt;conf.ConfigIndex = cf-&gt;index;
+		/* power settings (Vcc &amp; Vpp) */
+		if (cf-&gt;vcc.present &amp; (1 &lt;&lt; CISTPL_POWER_VNOM)) {
+			if (config.Vcc !=
+				cf-&gt;vcc.param[CISTPL_POWER_VNOM]/10000) {
+				mod_alert(&quot;%s: cf-&gt;Vcc mismatch\n&quot;, __FILE__);
+				goto do_next;
+			}
+		} else if (def_cf.vcc.present &amp; (1 &lt;&lt; CISTPL_POWER_VNOM)) {
+			if (config.Vcc !=
+				def_cf.vcc.param[CISTPL_POWER_VNOM]/10000) {
+				mod_alert(&quot;%s: cf-&gt;Vcc mismatch\n&quot;, __FILE__);
+				goto do_next;
+			}
+		}
+		if (cf-&gt;vpp1.present &amp; (1 &lt;&lt; CISTPL_POWER_VNOM))
+			config.Vpp1
+				= config.Vpp2
+				= cf-&gt;vpp1.param[CISTPL_POWER_VNOM] / 10000;
+
+		else if (def_cf.vpp1.present &amp; (1 &lt;&lt; CISTPL_POWER_VNOM))
+			config.Vpp1
+				= config.Vpp2
+				= def_cf.vpp1.param[CISTPL_POWER_VNOM] / 10000;
+
+		/* interrupt ? */
+		if (cf-&gt;irq.IRQInfo1 || def_cf.irq.IRQInfo1)
+			csdev-&gt;conf.Attributes |= CONF_ENABLE_IRQ;
+		/* IO window */
+		csdev-&gt;io.NumPorts1
+			= csdev-&gt;io.NumPorts2
+			= 0;
+		if ((cf-&gt;io.nwin &gt; 0) || (def_cf.io.nwin &gt; 0)) {
+			cistpl_io_t *io = (cf-&gt;io.nwin) ? &amp;cf-&gt;io : &amp;def_cf.io;
+			csdev-&gt;io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+			if (!(io-&gt;flags &amp; CISTPL_IO_8BIT))
+				csdev-&gt;io.Attributes1 = IO_DATA_PATH_WIDTH_16;
+			if (!(io-&gt;flags &amp; CISTPL_IO_16BIT))
+				csdev-&gt;io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+			csdev-&gt;io.IOAddrLines
+				= io-&gt;flags &amp; CISTPL_IO_LINES_MASK;
+			csdev-&gt;io.BasePort1 = io-&gt;win[0].base;
+			csdev-&gt;io.NumPorts1 = io-&gt;win[0].len ;
+			if (io-&gt;nwin &gt; 1) {
+				csdev-&gt;io.Attributes2 = csdev-&gt;io.Attributes1;
+				csdev-&gt;io.BasePort2	 = io-&gt;win[1].base;
+				csdev-&gt;io.NumPorts2	 = io-&gt;win[1].base;
+			}
+			/* reserve IO, but don't enable it. */
+			ret = pcmcia_request_io(pcmcia, &amp;csdev-&gt;io);
+			if (ret != CS_SUCCESS) {
+				mod_alert(&quot;pcmcia_request_io() mismatch\n&quot;);
+				goto do_next;
+			}
+		}
+		/* Memory window */
+		if ((cf-&gt;mem.nwin &gt; 0) || (def_cf.mem.nwin &gt; 0)) {
+			cistpl_mem_t *mem
+				= (cf-&gt;mem.nwin) ? &amp;cf-&gt;mem : &amp;def_cf.mem;
+			req.Attributes = ((sdev-&gt;desc-&gt;generation &gt;= 2)
+					? WIN_DATA_WIDTH_16 : WIN_DATA_WIDTH_8)
+				| WIN_MEMORY_TYPE_CM
+				| WIN_ENABLE;
+			req.Base = mem-&gt;win[0].host_addr;
+			req.Size = mem-&gt;win[0].len;
+			if (req.Size &lt; 0x1000)
+				req.Size = 0x1000;
+			req.AccessSpeed = 0;
+			ret = pcmcia_request_window(&amp;pcmcia, &amp;req, &amp;csdev-&gt;win);
+			if (ret != CS_SUCCESS) {
+				mod_alert(&quot;pcmcia_request_window() mismatch\n&quot;);
+				goto do_next;
+			}
+			if (sdev-&gt;desc-&gt;generation &lt; 2) {
+				csdev-&gt;win-&gt;ctl.flags
+					= MAP_ACTIVE | MAP_USE_WAIT;
+				csdev-&gt;win-&gt;ctl.speed = 3;
+			}
+			map.Page = 0;
+			map.CardOffset = mem-&gt;win[0].card_addr;
+			if (pcmcia_map_mem_page(csdev-&gt;win, &amp;map)) {
+				mod_alert(&quot;pcmcia_map_mem_page() mismatch\n&quot;);
+				goto do_next_win;
+			}
+		} else {
+			mod_info(&quot;no memory window in tuple %u&quot;, cf-&gt;index);
+			goto do_next;
+		}
+		break;
+do_next_win:
+		pcmcia_release_window(csdev-&gt;win);
+do_next:
+		pcmcia_disable_device(pcmcia);
+		if (pcmcia_get_next_tuple(pcmcia, &amp;cfg.tuple))
+			goto cs_failed;
+	} while (1);
+
+	if (csdev-&gt;conf.Attributes &amp; CONF_ENABLE_IRQ) {
+		/*csdev-&gt;irq.Handler  = dev_interrupt_nshared;
+		csdev-&gt;irq.Instance = card;
+		csdev-&gt;irq.Attributes |= IRQ_HANDLE_PRESENT;
+		*/
+		if (pcmcia_request_irq(pcmcia, &amp;csdev-&gt;irq))
+			goto cs_failed;
+	}
+
+	if (pcmcia_request_configuration(pcmcia, &amp;csdev-&gt;conf))
+		goto cs_failed;
+
+	/* Finally, report what we've done */
+	printk(KERN_INFO &quot;[%s] %s: index 0x%02x&quot;,
+			THIS_MODULE-&gt;name,
+			pcmcia-&gt;devname,
+			csdev-&gt;conf.ConfigIndex);
+	printk(&quot;, Vcc %d.%01d&quot;, config.Vcc/10, config.Vcc%10);
+	if (config.Vpp1)
+		printk(&quot;, Vpp %d.%d&quot;, config.Vpp1/10, config.Vpp1%10);
+	if (csdev-&gt;conf.Attributes &amp; CONF_ENABLE_IRQ) {
+		printk(&quot;, irq %d&quot;, csdev-&gt;irq.AssignedIRQ);
+		sdev-&gt;irq.nr = csdev-&gt;irq.AssignedIRQ;
+	}
+	if (csdev-&gt;io.NumPorts1) {
+		int tmp;
+		const char *p;
+		printk(&quot;, io 0x%04x-0x%04x&quot;
+				, pcmcia-&gt;io.BasePort1
+				, csdev-&gt;io.BasePort1+csdev-&gt;io.NumPorts1-1);
+		tmp = csdev-&gt;io.Attributes1;
+		if (tmp) {
+			do {
+				p = lookup_mask(pcmcia_io_attr, &amp;tmp);
+				if (p)
+					printk(&quot; %s&quot;, p);
+			} while (p);
+		}
+	}
+	if (csdev-&gt;io.NumPorts2) {
+		int tmp;
+		const char *p;
+		printk(&quot; &amp; 0x%04x-0x%04x&quot;
+			, csdev-&gt;io.BasePort2
+			, csdev-&gt;io.BasePort2+csdev-&gt;io.NumPorts2-1);
+		tmp = csdev-&gt;io.Attributes2;
+		if (tmp)
+			do {
+				p = lookup_mask(pcmcia_io_attr, &amp;tmp);
+				if (p)
+					printk(&quot; %s&quot;, p);
+			} while (p);
+	}
+	if (csdev-&gt;win) {
+		int tmp;
+		const char *p;
+		sdev-&gt;dpram.phys = req.Base;
+		sdev-&gt;dpram.size = req.Size;
+		printk(&quot;, mem 0x%08lx-0x%08lx&quot;
+				, sdev-&gt;dpram.phys
+				, sdev-&gt;dpram.phys + sdev-&gt;dpram.size-1);
+		tmp = req.Attributes;
+		if (tmp)
+			do {
+				p = lookup_mask(pcmcia_mem_attr, &amp;tmp);
+				if (p)
+					printk(&quot; %s&quot;, p);
+			} while (p);
+	}
+	printk(&quot;\n&quot;);
+	return 0;
+
+cs_failed:
+	cs_error(pcmcia, last_fn, last_ret);
+	pcmcia_release_window(csdev-&gt;win);
+	pcmcia_disable_device(pcmcia);
+	return EINVAL;
+}
+
+static void driver_remove(struct pcmcia_device *pcmcia)
+{
+	struct softing *card = (struct softing *)pcmcia-&gt;priv;
+	struct softing_cs *cs = softing2cs(card);
+	mod_trace(&quot;%s,device'%s'&quot;, card-&gt;id.name, pcmcia-&gt;devname);
+	rm_softing(card);
+	/* release pcmcia stuff */
+	pcmcia_release_window(cs-&gt;win);
+	pcmcia_disable_device(pcmcia);
+	/* free bits */
+	kfree(cs);
+}
+
+static int __devinit driver_probe(struct pcmcia_device *pcmcia)
+{
+	struct softing_cs *cs;
+	struct softing		*card;
+	int ret = 0;
+
+	mod_trace(&quot;on %s&quot;, pcmcia-&gt;devname);
+
+	/* Create new softing device */
+	cs = kzalloc(sizeof(*cs), GFP_KERNEL);
+	if (!cs) {
+		ret = ENOMEM;
+		goto no_mem;
+	}
+	card = &amp;cs-&gt;softing;
+	pcmcia-&gt;priv = card;
+	card-&gt;id.manf = pcmcia-&gt;manf_id;
+	card-&gt;id.prod = pcmcia-&gt;card_id;
+	card-&gt;desc = softing_lookup_desc(card-&gt;id.manf, card-&gt;id.prod);
+	card-&gt;dev = &amp;pcmcia-&gt;dev;
+	if (card-&gt;desc-&gt;generation &gt;= 2) {
+		card-&gt;fn.reset = card_reset_via_dpram;
+	} else {
+		card-&gt;fn.reset = card_reset_via_pcmcia;
+		card-&gt;fn.enable_irq = card_enable_irq_via_pcmcia;
+	}
+
+	card-&gt;nbus = 2;
+	card-&gt;irq.shared = (card-&gt;desc-&gt;generation &gt;= 2);
+	/* presets */
+	cs-&gt;irq.Attributes
+		= card-&gt;irq.shared
+		? IRQ_TYPE_DYNAMIC_SHARING : IRQ_TYPE_EXCLUSIVE;
+	cs-&gt;irq.IRQInfo1	 = IRQ_LEVEL_ID;
+	cs-&gt;irq.Handler	 = 0;
+	cs-&gt;conf.Attributes = 0;
+	cs-&gt;conf.IntType	  = INT_MEMORY_AND_IO;
+
+	ret = dev_config(pcmcia, cs);
+	if (ret)
+		goto config_failed;
+
+	if (card-&gt;dpram.size != 0x1000) {
+		mod_alert(&quot;dpram size 0x%lx mismatch\n&quot;, card-&gt;dpram.size);
+		goto wrong_dpram;
+	}
+
+	if (!mk_softing(card))
+		return 0;
+	/* else */
+wrong_dpram:
+	pcmcia_release_window(cs-&gt;win);
+config_failed:
+	kfree(cs);
+no_mem:
+	pcmcia_disable_device(pcmcia);
+	return ret ? ret : EINVAL;
+}
+
+static struct pcmcia_device_id driver_ids[] = {
+	/* softing */
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0001),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0002),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0004),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0005),
+	/* vector , manufacturer? */
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0081),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0084),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0085),
+	/* EDIC */
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0102),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0105),
+	PCMCIA_DEVICE_NULL,
+};
+
+MODULE_DEVICE_TABLE(pcmcia, driver_ids);
+
+static struct pcmcia_driver softing_cs_driver = {
+	.owner		= THIS_MODULE,
+	.drv			= {
+	.name		= &quot;softing_cs&quot;,
+	},
+	.probe		= driver_probe,
+	.remove		= driver_remove,
+	.id_table	= driver_ids,
+};
+
+static int __init mod_start(void)
+{
+	mod_trace(&quot;&quot;);
+	return pcmcia_register_driver(&amp;softing_cs_driver);
+}
+
+static void __exit mod_stop(void)
+{
+	mod_trace(&quot;&quot;);
+	pcmcia_unregister_driver(&amp;softing_cs_driver);
+}
+
+module_init(mod_start);
+module_exit(mod_stop);
+
+MODULE_DESCRIPTION(&quot;softing CANcard driver&quot;
+		&quot;, links PCMCIA card to softing driver&quot;);
+MODULE_LICENSE(&quot;GPL&quot;);
+MODULE_SUPPORTED_DEVICE(&quot;softing CANcard2&quot;);
+

Added: trunk/kernel/2.6/drivers/net/can/softing/softing_fw.c
===================================================================
--- trunk/kernel/2.6/drivers/net/can/softing/softing_fw.c	2008-07-01 09:16:34 UTC (rev 802)
+++ trunk/kernel/2.6/drivers/net/can/softing/softing_fw.c	2008-07-01 10:09:12 UTC (rev 803)
@@ -0,0 +1,690 @@
+/*
+* drivers/net/can/softing/softing_fw.c
+*
+* Copyright (C) 2008
+*
+* - Kurt Van Dijck, EIA Electronics
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the version 2 of the GNU General Public License
+* as published by the Free Software Foundation
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/device.h&gt;
+#include &lt;linux/firmware.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;linux/io.h&gt;
+
+#include &quot;softing.h&quot;
+
+#define fw_dir &quot;softing-4.6/&quot;
+
+static const struct softing_desc carddescs[] = {
+{
+	.name = &quot;CANcard&quot;,
+	.manf = 0x0168, .prod = 0x001,
+	.generation = 1,
+	.freq = 16, .max_brp = 32, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir &quot;bcard.bin&quot;,},
+	.load = {0x0120, 0x00f600, fw_dir &quot;ldcard.bin&quot;,},
+	.app = {0x0010, 0x0d0000, fw_dir &quot;cancard.bin&quot;,},
+}, {
+	.name = &quot;CANcard-NEC&quot;,
+	.manf = 0x0168, .prod = 0x002,
+	.generation = 1,
+	.freq = 16, .max_brp = 32, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir &quot;bcard.bin&quot;,},
+	.load = {0x0120, 0x00f600, fw_dir &quot;ldcard.bin&quot;,},
+	.app = {0x0010, 0x0d0000, fw_dir &quot;cancard.bin&quot;,},
+}, {
+	.name = &quot;CANcard-SJA&quot;,
+	.manf = 0x0168, .prod = 0x004,
+	.generation = 1,
+	.freq = 20, .max_brp = 32, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir &quot;bcard.bin&quot;,},
+	.load = {0x0120, 0x00f600, fw_dir &quot;ldcard.bin&quot;,},
+	.app = {0x0010, 0x0d0000, fw_dir &quot;cansja.bin&quot;,},
+}, {
+	.name = &quot;CANcard-2&quot;,
+	.manf = 0x0168, .prod = 0x005,
+	.generation = 2,
+	.freq = 24, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir &quot;bcard2.bin&quot;,},
+	.load = {0x0120, 0x00f600, fw_dir &quot;ldcard2.bin&quot;,},
+	.app = {0x0010, 0x0d0000, fw_dir &quot;cancrd2.bin&quot;,},
+}, {
+	.name = &quot;Vector-CANcard&quot;,
+	.manf = 0x0168, .prod = 0x081,
+	.generation = 1,
+	.freq = 16, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir &quot;bcard.bin&quot;,},
+	.load = {0x0120, 0x00f600, fw_dir &quot;ldcard.bin&quot;,},
+	.app = {0x0010, 0x0d0000, fw_dir &quot;cancard.bin&quot;,},
+}, {
+	.name = &quot;Vector-CANcard-SJA&quot;,
+	.manf = 0x0168, .prod = 0x084,
+	.generation = 1,
+	.freq = 20, .max_brp = 32, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir &quot;bcard.bin&quot;,},
+	.load = {0x0120, 0x00f600, fw_dir &quot;ldcard.bin&quot;,},
+	.app = {0x0010, 0x0d0000, fw_dir &quot;cansja.bin&quot;,},
+}, {
+	.name = &quot;Vector-CANcard-2&quot;,
+	.manf = 0x0168, .prod = 0x085,
+	.generation = 2,
+	.freq = 24, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir &quot;bcard2.bin&quot;,},
+	.load = {0x0120, 0x00f600, fw_dir &quot;ldcard2.bin&quot;,},
+	.app = {0x0010, 0x0d0000, fw_dir &quot;cancrd2.bin&quot;,},
+}, {
+	.name = &quot;EDICcard-NEC&quot;,
+	.manf = 0x0168, .prod = 0x102,
+	.generation = 1,
+	.freq = 16, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir &quot;bcard.bin&quot;,},
+	.load = {0x0120, 0x00f600, fw_dir &quot;ldcard.bin&quot;,},
+	.app = {0x0010, 0x0d0000, fw_dir &quot;cancard.bin&quot;,},
+}, {
+	.name = &quot;EDICcard-2&quot;,
+	.manf = 0x0168, .prod = 0x105,
+	.generation = 2,
+	.freq = 24, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir &quot;bcard2.bin&quot;,},
+	.load = {0x0120, 0x00f600, fw_dir &quot;ldcard2.bin&quot;,},
+	.app = {0x0010, 0x0d0000, fw_dir &quot;cancrd2.bin&quot;,},
+	},
+
+/* never tested, but taken from original softing */
+{	.name = &quot;CAN-AC2-104&quot;,
+	.manf = 0x0000, .prod = 0x009,
+	.generation = 1,
+	.freq = 25, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x1000,
+	.boot = {0x0000, 0x000000, fw_dir &quot;boot104.bin&quot;,},
+	.load = {0x0800, 0x035000, fw_dir &quot;ld104.bin&quot;,},
+	.app = {0x0010, 0x120000, fw_dir &quot;canpc104.bin&quot;,},
+	},
+{0, 0,},
+};
+
+const struct softing_desc *softing_lookup_desc
+					(unsigned int manf, unsigned int prod)
+{
+	const struct softing_desc *lp = carddescs;
+	for (; lp-&gt;name; ++lp) {
+		if ((lp-&gt;manf == manf) &amp;&amp; (lp-&gt;prod == prod))
+			return lp;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(softing_lookup_desc);
+
+int softing_fct_cmd(struct softing *card, int cmd, int vector, const char *msg)
+{
+	int ret;
+	unsigned long stamp;
+	if (vector == RES_OK)
+		vector = RES_NONE;
+	card-&gt;dpram.fct-&gt;param[0] = cmd;
+	card-&gt;dpram.fct-&gt;host_access = vector;
+	/* be sure to flush this to the card */
+	wmb();
+	stamp = jiffies;
+	/*wait for card */
+	do {
+		ret = card-&gt;dpram.fct-&gt;host_access;
+		/* don't have any cached variables */
+		rmb();
+		if (ret == RES_OK) {
+			/*don't read return-value now */
+			ret = card-&gt;dpram.fct-&gt;returned;
+			if (ret)
+				mod_alert(&quot;%s returned %u&quot;, msg, ret);
+			return 0;
+		}
+		if ((jiffies - stamp) &gt;= 1 * HZ)
+			break;
+		if (in_interrupt())
+			/* go as fast as possible */
+			continue;
+		/* process context =&gt; relax */
+		schedule();
+	} while (!signal_pending(current));
+
+	if (ret == RES_NONE) {
+		mod_alert(&quot;%s, no response from card on %u/0x%02x&quot;
+			, msg, cmd, vector);
+		return 1;
+	} else {
+		mod_alert(&quot;%s, bad response from card on %u/0x%02x, 0x%04x&quot;
+			, msg, cmd, vector, ret);
+		/*make sure to return something not 0 */
+		return ret ? ret : 1;
+	}
+}
+
+int softing_bootloader_command(struct softing *card
+		, int command, const char *msg)
+{
+	int ret;
+	unsigned long stamp;
+	card-&gt;dpram.receipt[0] = RES_NONE;
+	card-&gt;dpram.command[0] = command;
+	/* be sure to flush this to the card */
+	wmb();
+	stamp = jiffies;
+	/*wait for card */
+	do {
+		ret = card-&gt;dpram.receipt[0];
+		/* don't have any cached variables */
+		rmb();
+		if (ret == RES_OK)
+			return 0;
+		if ((jiffies - stamp) &gt;= (3 * HZ))
+			break;
+		schedule();
+	} while (!signal_pending(current));
+
+	switch (ret) {
+	case RES_NONE:
+		mod_alert(&quot;%s: no response from card&quot;, msg);
+		break;
+	case RES_NOK:
+		mod_alert(&quot;%s: response from card nok&quot;, msg);
+		break;
+	case RES_UNKNOWN:
+		mod_alert(&quot;%s: command 0x%04x unknown&quot;, msg, command);
+		break;
+	default:
+		mod_alert(&quot;%s: bad response from card (%u)]&quot;, msg, ret);
+		break;
+	}
+	return ret ? ret : 1;
+}
+
+struct fw_hdr {
+	u16 type;
+	u32 addr;
+	u16 len;
+	u16 checksum;
+	const unsigned char *base;
+} __attribute__ ((packed));
+
+static int fw_parse(const unsigned char **pmem, struct fw_hdr *hdr)
+{
+	u16 tmp;
+	const unsigned char *mem;
+	const unsigned char *end;
+	mem = *pmem;
+	hdr-&gt;type = (mem[0] &lt;&lt; 0) | (mem[1] &lt;&lt; 8);
+	hdr-&gt;addr = (mem[2] &lt;&lt; 0) | (mem[3] &lt;&lt; 8)
+		 | (mem[4] &lt;&lt; 16) | (mem[5] &lt;&lt; 24);
+	hdr-&gt;len = (mem[6] &lt;&lt; 0) | (mem[7] &lt;&lt; 8);
+	hdr-&gt;base = &amp;mem[8];
+	hdr-&gt;checksum =
+		 (hdr-&gt;base[hdr-&gt;len] &lt;&lt; 0) | (hdr-&gt;base[hdr-&gt;len + 1] &lt;&lt; 8);
+	for (tmp = 0, mem = *pmem, end = &amp;hdr-&gt;base[hdr-&gt;len]; mem &lt; end; ++mem)
+		tmp += *mem;
+	if (tmp != hdr-&gt;checksum)
+		return EINVAL;
+	*pmem += 10 + hdr-&gt;len;
+	return 0;
+}
+
+int softing_load_fw(const char *file, struct softing *card,
+			unsigned char *virt, unsigned int size, int offset)
+{
+	const struct firmware *fw;
+	const unsigned char *mem;
+	const unsigned char *end;
+	int ret;
+	u32 start_addr;
+	struct fw_hdr rec;
+	int ok = 0;
+	unsigned char buf[256];
+
+	ret = request_firmware(&amp;fw, file, card-&gt;dev);
+	if (ret) {
+		mod_alert(&quot;request_firmware(%s) got %i&quot;, file, ret);
+		return ret;
+	}
+	mod_trace(&quot;%s, firmware(%s) got %u bytes, offset %c0x%04x&quot;
+			, card-&gt;id.name, file, (unsigned int)fw-&gt;size,
+		  (offset &gt;= 0) ? '+' : '-', abs(offset));
+	/* parse the firmware */
+	mem = fw-&gt;data;
+	end = &amp;mem[fw-&gt;size];
+	/* look for header record */
+	if (fw_parse(&amp;mem, &amp;rec))
+		goto fw_end;
+	if (rec.type != 0xffff) {
+		mod_alert(&quot;firware starts with type 0x%04x&quot;, rec.type);
+		goto fw_end;
+	}
+	if (strncmp(&quot;Structured Binary Format, Softing GmbH&quot;
+			, rec.base, rec.len)) {
+		mod_info(&quot;firware string '%.*s'&quot;, rec.len, rec.base);
+		goto fw_end;
+	}
+	ok |= 1;
+	/* ok, we had a header */
+	while (mem &lt; end) {
+		if (fw_parse(&amp;mem, &amp;rec))
+			break;
+		if (rec.type == 3) {
+			/*start address */
+			start_addr = rec.addr;
+			ok |= 2;
+			continue;
+		} else if (rec.type == 1) {
+			/*eof */
+			ok |= 4;
+			goto fw_end;
+		} else if (rec.type != 0) {
+			mod_alert(&quot;unknown record type 0x%04x&quot;, rec.type);
+			break;
+		}
+
+		if ((rec.addr + rec.len + offset) &gt; size) {
+			mod_alert(&quot;firmware out of range (0x%08x / 0x%08x)&quot;
+			, (rec.addr + rec.len + offset), size);
+			goto fw_end;
+		}
+		memcpy_toio(&amp;virt[rec.addr + offset],
+				 rec.base, rec.len);
+		/* be sure to flush caches from IO space */
+		mb();
+		if (rec.len &gt; sizeof(buf)) {
+			mod_info(&quot;record is big (%u bytes), not verifying&quot;
+				, rec.len);
+			continue;
+		}
+		/* verify record data */
+		memcpy_fromio(buf, &amp;virt[rec.addr + offset], rec.len);
+		if (!memcmp(buf, rec.base, rec.len))
+			/* is ok */
+			continue;
+		mod_alert(&quot;0x%08x:0x%03x at 0x%p failed&quot;, rec.addr, rec.len
+			, &amp;virt[rec.addr + offset]);
+		goto fw_end;
+	}
+fw_end:
+	release_firmware(fw);
+	if (0x5 == (ok &amp; 0x5)) {
+		/*got eof &amp; start */
+		return 0;
+	}
+	mod_alert(&quot;failed&quot;);
+	return EINVAL;
+}
+
+int softing_load_app_fw(const char *file, struct softing *card)
+{
+	const struct firmware *fw;
+	const unsigned char *mem;
+	const unsigned char *end;
+	int ret;
+	struct fw_hdr rec;
+	int ok = 0;
+	u32 start_addr = 0;
+	u16 rx_sum;
+	unsigned int sum;
+	const unsigned char *mem_lp;
+	const unsigned char *mem_end;
+	struct cpy {
+		u32 src;
+		u32 dst;
+		u16 len;
+		u8 do_cs;
+	} __attribute__((packed)) *pcpy =
+		 (struct cpy *)&amp;card-&gt;dpram.command[1];
+
+	ret = request_firmware(&amp;fw, file, card-&gt;dev);
+	if (ret) {
+		mod_alert(&quot;request_firmware(%s) got %i&quot;, file, ret);
+		return ret;
+	}
+	mod_trace(&quot;%s, firmware(%s) got %lu bytes&quot;, card-&gt;id.name, file,
+		  (unsigned long)fw-&gt;size);
+	/* parse the firmware */
+	mem = fw-&gt;data;
+	end = &amp;mem[fw-&gt;size];
+	/* look for header record */
+	if (fw_parse(&amp;mem, &amp;rec))
+		goto fw_end;
+	if (rec.type != 0xffff) {
+		mod_alert(&quot;firware starts with type 0x%04x&quot;, rec.type);
+		goto fw_end;
+	}
+	if (strncmp(&quot;Structured Binary Format, Softing GmbH&quot;
+		, rec.base, rec.len)) {
+		mod_info(&quot;firware string '%.*s'&quot;, rec.len, rec.base);
+		goto fw_end;
+	}
+	ok |= 1;
+	/* ok, we had a header */
+	while (mem &lt; end) {
+		if (fw_parse(&amp;mem, &amp;rec))
+			break;
+
+		if (rec.type == 3) {
+			/*start address */
+			start_addr = rec.addr;
+			ok |= 2;
+			continue;
+		} else if (rec.type == 1) {
+			/*eof */
+			ok |= 4;
+			goto fw_end;
+		} else if (rec.type != 0) {
+			mod_alert(&quot;unknown record type 0x%04x&quot;, rec.type);
+			break;
+		}
+		/* regualar data */
+		for (sum = 0, mem_lp = rec.base, mem_end = &amp;mem_lp[rec.len];
+			mem_lp &lt; mem_end; ++mem_lp)
+			sum += *mem_lp;
+
+		memcpy_toio(&amp;card-&gt;dpram. virt[card-&gt;desc-&gt;app.offs],
+				 rec.base, rec.len);
+		pcpy-&gt;src = card-&gt;desc-&gt;app.offs + card-&gt;desc-&gt;app.addr;
+		pcpy-&gt;dst = rec.addr;
+		pcpy-&gt;len = rec.len;
+		pcpy-&gt;do_cs = 1;
+		if (softing_bootloader_command(card, 1, &quot;loading app.&quot;))
+			goto fw_end;
+		/*verify checksum */
+		rx_sum = card-&gt;dpram.receipt[1];
+		if (rx_sum != (sum &amp; 0xffff)) {
+			mod_alert(&quot;SRAM seems to be damaged&quot;
+				&quot;, wanted 0x%04x, got 0x%04x&quot;, sum, rx_sum);
+			goto fw_end;
+		}
+	}
+fw_end:
+	release_firmware(fw);
+	if (ok == 7) {
+		/*got start, start_addr, &amp; eof */
+		struct cmd {
+			u32 start;
+			u8 autorestart;
+		} *pcmd = (struct cmd *)&amp;card-&gt;dpram.command[1];
+		pcmd-&gt;start = start_addr;
+		pcmd-&gt;autorestart = 1;
+		if (!softing_bootloader_command(card, 3, &quot;start app.&quot;)) {
+			mod_trace(&quot;%s: card app. run at 0x%06x&quot;
+				, card-&gt;id.name, start_addr);
+			return 0;
+		}
+	}
+	mod_alert(&quot;failed&quot;);
+	return EINVAL;
+}
+
+int softing_reset_chip(struct softing *card)
+{
+	mod_trace(&quot;%s&quot;, card-&gt;id.name);
+	do {
+		/*reset chip */
+		card-&gt;dpram.info-&gt;reset_rcv_fifo = 0;
+		card-&gt;dpram.info-&gt;reset = 1;
+		if (!softing_fct_cmd(card, 0, 0, &quot;reset_chip&quot;))
+			break;
+		if (signal_pending(current))
+			goto failed;
+		/*sync */
+		if (softing_fct_cmd(card, 99, 0x55, &quot;sync-a&quot;))
+			goto failed;
+		if (softing_fct_cmd(card, 99, 0xaa, &quot;sync-a&quot;))
+			goto failed;
+	} while (1);
+	card-&gt;tx.pending = 0;
+	return 0;
+failed:
+	return -EIO;
+}
+
+int softing_reinit(struct softing *card, int bus0, int bus1)
+{
+	int ret;
+	int restarted_bus = -1;
+	mod_trace(&quot;%s&quot;, card-&gt;id.name);
+	if (!card-&gt;fw.up)
+		return -EIO;
+	if (bus0 &lt; 0) {
+		bus0 = (card-&gt;bus[0]-&gt;netdev-&gt;flags &amp; IFF_UP) ? 1 : 0;
+		if (bus0)
+			restarted_bus = 0;
+	} else if (bus1 &lt; 0) {
+		bus1 = (card-&gt;bus[1]-&gt;netdev-&gt;flags &amp; IFF_UP) ? 1 : 0;
+		if (bus1)
+			restarted_bus = 1;
+	}
+	/* collect info */
+	if (card-&gt;bus[0]) {
+		card-&gt;bus[0]-&gt;can.state = CAN_STATE_STOPPED;
+		softing_flush_echo_skb(card-&gt;bus[0]);
+	}
+	if (card-&gt;bus[1]) {
+		card-&gt;bus[1]-&gt;can.state = CAN_STATE_STOPPED;
+		softing_flush_echo_skb(card-&gt;bus[1]);
+	}
+
+	/* start acting */
+	if (!bus0 &amp;&amp; !bus1) {
+		softing_card_irq(card, 0);
+		softing_reset_chip(card);
+		if (card-&gt;bus[0])
+			netif_carrier_off(card-&gt;bus[0]-&gt;netdev);
+		if (card-&gt;bus[1])
+			netif_carrier_off(card-&gt;bus[1]-&gt;netdev);
+		return 0;
+	}
+	ret = softing_reset_chip(card);
+	if (ret) {
+		softing_card_irq(card, 0);
+		return ret;
+	}
+	if (bus0) {
+		mod_trace(&quot;%s opening at %u kbit&quot;
+			  &quot; %u %u %u %u %u %u&quot;, card-&gt;bus[0]-&gt;netdev-&gt;name,
+			  card-&gt;bus[0]-&gt;can.bitrate / 1000,
+			  card-&gt;bus[0]-&gt;can.bittime.std.brp,
+			  card-&gt;bus[0]-&gt;can.bittime.std.sjw,
+			  card-&gt;bus[0]-&gt;can.bittime.std.prop_seg,
+			  card-&gt;bus[0]-&gt;can.bittime.std.phase_seg1,
+			  card-&gt;bus[0]-&gt;can.bittime.std.phase_seg2,
+			  card-&gt;bus[0]-&gt;can.bittime.std.sam);
+		/*init chip */
+		card-&gt;dpram.fct-&gt;param[1] = card-&gt;bus[0]-&gt;can.bittime.std.brp;
+		card-&gt;dpram.fct-&gt;param[2] = card-&gt;bus[0]-&gt;can.bittime.std.sjw;
+		card-&gt;dpram.fct-&gt;param[3] =
+			 card-&gt;bus[0]-&gt;can.bittime.std.phase_seg1 +
+			 card-&gt;bus[0]-&gt;can.bittime.std.prop_seg;
+		card-&gt;dpram.fct-&gt;param[4] =
+			 card-&gt;bus[0]-&gt;can.bittime.std.phase_seg2;
+		card-&gt;dpram.fct-&gt;param[5] = card-&gt;bus[0]-&gt;can.bittime.std.sam;
+		if (softing_fct_cmd(card, 1, 0, &quot;initialize_chip[0]&quot;))
+			goto failed;
+		/*set mode */
+		card-&gt;dpram.fct-&gt;param[1] = 0;
+		card-&gt;dpram.fct-&gt;param[2] = 0;
+		if (softing_fct_cmd(card, 3, 0, &quot;set_mode[0]&quot;))
+			goto failed;
+		/*set filter */
+		card-&gt;dpram.fct-&gt;param[1] = 0x0000;/*card-&gt;bus[0].s.msg; */
+		card-&gt;dpram.fct-&gt;param[2] = 0x07ff;/*card-&gt;bus[0].s.msk; */
+		card-&gt;dpram.fct-&gt;param[3] = 0x0000;/*card-&gt;bus[0].l.msg; */
+		card-&gt;dpram.fct-&gt;param[4] = 0xffff;/*card-&gt;bus[0].l.msk; */
+		card-&gt;dpram.fct-&gt;param[5] = 0x0000;/*card-&gt;bus[0].l.msg &gt;&gt; 16;*/
+		card-&gt;dpram.fct-&gt;param[6] = 0x1fff;/*card-&gt;bus[0].l.msk &gt;&gt; 16;*/
+		if (softing_fct_cmd(card, 7, 0, &quot;set_filter[0]&quot;))
+			goto failed;
+		/*set output control */
+		card-&gt;dpram.fct-&gt;param[1] = card-&gt;bus[0]-&gt;output;
+		if (softing_fct_cmd(card, 5, 0, &quot;set_output[0]&quot;))
+			goto failed;
+	}
+	if (bus1) {
+		mod_trace(&quot;%s opening at %u kbit&quot;
+			  &quot; %u %u %u %u %u %u&quot;, card-&gt;bus[1]-&gt;netdev-&gt;name,
+			  card-&gt;bus[0]-&gt;can.bitrate / 1000,
+			  card-&gt;bus[1]-&gt;can.bittime.std.brp,
+			  card-&gt;bus[1]-&gt;can.bittime.std.sjw,
+			  card-&gt;bus[1]-&gt;can.bittime.std.prop_seg,
+			  card-&gt;bus[1]-&gt;can.bittime.std.phase_seg1,
+			  card-&gt;bus[1]-&gt;can.bittime.std.phase_seg2,
+			  card-&gt;bus[1]-&gt;can.bittime.std.sam);
+		/*init chip2 */
+		card-&gt;dpram.fct-&gt;param[1] = card-&gt;bus[1]-&gt;can.bittime.std.brp;
+		card-&gt;dpram.fct-&gt;param[2] = card-&gt;bus[1]-&gt;can.bittime.std.sjw;
+		card-&gt;dpram.fct-&gt;param[3] =
+			 card-&gt;bus[1]-&gt;can.bittime.std.phase_seg1 +
+			 card-&gt;bus[1]-&gt;can.bittime.std.prop_seg;
+		card-&gt;dpram.fct-&gt;param[4] =
+			 card-&gt;bus[1]-&gt;can.bittime.std.phase_seg2;
+		card-&gt;dpram.fct-&gt;param[5] = card-&gt;bus[1]-&gt;can.bittime.std.sam;
+		if (softing_fct_cmd(card, 2, 0, &quot;initialize_chip[1]&quot;))
+			goto failed;
+		/*set mode2 */
+		card-&gt;dpram.fct-&gt;param[1] = 0;
+		card-&gt;dpram.fct-&gt;param[2] = 0;
+		if (softing_fct_cmd(card, 4, 0, &quot;set_mode[1]&quot;))
+			goto failed;
+		/*set filter2 */
+		card-&gt;dpram.fct-&gt;param[1] = 0x0000;/*card-&gt;bus[1].s.msg; */
+		card-&gt;dpram.fct-&gt;param[2] = 0x07ff;/*card-&gt;bus[1].s.msk; */
+		card-&gt;dpram.fct-&gt;param[3] = 0x0000;/*card-&gt;bus[1].l.msg; */
+		card-&gt;dpram.fct-&gt;param[4] = 0xffff;/*card-&gt;bus[1].l.msk; */
+		card-&gt;dpram.fct-&gt;param[5] = 0x0000;/*card-&gt;bus[1].l.msg &gt;&gt; 16;*/
+		card-&gt;dpram.fct-&gt;param[6] = 0x1fff;/*card-&gt;bus[1].l.msk &gt;&gt; 16;*/
+		if (softing_fct_cmd(card, 8, 0, &quot;set_filter[1]&quot;))
+			goto failed;
+		/*set output control2 */
+		card-&gt;dpram.fct-&gt;param[1] = card-&gt;bus[1]-&gt;output;
+		if (softing_fct_cmd(card, 6, 0, &quot;set_output[1]&quot;))
+			goto failed;
+	}
+	/*set interrupt */
+	/*enable_error_frame */
+	if (softing_fct_cmd(card, 51, 0, &quot;enable_error_frame&quot;))
+		goto failed;
+	/*initialize interface */
+	card-&gt;dpram.fct-&gt;param[1] = 1;
+	card-&gt;dpram.fct-&gt;param[2] = 1;
+	card-&gt;dpram.fct-&gt;param[3] = 1;
+	card-&gt;dpram.fct-&gt;param[4] = 1;
+	card-&gt;dpram.fct-&gt;param[5] = 1;
+	card-&gt;dpram.fct-&gt;param[6] = 1;
+	card-&gt;dpram.fct-&gt;param[7] = 1;
+	card-&gt;dpram.fct-&gt;param[8] = 1;
+	card-&gt;dpram.fct-&gt;param[9] = 1;
+	card-&gt;dpram.fct-&gt;param[10] = 1;
+	if (softing_fct_cmd(card, 17, 0, &quot;initialize_interface&quot;))
+		goto failed;
+	/*enable_fifo */
+	if (softing_fct_cmd(card, 36, 0, &quot;enable_fifo&quot;))
+		goto failed;
+	/*enable fifo tx ack */
+	if (softing_fct_cmd(card, 13, 0, &quot;fifo_tx_ack[0]&quot;))
+		goto failed;
+	/*enable fifo tx ack2 */
+	if (softing_fct_cmd(card, 14, 0, &quot;fifo_tx_ack[1]&quot;))
+		goto failed;
+	/*enable timestamps */
+	/*is default, no code found */
+	/*start_chip */
+	if (softing_fct_cmd(card, 11, 0, &quot;start_chip&quot;))
+		goto failed;
+	card-&gt;dpram.info-&gt;bus_state = 0;
+	card-&gt;dpram.info-&gt;bus_state2 = 0;
+	mod_info(&quot;ok for %s, %s/%s\n&quot;, card-&gt;bus[0]-&gt;netdev-&gt;name,
+		 card-&gt;bus[1]-&gt;netdev-&gt;name, card-&gt;id.name);
+	if (!card-&gt;irq.shared) {
+		card-&gt;dpram.irq-&gt;to_host = 0;
+		/* flush the DPRAM caches */
+		wmb();
+	}
+	/*run once */
+	/*the bottom halve will start flushing the tx-queue too */
+	tasklet_schedule(&amp;card-&gt;irq.bh);
+
+	ret = softing_card_irq(card, 1);
+	if (ret)
+		goto failed;
+
+	/*TODO: generate RESTARTED messages */
+
+	if (card-&gt;bus[0] &amp;&amp; bus0) {
+		card-&gt;bus[0]-&gt;can.state = CAN_STATE_ACTIVE;
+		netif_carrier_on(card-&gt;bus[0]-&gt;netdev);
+	}
+	if (card-&gt;bus[1] &amp;&amp; bus1) {
+		card-&gt;bus[1]-&gt;can.state = CAN_STATE_ACTIVE;
+		netif_carrier_on(card-&gt;bus[1]-&gt;netdev);
+	}
+	return 0;
+failed:
+	softing_card_irq(card, 0);
+	softing_reset_chip(card);
+	if (card-&gt;bus[0])
+		netif_carrier_off(card-&gt;bus[0]-&gt;netdev);
+	if (card-&gt;bus[1])
+		netif_carrier_off(card-&gt;bus[1]-&gt;netdev);
+	return -EIO;
+}
+
+
+int softing_default_output(struct softing *card, struct softing_priv *priv)
+{
+	switch (priv-&gt;chip) {
+	case 1000:
+		if (card-&gt;desc-&gt;generation &lt; 2)
+			return 0xfb;
+		return 0xfa;
+	case 5:
+		return 0x60;
+	default:
+		return 0x40;
+	}
+}
+
+u32 softing_time2usec(struct softing *card, u32 raw)
+{
+	/*TODO : don't loose higher order bits in computation */
+	switch (card-&gt;desc-&gt;freq) {
+	case 20:
+		return raw * 4 / 5;
+	case 24:
+		return raw * 2 / 3;
+	case 25:
+		return raw * 16 / 25;
+	case 0:
+	case 16:
+	default:
+		return raw;
+	}
+}
+
+

Added: trunk/kernel/2.6/drivers/net/can/softing/softing_main.c
===================================================================
--- trunk/kernel/2.6/drivers/net/can/softing/softing_main.c	2008-07-01 09:16:34 UTC (rev 802)
+++ trunk/kernel/2.6/drivers/net/can/softing/softing_main.c	2008-07-01 10:09:12 UTC (rev 803)
@@ -0,0 +1,1088 @@
+/*
+* drivers/net/can/softing/softing_main.c
+*
+* Copyright (C) 2008
+*
+* - Kurt Van Dijck, EIA Electronics
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the version 2 of the GNU General Public License
+* as published by the Free Software Foundation
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/device.h&gt;
+#include &lt;linux/firmware.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;linux/io.h&gt;
+
+#include &quot;softing.h&quot;
+
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 25)
+	/* clear statistics */
+#define strict_strtoul simple_strtoul
+#endif
+/* this is the worst thing on the softing API
+ * 2 busses are driven together, I don't know how
+ * to recover a single of them.
+ * Therefore, when one bus is modified, the other
+ * is flushed too
+ */
+void softing_flush_echo_skb(struct softing_priv *priv)
+{
+	can_close_cleanup(priv-&gt;netdev);
+	priv-&gt;tx.pending = 0;
+	priv-&gt;tx.echo_put = 0;
+	priv-&gt;tx.echo_get = 0;
+}
+
+/*softing_unlocked_tx_run:*/
+/*trigger the tx queue-ing*/
+/*no locks are grabbed, so be sure to have the spin spinlock*/
+static int netdev_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct softing_priv *priv = (struct softing_priv *)dev-&gt;priv;
+	struct softing *card = priv-&gt;card;
+	int ret;
+	int bhlock;
+	u8 *ptr;
+	u8 cmd;
+	unsigned int fifo_wr;
+	struct can_frame msg;
+
+	ret = -ENOTTY;
+	if (in_interrupt()) {
+		bhlock = 0;
+		spin_lock(&amp;card-&gt;spin);
+	} else {
+		bhlock = 1;
+		spin_lock_bh(&amp;card-&gt;spin);
+	}
+	if (!card-&gt;fw.up) {
+		ret = -EIO;
+		goto xmit_done;
+	}
+	if (netif_carrier_ok(priv-&gt;netdev) &lt;= 0) {
+		ret = -EBADF;
+		goto xmit_done;
+	}
+	if (card-&gt;tx.pending &gt;= TXMAX) {
+		ret = -EBUSY;
+		goto xmit_done;
+	}
+	if (priv-&gt;tx.pending &gt;= CAN_ECHO_SKB_MAX) {
+		ret = -EBUSY;
+		goto xmit_done;
+	}
+	fifo_wr = card-&gt;dpram.tx-&gt;wr;
+	if (fifo_wr == card-&gt;dpram.tx-&gt;rd) {
+		/*fifo full */
+		ret = -EAGAIN;
+		goto xmit_done;
+	}
+	memcpy(&amp;msg, skb-&gt;data, sizeof(msg));
+	ptr = &amp;card-&gt;dpram.tx-&gt;fifo[fifo_wr][0];
+	cmd = CMD_TX;
+	if (msg.can_id &amp; CAN_RTR_FLAG)
+		cmd |= CMD_RTR;
+	if (msg.can_id &amp; CAN_EFF_FLAG)
+		cmd |= CMD_XTD;
+	if (priv-&gt;index)
+		cmd |= CMD_BUS2;
+	*ptr++ = cmd;
+	*ptr++ = msg.can_dlc;
+	*ptr++ = (msg.can_id &gt;&gt; 0);
+	*ptr++ = (msg.can_id &gt;&gt; 8);
+	if (msg.can_id &amp; CAN_EFF_FLAG) {
+		*ptr++ = (msg.can_id &gt;&gt; 16);
+		*ptr++ = (msg.can_id &gt;&gt; 24);
+	} else {
+		/*increment 1, not 2 as you might think */
+		ptr += 1;
+	}
+	if (!(msg.can_id &amp; CAN_RTR_FLAG))
+		memcpy_toio(ptr, &amp;msg.data[0], msg.can_dlc);
+	if (++fifo_wr &gt;=
+		 sizeof(card-&gt;dpram.tx-&gt;fifo) /
+		 sizeof(card-&gt;dpram.tx-&gt;fifo[0]))
+		fifo_wr = 0;
+	card-&gt;dpram.tx-&gt;wr = fifo_wr;
+	ret = 0;
+	++card-&gt;tx.pending;
+	++priv-&gt;tx.pending;
+	can_put_echo_skb(skb, dev, priv-&gt;tx.echo_put);
+	++priv-&gt;tx.echo_put;
+	if (priv-&gt;tx.echo_put &gt;= CAN_ECHO_SKB_MAX)
+		priv-&gt;tx.echo_put = 0;
+	/* clear pointer, so don't erase later */
+	skb = 0;
+xmit_done:
+	if (bhlock)
+		spin_unlock_bh(&amp;card-&gt;spin);
+	else
+		spin_unlock(&amp;card-&gt;spin);
+	if (card-&gt;tx.pending &gt;= TXMAX) {
+		struct softing_priv *bus;
+		int j;
+		for (j = 0; j &lt; card-&gt;nbus; ++j) {
+			bus = card-&gt;bus[j];
+			if (!bus)
+				continue;
+			netif_stop_queue(bus-&gt;netdev);
+		}
+	}
+
+	/* free skb, if not handled by the driver */
+	if (skb)
+		dev_kfree_skb(skb);
+	return ret;
+}
+
+static int softing_dev_svc_once(struct softing *card)
+{
+	int j;
+	struct softing_priv *bus;
+	struct sk_buff *skb;
+	struct can_frame msg;
+
+	unsigned int fifo_rd;
+	unsigned int cnt = 0;
+	struct net_device_stats *stats;
+
+	memset(&amp;msg, 0, sizeof(msg));
+	if (card-&gt;dpram.rx-&gt;lost_msg) {
+		/*reset condition */
+		card-&gt;dpram.rx-&gt;lost_msg = 0;
+		/* prepare msg */
+		msg.can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;
+		msg.can_dlc = CAN_ERR_DLC;
+		msg.data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+		/*service to both busses, we don't know which one generated */
+		for (j = 0; j &lt; card-&gt;nbus; ++j) {
+			bus = card-&gt;bus[j];
+			if (!bus)
+				continue;
+			if (!netif_carrier_ok(bus-&gt;netdev))
+				continue;
+			++bus-&gt;can.can_stats.data_overrun;
+			skb = dev_alloc_skb(sizeof(msg));
+			if (!skb)
+				return -ENOMEM;
+			skb-&gt;dev = bus-&gt;netdev;
+			skb-&gt;protocol = htons(ETH_P_CAN);
+			skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
+			memcpy(skb_put(skb, sizeof(msg)), &amp;msg, sizeof(msg));
+			if (netif_rx(skb))
+				dev_kfree_skb_irq(skb);
+		}
+		memset(&amp;msg, 0, sizeof(msg));
+		++cnt;
+	}
+
+	fifo_rd = card-&gt;dpram.rx-&gt;rd;
+	if (++fifo_rd &gt;=
+		 sizeof(card-&gt;dpram.rx-&gt;fifo) / sizeof(card-&gt;dpram.rx-&gt;fifo[0]))
+		fifo_rd = 0;
+	if (card-&gt;dpram.rx-&gt;wr != fifo_rd) {
+		u8 *ptr;
+		u32 tmp;
+		u8 cmd;
+		int do_skb;
+
+		ptr = &amp;card-&gt;dpram.rx-&gt;fifo[fifo_rd][0];
+
+		cmd = *ptr++;
+		if (cmd == 0xff) {
+			/*not quite usefull, probably the card has got out */
+			mod_alert(&quot;got cmd 0x%02x, I suspect the card is lost&quot;
+				, cmd);
+		}
+		/*mod_trace(&quot;0x%02x&quot;, cmd);*/
+		bus = card-&gt;bus[0];
+		if (cmd &amp; CMD_BUS2)
+			bus = card-&gt;bus[1];
+
+		stats = bus-&gt;netdev-&gt;get_stats(bus-&gt;netdev);
+		if (cmd &amp; CMD_ERR) {
+			u8 can_state;
+			u8 state;
+			state = *ptr++;
+
+			msg.can_id = CAN_ERR_FLAG;
+			msg.can_dlc = CAN_ERR_DLC;
+
+			if (state &amp; 0x80) {
+				can_state = CAN_STATE_BUS_OFF;
+				msg.can_id |= CAN_ERR_BUSOFF;
+				state = 2;
+			} else if (state &amp; 0x60) {
+				can_state = CAN_STATE_BUS_PASSIVE;
+				msg.can_id |= CAN_ERR_BUSERROR;
+				state = 1;
+			} else {
+				can_state = CAN_STATE_ACTIVE;
+				state = 0;
+				do_skb = 0;
+			}
+			/*update DPRAM */
+			if (!bus-&gt;index)
+				card-&gt;dpram.info-&gt;bus_state = state;
+			else
+				card-&gt;dpram.info-&gt;bus_state2 = state;
+			/*timestamp */
+			tmp =	 (ptr[0] &lt;&lt;  0)
+				|(ptr[1] &lt;&lt;  8)
+				|(ptr[2] &lt;&lt; 16)
+				|(ptr[3] &lt;&lt; 24);
+			ptr += 4;
+			/*msg.time = */ softing_time2usec(card, tmp);
+			/*trigger dual port RAM */
+			mb();
+			card-&gt;dpram.rx-&gt;rd = fifo_rd;
+			/*update internal status */
+			if (can_state != bus-&gt;can.state) {
+				bus-&gt;can.state = can_state;
+				if (can_state == 1)
+					bus-&gt;can.can_stats.error_passive += 1;
+			}
+			bus-&gt;can.can_stats.bus_error += 1;
+
+			/*trigger socketcan */
+			if (state == 2) {
+				/* this calls can_close_cleanup() */
+				softing_flush_echo_skb(bus);
+				can_bus_off(bus-&gt;netdev);
+				netif_stop_queue(bus-&gt;netdev);
+			}
+			if ((state == CAN_STATE_BUS_OFF)
+				 || (state == CAN_STATE_BUS_PASSIVE)) {
+				skb = dev_alloc_skb(sizeof(msg));
+				if (!skb)
+					return -ENOMEM;
+				skb-&gt;dev = bus-&gt;netdev;
+				skb-&gt;protocol = htons(ETH_P_CAN);
+				skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
+				memcpy(skb_put(skb, sizeof(msg)), &amp;msg,
+						 sizeof(msg));
+				if (netif_rx(skb))
+					dev_kfree_skb_irq(skb);
+			}
+		} else {
+			if (cmd &amp; CMD_RTR)
+				msg.can_id |= CAN_RTR_FLAG;
+			/* acknowledge, was tx msg
+			 * no real tx flag to set
+			if (cmd &amp; CMD_ACK) {
+			}
+			 */
+			msg.can_dlc = *ptr++;
+			if (msg.can_dlc &gt; 8)
+				msg.can_dlc = 8;
+			if (cmd &amp; CMD_XTD) {
+				msg.can_id |= CAN_EFF_FLAG;
+				msg.can_id |=
+						(ptr[0] &lt;&lt; 0)
+					 | (ptr[1] &lt;&lt; 8)
+					 | (ptr[2] &lt;&lt; 16)
+					 | (ptr[3] &lt;&lt; 24);
+				ptr += 4;
+			} else {
+				msg.can_id |= (ptr[0] &lt;&lt; 0) | (ptr[1] &lt;&lt; 8);
+				ptr += 2;
+			}
+			tmp = (ptr[0] &lt;&lt; 0)
+				 | (ptr[1] &lt;&lt; 8)
+				 | (ptr[2] &lt;&lt; 16)
+				 | (ptr[3] &lt;&lt; 24);
+			ptr += 4;
+			/*msg.time = */ softing_time2usec(card, tmp);
+			memcpy_fromio(&amp;msg.data[0], ptr, 8);
+			ptr += 8;
+			/*trigger dual port RAM */
+			mb();
+			card-&gt;dpram.rx-&gt;rd = fifo_rd;
+			/*update socket */
+			if (cmd &amp; CMD_ACK) {
+				can_get_echo_skb(bus-&gt;netdev, bus-&gt;tx.echo_get);
+				++bus-&gt;tx.echo_get;
+				if (bus-&gt;tx.echo_get &gt;= CAN_ECHO_SKB_MAX)
+					bus-&gt;tx.echo_get = 0;
+				if (bus-&gt;tx.pending)
+					--bus-&gt;tx.pending;
+				if (card-&gt;tx.pending)
+					--card-&gt;tx.pending;
+				stats-&gt;tx_packets += 1;
+				stats-&gt;tx_bytes += msg.can_dlc;
+			} else {
+				stats-&gt;rx_packets += 1;
+				stats-&gt;rx_bytes += msg.can_dlc;
+				bus-&gt;netdev-&gt;last_rx = jiffies;
+				skb = dev_alloc_skb(sizeof(msg));
+				if (skb) {
+					skb-&gt;dev = bus-&gt;netdev;
+					skb-&gt;protocol = htons(ETH_P_CAN);
+					skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
+					memcpy(skb_put(skb, sizeof(msg)), &amp;msg,
+							 sizeof(msg));
+					if (netif_rx(skb))
+						dev_kfree_skb_irq(skb);
+				}
+			}
+		}
+		++cnt;
+	}
+	return cnt;
+}
+
+static void softing_dev_svc(unsigned long param)
+{
+	struct softing *card = (struct softing *)param;
+	struct softing_priv *bus;
+	int j;
+	int offset;
+
+	spin_lock(&amp;card-&gt;spin);
+	while (softing_dev_svc_once(card) &gt; 0)
+		++card-&gt;irq.svc_count;
+	/*resume tx queue's */
+	offset = card-&gt;tx.last_bus;
+	for (j = 0; j &lt; card-&gt;nbus; ++j) {
+		if (card-&gt;tx.pending &gt;= TXMAX)
+			break;
+		bus = card-&gt;bus[(j + offset) % card-&gt;nbus];
+		if (netif_carrier_ok(bus-&gt;netdev))
+			netif_wake_queue(bus-&gt;netdev);
+	}
+	spin_unlock(&amp;card-&gt;spin);
+}
+
+static void card_seems_down(struct softing *card)
+{
+	/* free interrupt, but probably
+	 * in wrong (interrupt) context
+	if (card-&gt;irq.requested) {
+		free_irq(card-&gt;irq.nr, card);
+		card-&gt;irq.requested = 0;
+		card-&gt;fw.up = 0;
+	}
+	*/
+	mod_alert(&quot;I think the card is vanished&quot;);
+}
+
+static
+irqreturn_t dev_interrupt_shared(int irq, void *dev_id)
+{
+	struct softing *card = (struct softing *)dev_id;
+	unsigned char ir;
+	ir = card-&gt;dpram.virt[0xe02];
+	card-&gt;dpram.virt[0xe02] = 0;
+	if (card-&gt;dpram.rx-&gt;rd == 0xffff) {
+		card_seems_down(card);
+		return IRQ_NONE;
+	}
+	if (ir == 1) {
+		tasklet_schedule(&amp;card-&gt;irq.bh);
+		return IRQ_HANDLED;
+	} else if (ir == 0x10) {
+		return IRQ_NONE;
+	} else {
+		return IRQ_NONE;
+	}
+}
+
+static
+irqreturn_t dev_interrupt_nshared(int irq, void *dev_id)
+{
+	struct softing *card = (struct softing *)dev_id;
+	unsigned char irq_host;
+	irq_host = card-&gt;dpram.irq-&gt;to_host;
+	/* make sure we have a copy, before clearing the variable in DPRAM */
+	rmb();
+	card-&gt;dpram.irq-&gt;to_host = 0;
+	/* make sure we cleared it */
+	wmb();
+	mod_trace(&quot;0x%02x&quot;, irq_host);
+	if (card-&gt;dpram.rx-&gt;rd == 0xffff) {
+		card_seems_down(card);
+		return IRQ_NONE;
+	}
+	tasklet_schedule(&amp;card-&gt;irq.bh);
+	return IRQ_HANDLED;
+}
+
+static int netdev_open(struct net_device *ndev)
+{
+	struct softing_priv *priv = netdev_priv(ndev);
+	struct softing *card = priv-&gt;card;
+	int fw;
+	mod_trace(&quot;%s&quot;, ndev-&gt;name);
+	if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
+		return -ERESTARTSYS;
+	fw = card-&gt;fw.up;
+	if (fw)
+		softing_reinit(card
+			, (card-&gt;bus[0] == priv) ? 1 : -1
+			, (card-&gt;bus[1] == priv) ? 1 : -1);
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	if (!fw)
+		return -EIO;
+	netif_start_queue(ndev);
+	return 0;
+}
+
+static int netdev_stop(struct net_device *ndev)
+{
+	struct softing_priv *priv = netdev_priv(ndev);
+	struct softing *card = priv-&gt;card;
+	int fw;
+
+	mod_trace(&quot;%s&quot;, ndev-&gt;name);
+	netif_stop_queue(ndev);
+	netif_carrier_off(ndev);
+	softing_flush_echo_skb(priv);
+	can_close_cleanup(ndev);
+	if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
+		return -ERESTARTSYS;
+	fw = card-&gt;fw.up;
+	if (fw)
+		softing_reinit(card
+			, (card-&gt;bus[0] == priv) ? 0 : -1
+			, (card-&gt;bus[1] == priv) ? 0 : -1);
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	if (!fw)
+		return -EIO;
+	return 0;
+}
+
+#define out_of_range(x, min, max) (((x) &lt; min) || ((x) &gt; max))
+
+static int candev_set_bittime(struct net_device *ndev, struct can_bittime *bt)
+{
+	switch (bt-&gt;type) {
+	case CAN_BITTIME_STD:
+		/*SJW is test via max_sjw */
+		if (out_of_range(bt-&gt;std.sjw, 1, 4))
+			return -EIO;
+		if (out_of_range(bt-&gt;std.phase_seg1 + bt-&gt;std.prop_seg, 1, 16))
+			return -EIO;
+		if (out_of_range(bt-&gt;std.phase_seg2, 1, 8))
+			return -EIO;
+		/*BRP is test via max_brp */
+		if (ndev-&gt;flags &amp; IFF_UP)
+			return -EBUSY;
+		break;
+	case CAN_BITTIME_BTR:
+	default:
+		mod_alert(&quot;%s, type %i not supported&quot;, ndev-&gt;name, bt-&gt;type);
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+static int candev_get_state(struct net_device *ndev, enum can_state *state)
+{
+	struct softing_priv *priv = netdev_priv(ndev);
+	mod_trace(&quot;%s&quot;, ndev-&gt;name);
+	if (priv-&gt;netdev-&gt;flags &amp; IFF_UP)
+		*state = CAN_STATE_STOPPED;
+	else if (priv-&gt;can.state == CAN_STATE_STOPPED)
+		*state = CAN_STATE_STOPPED;
+	else
+		*state = CAN_STATE_ACTIVE;
+	return 0;
+}
+
+static int candev_set_mode(struct net_device *ndev, enum can_mode mode)
+{
+	struct softing_priv *priv = netdev_priv(ndev);
+	struct softing *card = priv-&gt;card;
+	mod_trace(&quot;%s %u&quot;, ndev-&gt;name, mode);
+	switch (mode) {
+	case CAN_MODE_START:
+		/*recovery from busoff? */
+		if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
+			return -ERESTARTSYS;
+		softing_reinit(card, -1, -1);
+		mutex_unlock(&amp;card-&gt;fw.lock);
+		break;
+	case CAN_MODE_STOP:
+	case CAN_MODE_SLEEP:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+/*assume the card-&gt;lock is held*/
+
+int softing_card_irq(struct softing *card, int enable)
+{
+	int ret;
+	if (!enable) {
+		if (card-&gt;irq.requested &amp;&amp; card-&gt;irq.nr) {
+			free_irq(card-&gt;irq.nr, card);
+			card-&gt;irq.requested = 0;
+		}
+		return 0;
+	}
+	if (!card-&gt;irq.requested &amp;&amp; (card-&gt;irq.nr)) {
+		irqreturn_t(*fn) (int, void *);
+		unsigned int flags;
+		flags = IRQF_DISABLED;	/*| IRQF_TRIGGER_LOW; */
+		fn = dev_interrupt_nshared;
+		if (card-&gt;irq.shared) {
+			flags |= IRQF_SHARED;
+			fn = dev_interrupt_shared;
+		}
+		ret = request_irq(card-&gt;irq.nr, fn, flags, card-&gt;id.name, card);
+		if (ret) {
+			mod_alert(&quot;%s, request_irq(%u) failed, %s shared&quot;
+				, card-&gt;id.name, card-&gt;irq.nr
+				, (card-&gt;irq.shared ? &quot;&quot; : &quot;not&quot;)
+				);
+			return ret;
+		}
+		card-&gt;irq.requested = 1;
+	}
+	return 0;
+}
+
+static void shutdown_card(struct softing *card)
+{
+	int fw_up = 0;
+	mod_trace(&quot;%s&quot;, card-&gt;id.name);
+	if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
+		/* return -ERESTARTSYS*/;
+	fw_up = card-&gt;fw.up;
+	card-&gt;fw.up = 0;
+
+	if (card-&gt;irq.requested &amp;&amp; card-&gt;irq.nr) {
+		free_irq(card-&gt;irq.nr, card);
+		card-&gt;irq.requested = 0;
+	}
+	if (fw_up) {
+		if (card-&gt;fn.enable_irq)
+			card-&gt;fn.enable_irq(card, 0);
+		if (card-&gt;fn.reset)
+			card-&gt;fn.reset(card, 1);
+	}
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	tasklet_kill(&amp;card-&gt;irq.bh);
+}
+
+static int boot_card(struct softing *card)
+{
+	mod_trace(&quot;%s&quot;, card-&gt;id.name);
+	if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
+		return -ERESTARTSYS;
+	if (card-&gt;fw.up) {
+		mutex_unlock(&amp;card-&gt;fw.lock);
+		return 0;
+	}
+	/*reset board */
+
+	if (card-&gt;fn.enable_irq)
+		card-&gt;fn.enable_irq(card, 1);
+	/*boot card */
+	if (card-&gt;fn.reset)
+		card-&gt;fn.reset(card, 1);
+	/*test dp ram */
+	if (card-&gt;dpram.virt) {
+		unsigned char *lp;
+		static const unsigned char stream[]
+		= { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, };
+		unsigned char back[sizeof(stream)];
+		for (lp = card-&gt;dpram.virt;
+			  &amp;lp[sizeof(stream)] &lt;= card-&gt;dpram.end;
+			  lp += sizeof(stream)) {
+			memcpy_toio(lp, stream, sizeof(stream));
+			/* flush IO cache */
+			mb();
+			memcpy_fromio(back, lp, sizeof(stream));
+
+			if (memcmp(back, stream, sizeof(stream))) {
+				char line[3 * sizeof(stream)
+					/ sizeof(stream[0]) + 1];
+				char *pline = line;
+				unsigned char *addr = lp;
+				for (lp = back; lp &lt; &amp;back[sizeof(stream)
+						/ sizeof(stream[0])]; ++lp)
+					pline += sprintf(pline, &quot; %02x&quot;, *lp);
+
+				mod_alert(&quot;write to dpram failed at 0x%p, %s&quot;
+					, addr, line);
+				goto open_failed;
+			}
+		}
+		/*fill dpram with 0x55 */
+		/*for (lp = card-&gt;dpram.virt; lp &lt;= card-&gt;dpram.end; ++lp) {
+		 *lp = 0x55;
+		 }*/
+		wmb();
+	} else {
+		goto open_failed;
+	}
+	/*load boot firmware */
+	if (softing_load_fw(card-&gt;desc-&gt;boot.fw, card, card-&gt;dpram.virt,
+				 card-&gt;dpram.size,
+				 card-&gt;desc-&gt;boot.offs -
+				 card-&gt;desc-&gt;boot.addr))
+		goto open_failed;
+	/*load load firmware */
+	if (softing_load_fw(card-&gt;desc-&gt;load.fw, card, card-&gt;dpram.virt,
+				 card-&gt;dpram.size,
+				 card-&gt;desc-&gt;load.offs -
+				 card-&gt;desc-&gt;load.addr))
+		goto open_failed;
+
+	if (card-&gt;fn.reset)
+		card-&gt;fn.reset(card, 0);
+	if (softing_bootloader_command(card, 0, &quot;card boot&quot;))
+		goto open_failed;
+	if (softing_load_app_fw(card-&gt;desc-&gt;app.fw, card))
+		goto open_failed;
+	/*reset chip */
+	card-&gt;dpram.info-&gt;reset_rcv_fifo = 0;
+	card-&gt;dpram.info-&gt;reset = 1;
+	/*sync */
+	if (softing_fct_cmd(card, 99, 0x55, &quot;sync-a&quot;))
+		goto open_failed;
+	if (softing_fct_cmd(card, 99, 0xaa, &quot;sync-a&quot;))
+		goto open_failed;
+	/*reset chip */
+	if (softing_fct_cmd(card, 0, 0, &quot;reset_chip&quot;))
+		goto open_failed;
+	/*get_serial */
+	if (softing_fct_cmd(card, 43, 0, &quot;get_serial_number&quot;))
+		goto open_failed;
+	card-&gt;id.serial =
+		 (u16) card-&gt;dpram.fct-&gt;param[1] +
+		 (((u16) card-&gt;dpram.fct-&gt;param[2]) &lt;&lt; 16);
+	/*get_version */
+	if (softing_fct_cmd(card, 12, 0, &quot;get_version&quot;))
+		goto open_failed;
+	card-&gt;id.fw = (u16) card-&gt;dpram.fct-&gt;param[1];
+	card-&gt;id.hw = (u16) card-&gt;dpram.fct-&gt;param[2];
+	card-&gt;id.lic = (u16) card-&gt;dpram.fct-&gt;param[3];
+	card-&gt;id.chip[0] = (u16) card-&gt;dpram.fct-&gt;param[4];
+	card-&gt;id.chip[1] = (u16) card-&gt;dpram.fct-&gt;param[5];
+
+	mod_info(&quot;%s, card booted, &quot;
+			&quot;serial %u, fw %u, hw %u, lic %u, chip (%u,%u)&quot;,
+		  card-&gt;id.name, card-&gt;id.serial, card-&gt;id.fw, card-&gt;id.hw,
+		  card-&gt;id.lic, card-&gt;id.chip[0], card-&gt;id.chip[1]);
+
+	card-&gt;fw.up = 1;
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	return 0;
+open_failed:
+	card-&gt;fw.up = 0;
+	if (card-&gt;fn.enable_irq)
+		card-&gt;fn.enable_irq(card, 0);
+	if (card-&gt;fn.reset)
+		card-&gt;fn.reset(card, 1);
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	return EINVAL;
+}
+
+/*sysfs stuff*/
+
+/* Because the struct softing may be used by pcmcia devices
+ * as well as pci devices, * we have no clue how to get
+ * from a struct device * towards the struct softing *.
+ * It may go over a pci_device-&gt;priv or over a pcmcia_device-&gt;priv.
+ * Therefore, provide the struct softing pointer within the attribute.
+ * Then we don't need driver/bus specific things in these attributes
+ */
+struct softing_attribute {
+	struct device_attribute dev;
+	ssize_t (*show) (struct softing *card, char *buf);
+	ssize_t (*store)(struct softing *card, const char *buf, size_t count);
+	struct softing *card;
+};
+
+static ssize_t rd_card_attr(struct device *dev, struct device_attribute *attr
+		, char *buf) {
+	struct softing_attribute *cattr
+		= container_of(attr, struct softing_attribute, dev);
+	return cattr-&gt;show ? cattr-&gt;show(cattr-&gt;card, buf) : 0;
+}
+static ssize_t wr_card_attr(struct device *dev, struct device_attribute *attr
+		, const char *buf, size_t count) {
+	struct softing_attribute *cattr
+		= container_of(attr, struct softing_attribute, dev);
+	return cattr-&gt;store ? cattr-&gt;store(cattr-&gt;card, buf, count) : 0;
+}
+
+#define declare_attr(_name, _mode, _show, _store) { \
+	.dev = { \
+		.attr = { \
+			.name = __stringify(_name), \
+			.mode = _mode, \
+		}, \
+		.show = rd_card_attr, \
+		.store = wr_card_attr, \
+	}, \
+	.show =	_show, \
+	.store = _store, \
+}
+
+#define CARD_SHOW(name, member) \
+static ssize_t show_##name(struct softing *card, char *buf) { \
+	return sprintf(buf, &quot;%u\n&quot;, card-&gt;member); \
+}
+CARD_SHOW(serial	, id.serial);
+CARD_SHOW(firmware	, id.fw);
+CARD_SHOW(hardware	, id.hw);
+CARD_SHOW(license	, id.lic);
+CARD_SHOW(freq		, id.freq);
+CARD_SHOW(txpending	, tx.pending);
+
+static const struct softing_attribute card_attr_proto [] = {
+	declare_attr(serial	, 0644, show_serial	, 0),
+	declare_attr(firmware	, 0644, show_firmware	, 0),
+	declare_attr(hardware	, 0644, show_hardware	, 0),
+	declare_attr(license	, 0644, show_license	, 0),
+	declare_attr(freq	, 0644, show_freq	, 0),
+	declare_attr(txpending	, 0644, show_txpending	, 0),
+};
+
+static int mk_card_sysfs(struct softing *card)
+{
+	int size;
+	int j;
+
+	size = sizeof(card_attr_proto)/sizeof(card_attr_proto[0]);
+	card-&gt;attr = kmalloc((size+1)*sizeof(card-&gt;attr[0]), GFP_KERNEL);
+	if (!card-&gt;attr)
+		goto attr_mem_failed;
+	memcpy(card-&gt;attr, card_attr_proto, size * sizeof(card-&gt;attr[0]));
+	memset(&amp;card-&gt;attr[size], 0, sizeof(card-&gt;attr[0]));
+
+	card-&gt;grp  = kmalloc((size+1)*sizeof(card-&gt;grp [0]), GFP_KERNEL);
+	if (!card-&gt;grp)
+		goto grp_mem_failed;
+
+	for (j = 0; j &lt; size; ++j) {
+		card-&gt;attr[j].card = card;
+		card-&gt;grp[j] = &amp;card-&gt;attr[j].dev.attr;
+		if (!card-&gt;attr[j].show)
+			card-&gt;attr[j].dev.attr.mode &amp;= ~(S_IRUGO);
+		if (!card-&gt;attr[j].store)
+			card-&gt;attr[j].dev.attr.mode &amp;= ~(S_IWUGO);
+	}
+	card-&gt;grp[size] = 0;
+	card-&gt;sysfs.name	= &quot;softing&quot;;
+	card-&gt;sysfs.attrs = card-&gt;grp;
+	if (sysfs_create_group(&amp;card-&gt;dev-&gt;kobj, &amp;card-&gt;sysfs) &lt; 0)
+		goto sysfs_failed;
+
+	return 0;
+
+sysfs_failed:
+	kfree(card-&gt;grp);
+grp_mem_failed:
+	kfree(card-&gt;attr);
+attr_mem_failed:
+	return -1;
+}
+static void rm_card_sysfs(struct softing *card)
+{
+	sysfs_remove_group(&amp;card-&gt;dev-&gt;kobj, &amp;card-&gt;sysfs);
+	kfree(card-&gt;grp);
+	kfree(card-&gt;attr);
+}
+
+static ssize_t show_chip(struct device *dev
+		, struct device_attribute *attr, char *buf)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+	return sprintf(buf, &quot;%i\n&quot;, priv-&gt;chip);
+}
+
+static ssize_t show_output(struct device *dev
+		, struct device_attribute *attr, char *buf)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+	return sprintf(buf, &quot;0x%02x\n&quot;, priv-&gt;output);
+}
+
+static ssize_t store_output(struct device *dev
+		, struct device_attribute *attr
+		, const char *buf, size_t count)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+	struct softing *card = priv-&gt;card;
+
+	int v = strict_strtol(buf, 0, 0);
+
+	if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
+		return -ERESTARTSYS;
+	if (ndev-&gt;flags &amp; IFF_UP) {
+		int j;
+		/* we will need a restart */
+		for (j = 0; j &lt; card-&gt;nbus; ++j) {
+			if (j == priv-&gt;index)
+				/* me, myself &amp; I */
+				continue;
+			if (card-&gt;bus[j]-&gt;netdev-&gt;flags &amp; IFF_UP) {
+				mutex_unlock(&amp;card-&gt;fw.lock);
+				return -EBUSY;
+			}
+		}
+		priv-&gt;output = v;
+		softing_reinit(card, -1, -1);
+	} else {
+		priv-&gt;output = v;
+	}
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	return count;
+}
+/* TODO
+ * the latest softing cards support sleep mode too
+ */
+
+static const DEVICE_ATTR(chip, S_IRUGO, show_chip, 0);
+static const DEVICE_ATTR(output, S_IRUGO | S_IWUSR, show_output, store_output);
+
+static const struct attribute *const netdev_sysfs_entries [] = {
+	&amp;dev_attr_chip		.attr,
+	&amp;dev_attr_output	.attr,
+	0,
+};
+static const struct attribute_group netdev_sysfs = {
+	.name  = 0,
+	.attrs = (struct attribute **)netdev_sysfs_entries,
+};
+
+static int mk_netdev_sysfs(struct softing_priv *priv)
+{
+	if (!priv-&gt;netdev-&gt;dev.kobj.sd) {
+		mod_alert(&quot;sysfs_create_group would fail&quot;);
+		return ENODEV;
+	}
+	return sysfs_create_group(&amp;priv-&gt;netdev-&gt;dev.kobj, &amp;netdev_sysfs);
+}
+static void rm_netdev_sysfs(struct softing_priv *priv)
+{
+	sysfs_remove_group(&amp;priv-&gt;netdev-&gt;dev.kobj, &amp;netdev_sysfs);
+}
+
+static struct softing_priv *mk_netdev(struct softing *card, u16 chip_id)
+{
+	struct net_device *ndev;
+	struct softing_priv *priv;
+
+	ndev = alloc_candev(sizeof(*priv));
+	if (!ndev) {
+		mod_alert(&quot;alloc_candev failed&quot;);
+		return 0;
+	}
+	priv = netdev_priv(ndev);
+	priv-&gt;netdev		= ndev;
+	priv-&gt;card		= card;
+	priv-&gt;can.can_sys_clock = 8000000UL;
+	priv-&gt;can.max_brp	= card-&gt;desc-&gt;max_brp;
+	priv-&gt;can.max_sjw	= card-&gt;desc-&gt;max_sjw;
+	priv-&gt;sample		= 1;
+	priv-&gt;chip		= chip_id;
+	priv-&gt;output = softing_default_output(card, priv);
+	SET_NETDEV_DEV(ndev, card-&gt;dev);
+
+	ndev-&gt;flags |= IFF_ECHO;
+	ndev-&gt;open		= netdev_open;
+	ndev-&gt;stop		= netdev_stop;
+	ndev-&gt;hard_start_xmit	= netdev_start_xmit;
+	priv-&gt;can.do_set_bittime = candev_set_bittime;
+	priv-&gt;can.do_get_state	= candev_get_state;
+	priv-&gt;can.do_set_mode	= candev_set_mode;
+
+	if (can_set_bitrate(ndev, 250000UL))
+		mod_alert(&quot;bitrate failed&quot;);
+
+	return priv;
+}
+
+static void rm_netdev(struct softing_priv *priv)
+{
+	free_candev(priv-&gt;netdev);
+}
+
+static int reg_netdev(struct softing_priv *priv)
+{
+	int ret;
+	netif_carrier_off(priv-&gt;netdev);
+	ret = register_netdev(priv-&gt;netdev);
+	if (ret) {
+		mod_alert(&quot;%s, register failed&quot;, priv-&gt;card-&gt;id.name);
+		goto reg_failed;
+	}
+	ret = mk_netdev_sysfs(priv);
+	if (ret) {
+		mod_alert(&quot;%s, sysfs failed&quot;, priv-&gt;card-&gt;id.name);
+		goto sysfs_failed;
+	}
+	return 0;
+sysfs_failed:
+	unregister_netdev(priv-&gt;netdev);
+reg_failed:
+	return EINVAL;
+}
+
+static void unreg_netdev(struct softing_priv *priv)
+{
+	rm_netdev_sysfs(priv);
+	unregister_netdev(priv-&gt;netdev);
+}
+
+void rm_softing(struct softing *card)
+{
+	int j;
+
+	/*first, disable card*/
+	shutdown_card(card);
+
+	for (j = 0; j &lt; card-&gt;nbus; ++j) {
+		unreg_netdev(card-&gt;bus[j]);
+		rm_netdev(card-&gt;bus[j]);
+	}
+
+	rm_card_sysfs(card);
+
+	iounmap(card-&gt;dpram.virt);
+}
+EXPORT_SYMBOL(rm_softing);
+
+int mk_softing(struct softing *card)
+{
+	int j;
+
+	/* try_module_get(THIS_MODULE); */
+	mutex_init(&amp;card-&gt;fw.lock);
+	spin_lock_init(&amp;card-&gt;spin);
+	tasklet_init(&amp;card-&gt;irq.bh, softing_dev_svc, (unsigned long)card);
+
+	card-&gt;desc = softing_lookup_desc(card-&gt;id.manf, card-&gt;id.prod);
+	if (!card-&gt;desc) {
+		mod_alert(&quot;0x%04x:0x%04x not supported\n&quot;, card-&gt;id.manf,
+			  card-&gt;id.prod);
+		goto lookup_failed;
+	}
+	card-&gt;id.name = card-&gt;desc-&gt;name;
+	mod_trace(&quot;can (%s)&quot;, card-&gt;id.name);
+
+	card-&gt;dpram.virt = ioremap(card-&gt;dpram.phys, card-&gt;dpram.size);
+	if (!card-&gt;dpram.virt) {
+		mod_alert(&quot;dpram ioremap failed\n&quot;);
+		goto ioremap_failed;
+	}
+
+	card-&gt;dpram.size = card-&gt;desc-&gt;dpram_size;
+	card-&gt;dpram.end = &amp;card-&gt;dpram.virt[card-&gt;dpram.size];
+	/*initialize_board */
+	card-&gt;dpram.rx = (struct softing_rx *)&amp;card-&gt;dpram.virt[0x0000];
+	card-&gt;dpram.tx = (struct softing_tx *)&amp;card-&gt;dpram.virt[0x0400];
+	card-&gt;dpram.fct = (struct softing_fct *)&amp;card-&gt;dpram.virt[0x0300];
+	card-&gt;dpram.info = (struct softing_info *)&amp;card-&gt;dpram.virt[0x0330];
+	card-&gt;dpram.command = (unsigned short *)&amp;card-&gt;dpram.virt[0x07e0];
+	card-&gt;dpram.receipt = (unsigned short *)&amp;card-&gt;dpram.virt[0x07f0];
+	card-&gt;dpram.irq = (struct softing_irq *)&amp;card-&gt;dpram.virt[0x07fe];
+
+	/*reset card */
+	if (card-&gt;fn.reset)
+		card-&gt;fn.reset(card, 1);
+	if (boot_card(card)) {
+		mod_alert(&quot;%s, failed to boot&quot;, card-&gt;id.name);
+		goto boot_failed;
+	}
+
+	/*only now, the chip's are known */
+	card-&gt;id.freq = card-&gt;desc-&gt;freq * 1000000UL;
+
+	if (mk_card_sysfs(card)) {
+		mod_alert(&quot;%s, sysfs failed&quot;, card-&gt;id.name);
+		goto sysfs_failed;
+	}
+
+	if (card-&gt;nbus &gt; (sizeof(card-&gt;bus) / sizeof(card-&gt;bus[0]))) {
+		card-&gt;nbus = sizeof(card-&gt;bus) / sizeof(card-&gt;bus[0]);
+		mod_alert(&quot;%s, going for %u busses&quot;, card-&gt;id.name, card-&gt;nbus);
+	}
+
+	for (j = 0; j &lt; card-&gt;nbus; ++j) {
+		card-&gt;bus[j] = mk_netdev(card, card-&gt;id.chip[j]);
+		if (!card-&gt;bus[j]) {
+			mod_alert(&quot;%s: failed to make can[%i]&quot;, card-&gt;id.name,
+				  j);
+			goto netdev_failed;
+		}
+		card-&gt;bus[j]-&gt;index = j;
+	}
+	for (j = 0; j &lt; card-&gt;nbus; ++j) {
+		if (reg_netdev(card-&gt;bus[j])) {
+			mod_alert(&quot;%s: failed to register can[%i]&quot;,
+				  card-&gt;id.name, j);
+			goto reg_failed;
+		}
+	}
+	mod_trace(&quot;card initialised&quot;);
+	return 0;
+
+reg_failed:
+	for (j = 0; j &lt; card-&gt;nbus; ++j)
+		unreg_netdev(card-&gt;bus[j]);
+netdev_failed:
+	for (j = 0; j &lt; card-&gt;nbus; ++j) {
+		if (card-&gt;bus[j])
+			rm_netdev(card-&gt;bus[j]);
+	}
+	rm_card_sysfs(card);
+sysfs_failed:
+	shutdown_card(card);
+boot_failed:
+	iounmap(card-&gt;dpram.virt);
+	card-&gt;dpram.virt = 0;
+	card-&gt;dpram.end = 0;
+ioremap_failed:
+lookup_failed:
+	tasklet_kill(&amp;card-&gt;irq.bh);
+	return EINVAL;
+}
+EXPORT_SYMBOL(mk_softing);
+
+static int __init mod_start(void)
+{
+	mod_trace(&quot;&quot;);
+	return 0;
+}
+
+static void __exit mod_stop(void)
+{
+	mod_trace(&quot;&quot;);
+}
+
+module_init(mod_start);
+module_exit(mod_stop);
+
+MODULE_DESCRIPTION(&quot;socketcan softing driver&quot;);
+MODULE_AUTHOR(&quot;Kurt Van Dijck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">kurt.van.dijck at eia.be</A>&gt;&quot;);
+MODULE_LICENSE(&quot;GPL&quot;);
+
+int softing_debug = 1;
+EXPORT_SYMBOL(softing_debug);
+module_param(softing_debug, int , S_IRUGO | S_IWUSR | S_IWGRP);
+MODULE_PARM_DESC(softing_debug, &quot;trace softing functions&quot;);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000782.html">r802 - trunk/kernel/2.6/net/can
</A></li>
	<LI>Next message: <A HREF="000784.html">r804 - trunk/can-utils
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#783">[ date ]</a>
              <a href="thread.html#783">[ thread ]</a>
              <a href="subject.html#783">[ subject ]</a>
              <a href="author.html#783">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-commit">More information about the Socketcan-commit
mailing list</a><br>
</body></html>
