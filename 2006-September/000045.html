<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> r65 - in branches/ut/hlist/kernel/2.6: include/linux/can net/ can
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-commit/2006-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r65%20-%20in%20branches/ut/hlist/kernel/2.6%3A%20include/linux/can%20net/%20can&In-Reply-To=%3C44F8135C.7090105%40volkswagen.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000044.html">
   <LINK REL="Next"  HREF="000046.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>r65 - in branches/ut/hlist/kernel/2.6: include/linux/can net/ can</H1>
    <B>Hartkopp, Oliver (K-GEFE/E)</B> 
    <A HREF="mailto:socketcan-commit%40lists.berlios.de?Subject=Re%3A%20r65%20-%20in%20branches/ut/hlist/kernel/2.6%3A%20include/linux/can%20net/%20can&In-Reply-To=%3C44F8135C.7090105%40volkswagen.de%3E"
       TITLE="r65 - in branches/ut/hlist/kernel/2.6: include/linux/can net/ can">oliver.hartkopp at volkswagen.de
       </A><BR>
    <I>Fri Sep  1 13:02:52 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000044.html">r65 - in branches/ut/hlist/kernel/2.6: include/linux/can net/can
</A></li>
        <LI>Next message: <A HREF="000046.html">r66 - in branches/ut/hlist/kernel/2.6: include/linux/can net/can
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45">[ date ]</a>
              <a href="thread.html#45">[ thread ]</a>
              <a href="subject.html#45">[ subject ]</a>
              <a href="author.html#45">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>@Urs (subject: performance problems in can_rx_unregister):
In my working copy i reverted the spin_locks to write_(un)lock_bh in
can_rx_(un)register as AFAIK kmalloc() is no good idea within spin_locks.
And kmalloc occurs typically in can_rx_register.

But this did not change the behavior. The problem seems to be in
synchronize_rcu() as it looks like the old behaviour when i comment this
out. Having load on the CAN-bus or not has no effect on this.

Regards,
Oliver

<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">hartkopp at mail.berlios.de</A> wrote:
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Author: hartkopp
</I>&gt;<i> Date: 2006-09-01 11:42:27 +0200 (Fri, 01 Sep 2006)
</I>&gt;<i> New Revision: 65
</I>&gt;<i> 
</I>&gt;<i> Modified:
</I>&gt;<i>    branches/ut/hlist/kernel/2.6/include/linux/can/af_can.h
</I>&gt;<i>    branches/ut/hlist/kernel/2.6/net/can/af_can.c
</I>&gt;<i>    branches/ut/hlist/kernel/2.6/net/can/bcm.c
</I>&gt;<i>    branches/ut/hlist/kernel/2.6/net/can/proc.c
</I>&gt;<i> Log:
</I>&gt;<i> Fixed procfs reading in bcm_read_proc().
</I>&gt;<i> Fixed hlist handling in can_rx_unregister() analog to can_rcv().
</I>&gt;<i> General: Gone crazy while making a code review for the hlist 
</I>&gt;<i> implementation.
</I>&gt;<i> All pointers where named p,q and all list /entries/ were named *_list so
</I>&gt;<i> i got confused as anything was *list and it was not understandable for me
</I>&gt;<i> (and i assume for others also). So i renamed structures and pointers to 
</I>&gt;<i> give
</I>&gt;<i> them 'more talking' names to understand the code at first sight.
</I>&gt;<i> Additionally added several comments.
</I>&gt;<i> TODO: Identified major performance problem on deleting receive list 
</I>&gt;<i> entries.
</I>&gt;<i> Terminating can-sniffer (which registers 2048 SFF entries) lasts about 
</I>&gt;<i> 25 secs!
</I>&gt;<i> You can watch the decreasing entries in /proc/net/can/stats (CRCV) ... :-(
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Modified: branches/ut/hlist/kernel/2.6/include/linux/can/af_can.h
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- branches/ut/hlist/kernel/2.6/include/linux/can/af_can.h     
</I>&gt;<i> 2006-08-30 12:46:15 UTC (rev 64)
</I>&gt;<i> +++ branches/ut/hlist/kernel/2.6/include/linux/can/af_can.h     
</I>&gt;<i> 2006-09-01 09:42:27 UTC (rev 65)
</I>&gt;<i> @@ -132,7 +132,7 @@
</I>&gt;<i>  
</I>&gt;<i>  /* af_can rx dispatcher structures */
</I>&gt;<i>  
</I>&gt;<i> -struct rcv_list {
</I>&gt;<i> +struct rcv_entry {
</I>&gt;<i>         struct hlist_node list;
</I>&gt;<i>         canid_t can_id;
</I>&gt;<i>         canid_t mask;
</I>&gt;<i> @@ -142,7 +142,7 @@
</I>&gt;<i>         char *ident;
</I>&gt;<i>  };
</I>&gt;<i>  
</I>&gt;<i> -struct rcv_dev_list {
</I>&gt;<i> +struct rcv_dev_entry {
</I>&gt;<i>         struct hlist_node list;
</I>&gt;<i>         struct net_device *dev;
</I>&gt;<i>         struct hlist_head rx_err;
</I>&gt;<i> 
</I>&gt;<i> Modified: branches/ut/hlist/kernel/2.6/net/can/af_can.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- branches/ut/hlist/kernel/2.6/net/can/af_can.c       2006-08-30 
</I>&gt;<i> 12:46:15 UTC (rev 64)
</I>&gt;<i> +++ branches/ut/hlist/kernel/2.6/net/can/af_can.c       2006-09-01 
</I>&gt;<i> 09:42:27 UTC (rev 65)
</I>&gt;<i> @@ -103,46 +103,60 @@
</I>&gt;<i>  static int can_rcv(struct sk_buff *skb, struct net_device *dev,
</I>&gt;<i>                    struct packet_type *pt);
</I>&gt;<i>  #endif
</I>&gt;<i> -static int can_rcv_filter(struct rcv_dev_list *q, struct sk_buff *skb);
</I>&gt;<i> +static int can_rcv_filter(struct rcv_dev_entry *rd, struct sk_buff *skb);
</I>&gt;<i>  static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,
</I>&gt;<i>                                         struct net_device *dev);
</I>&gt;<i>  
</I>&gt;<i> -struct notifier_list {
</I>&gt;<i> +/* notification for netdevice status changes */
</I>&gt;<i> +
</I>&gt;<i> +struct notifier_entry {
</I>&gt;<i>         struct list_head list;
</I>&gt;<i>         struct net_device *dev;
</I>&gt;<i>         void (*func)(unsigned long msg, void *data);
</I>&gt;<i>         void *data;
</I>&gt;<i>  };
</I>&gt;<i>  
</I>&gt;<i> -static LIST_HEAD(nlist);
</I>&gt;<i> +static LIST_HEAD(notifier_list);
</I>&gt;<i>  static rwlock_t notifier_lock = RW_LOCK_UNLOCKED;
</I>&gt;<i>  
</I>&gt;<i> -HLIST_HEAD(rx_dev_list);
</I>&gt;<i> -struct rcv_dev_list rx_alldev_list;
</I>&gt;<i> +/* receive lists for CAN-frame delivery to the CAN protocols */
</I>&gt;<i> +
</I>&gt;<i> +HLIST_HEAD(rx_dev_list); /* receive lists per device (ifindex != 0) */
</I>&gt;<i> +struct rcv_dev_entry rx_alldev_list; /* receive list reading all 
</I>&gt;<i> devices */
</I>&gt;<i>  static spinlock_t rcv_lists_lock  = SPIN_LOCK_UNLOCKED;
</I>&gt;<i>  
</I>&gt;<i> +/* for registering skbs received from CAN netdevices */
</I>&gt;<i> +
</I>&gt;<i>  static struct packet_type can_packet = {
</I>&gt;<i>         .type = __constant_htons(ETH_P_CAN),
</I>&gt;<i>         .dev  = NULL,
</I>&gt;<i>         .func = can_rcv,
</I>&gt;<i>  };
</I>&gt;<i>  
</I>&gt;<i> +/* for handle socket creations for PF_CAN sockets */
</I>&gt;<i> +
</I>&gt;<i>  static struct net_proto_family can_family_ops = {
</I>&gt;<i>         .family = PF_CAN,
</I>&gt;<i>         .create = can_create,
</I>&gt;<i>         .owner  = THIS_MODULE,
</I>&gt;<i>  };
</I>&gt;<i>  
</I>&gt;<i> +/* for handling of CAN netdevice status changes */
</I>&gt;<i> +
</I>&gt;<i>  static struct notifier_block can_netdev_notifier = {
</I>&gt;<i>         .notifier_call = can_notifier,
</I>&gt;<i>  };
</I>&gt;<i>  
</I>&gt;<i> +/* table of known/loaded CAN protocols inside PF_CAN */
</I>&gt;<i> +
</I>&gt;<i>  static struct can_proto *proto_tab[CAN_MAX];
</I>&gt;<i>  
</I>&gt;<i> -extern struct timer_list stattimer; /* timer for statistics update */
</I>&gt;<i> -extern struct s_stats  stats;       /* statistics */
</I>&gt;<i> -extern struct s_pstats pstats;
</I>&gt;<i> + /* statistics */
</I>&gt;<i>  
</I>&gt;<i> +extern struct timer_list stattimer; /* for cyclic updates */
</I>&gt;<i> +extern struct s_stats  stats;       /* packet statistics */
</I>&gt;<i> +extern struct s_pstats pstats;      /* receivelist statistics */
</I>&gt;<i> +
</I>&gt;<i>  module_init(can_init);
</I>&gt;<i>  module_exit(can_exit);
</I>&gt;<i>  
</I>&gt;<i> @@ -230,34 +244,34 @@
</I>&gt;<i>  void can_dev_register(struct net_device *dev,
</I>&gt;<i>                       void (*func)(unsigned long msg, void *), void *data)
</I>&gt;<i>  {
</I>&gt;<i> -       struct notifier_list *p = kmalloc(sizeof(*p), GFP_KERNEL);
</I>&gt;<i> +       struct notifier_entry *ne = kmalloc(sizeof(*ne), GFP_KERNEL);
</I>&gt;<i>  
</I>&gt;<i>         DBG(&quot;called for %s\n&quot;, dev-&gt;name);
</I>&gt;<i>  
</I>&gt;<i> -       if (!p)
</I>&gt;<i> +       if (!ne)
</I>&gt;<i>                 return;
</I>&gt;<i>  
</I>&gt;<i> -       p-&gt;dev  = dev;
</I>&gt;<i> -       p-&gt;func = func;
</I>&gt;<i> -       p-&gt;data = data;
</I>&gt;<i> +       ne-&gt;dev  = dev;
</I>&gt;<i> +       ne-&gt;func = func;
</I>&gt;<i> +       ne-&gt;data = data;
</I>&gt;<i>  
</I>&gt;<i>         write_lock(&amp;notifier_lock);
</I>&gt;<i> -       list_add(&amp;p-&gt;list, &amp;nlist);
</I>&gt;<i> +       list_add(&amp;ne-&gt;list, &amp;notifier_list);
</I>&gt;<i>         write_unlock(&amp;notifier_lock);
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i>  void can_dev_unregister(struct net_device *dev,
</I>&gt;<i>                         void (*func)(unsigned long msg, void *), void 
</I>&gt;<i> *data)
</I>&gt;<i>  {
</I>&gt;<i> -       struct notifier_list *p;
</I>&gt;<i> +       struct notifier_entry *ne, *safe;
</I>&gt;<i>  
</I>&gt;<i>         DBG(&quot;called for %s\n&quot;, dev-&gt;name);
</I>&gt;<i>  
</I>&gt;<i>         write_lock(&amp;notifier_lock);
</I>&gt;<i> -       list_for_each_entry (p, &amp;nlist, list) {
</I>&gt;<i> -               if (p-&gt;dev == dev &amp;&amp; p-&gt;func == func &amp;&amp; p-&gt;data == data) {
</I>&gt;<i> -                       list_del(&amp;p-&gt;list);
</I>&gt;<i> -                       kfree(p);
</I>&gt;<i> +       list_for_each_entry_safe(ne, safe, &amp;notifier_list, list) {
</I>&gt;<i> +               if (ne-&gt;dev == dev &amp;&amp; ne-&gt;func == func &amp;&amp; ne-&gt;data == 
</I>&gt;<i> data) {
</I>&gt;<i> +                       list_del(&amp;ne-&gt;list);
</I>&gt;<i> +                       kfree(ne);
</I>&gt;<i>                         break;
</I>&gt;<i>                 }
</I>&gt;<i>         }
</I>&gt;<i> @@ -395,14 +409,14 @@
</I>&gt;<i>                         unsigned long msg, void *data)
</I>&gt;<i>  {
</I>&gt;<i>         struct net_device *dev = (struct net_device *)data;
</I>&gt;<i> -       struct notifier_list *p;
</I>&gt;<i> +       struct notifier_entry *ne;
</I>&gt;<i>  
</I>&gt;<i>         DBG(&quot;called for %s, msg = %lu\n&quot;, dev-&gt;name, msg);
</I>&gt;<i>  
</I>&gt;<i>         read_lock(&amp;notifier_lock);
</I>&gt;<i> -       list_for_each_entry (p, &amp;nlist, list) {
</I>&gt;<i> -               if (p-&gt;dev == dev)
</I>&gt;<i> -                       p-&gt;func(msg, p-&gt;data);
</I>&gt;<i> +       list_for_each_entry (ne, &amp;notifier_list, list) {
</I>&gt;<i> +               if (ne-&gt;dev == dev)
</I>&gt;<i> +                       ne-&gt;func(msg, ne-&gt;data);
</I>&gt;<i>         }
</I>&gt;<i>         read_unlock(&amp;notifier_lock);
</I>&gt;<i>  
</I>&gt;<i> @@ -462,19 +476,19 @@
</I>&gt;<i>                      void (*func)(struct sk_buff *, void *), void *data,
</I>&gt;<i>                      char *ident)
</I>&gt;<i>  {
</I>&gt;<i> -       struct rcv_list *p;
</I>&gt;<i> -       struct hlist_head *q;
</I>&gt;<i> +       struct rcv_entry *re;
</I>&gt;<i> +       struct hlist_head *rcvlist;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i> -       struct rcv_dev_list *d;
</I>&gt;<i> +       struct rcv_dev_entry *rd = NULL;
</I>&gt;<i>  
</I>&gt;<i>         DBG(&quot;dev %p, id %03X, mask %03X, callback %p, data %p, ident
</I>%s\n&quot;,
&gt;<i>             dev, can_id, mask, func, data, ident);
</I>&gt;<i>  
</I>&gt;<i>         spin_lock(&amp;rcv_lists_lock);
</I>&gt;<i>  
</I>&gt;<i> -       q = find_rcv_list(&amp;can_id, &amp;mask, dev);
</I>&gt;<i> +       rcvlist = find_rcv_list(&amp;can_id, &amp;mask, dev);
</I>&gt;<i>  
</I>&gt;<i> -       if (!q) {
</I>&gt;<i> +       if (!rcvlist) {
</I>&gt;<i>                 printk(KERN_ERR &quot;CAN: receive list not found for &quot;
</I>&gt;<i>                        &quot;dev %s, id %03X, mask %03X, ident %s\n&quot;,
</I>&gt;<i>                        dev-&gt;name, can_id, mask, ident);
</I>&gt;<i> @@ -482,28 +496,27 @@
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i>         /* insert   (dev,canid,mask) -&gt; (func,data) */
</I>&gt;<i> -       if (!(p = kmalloc(sizeof(struct rcv_list), GFP_KERNEL)))
</I>&gt;<i> +       if (!(re = kmalloc(sizeof(struct rcv_entry), GFP_KERNEL)))
</I>&gt;<i>                 goto out;
</I>&gt;<i>  
</I>&gt;<i> -       p-&gt;can_id  = can_id;
</I>&gt;<i> -       p-&gt;mask    = mask;
</I>&gt;<i> -       p-&gt;matches = 0;
</I>&gt;<i> -       p-&gt;func    = func;
</I>&gt;<i> -       p-&gt;data    = data;
</I>&gt;<i> -       p-&gt;ident   = ident;
</I>&gt;<i> +       re-&gt;can_id  = can_id;
</I>&gt;<i> +       re-&gt;mask    = mask;
</I>&gt;<i> +       re-&gt;matches = 0;
</I>&gt;<i> +       re-&gt;func    = func;
</I>&gt;<i> +       re-&gt;data    = data;
</I>&gt;<i> +       re-&gt;ident   = ident;
</I>&gt;<i>  
</I>&gt;<i> -       hlist_add_head_rcu(&amp;p-&gt;list, q);
</I>&gt;<i> +       hlist_add_head_rcu(&amp;re-&gt;list, rcvlist);
</I>&gt;<i>  
</I>&gt;<i>         if (!dev)
</I>&gt;<i> -               d = &amp;rx_alldev_list;
</I>&gt;<i> -       else {
</I>&gt;<i> -               d = NULL;
</I>&gt;<i> -               hlist_for_each_entry(d, n, &amp;rx_dev_list, list)
</I>&gt;<i> -                       if (d-&gt;dev == dev)
</I>&gt;<i> +               rd = &amp;rx_alldev_list; /* for read 'all' devices only */
</I>&gt;<i> +       else
</I>&gt;<i> +               hlist_for_each_entry(rd, n, &amp;rx_dev_list, list)
</I>&gt;<i> +                       if (rd-&gt;dev == dev) /* one match is sure! */
</I>&gt;<i>                                 break;
</I>&gt;<i> -       }
</I>&gt;<i> -       d-&gt;entries++;
</I>&gt;<i>  
</I>&gt;<i> +       rd-&gt;entries++; /* entries for this/all device(s) */
</I>&gt;<i> +
</I>&gt;<i>         pstats.rcv_entries++;
</I>&gt;<i>         if (pstats.rcv_entries_max &lt; pstats.rcv_entries)
</I>&gt;<i>                 pstats.rcv_entries_max = pstats.rcv_entries;
</I>&gt;<i> @@ -515,62 +528,59 @@
</I>&gt;<i>  void can_rx_unregister(struct net_device *dev, canid_t can_id, canid_t 
</I>&gt;<i> mask,
</I>&gt;<i>                        void (*func)(struct sk_buff *, void *), void *data)
</I>&gt;<i>  {
</I>&gt;<i> -       struct rcv_list *p;
</I>&gt;<i> -       struct hlist_head *q;
</I>&gt;<i> +       struct rcv_entry *re = NULL;
</I>&gt;<i> +       struct hlist_head *rcvlist;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i> -       struct rcv_dev_list *d;
</I>&gt;<i> +       struct rcv_dev_entry *rd = NULL;
</I>&gt;<i>  
</I>&gt;<i>         DBG(&quot;dev %p, id %03X, mask %03X, callback %p, data %p\n&quot;,
</I>&gt;<i>             dev, can_id, mask, func, data);
</I>&gt;<i>  
</I>&gt;<i> -       p = NULL;
</I>&gt;<i> -
</I>&gt;<i>         spin_lock(&amp;rcv_lists_lock);
</I>&gt;<i>  
</I>&gt;<i> -       q = find_rcv_list(&amp;can_id, &amp;mask, dev);
</I>&gt;<i> +       rcvlist = find_rcv_list(&amp;can_id, &amp;mask, dev);
</I>&gt;<i>  
</I>&gt;<i> -       if (!q) {
</I>&gt;<i> +       if (!rcvlist) {
</I>&gt;<i>                 printk(KERN_ERR &quot;CAN: receive list not found for &quot;
</I>&gt;<i>                        &quot;dev %s, id %03X, mask %03X\n&quot;, dev-&gt;name, 
</I>&gt;<i> can_id, mask);
</I>&gt;<i>                 goto out;
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i> -       hlist_for_each_entry(p, n, q, list) {
</I>&gt;<i> -               if (p-&gt;can_id == can_id &amp;&amp; p-&gt;mask == mask
</I>&gt;<i> -                   &amp;&amp; p-&gt;func == func &amp;&amp; p-&gt;data == data)
</I>&gt;<i> +       hlist_for_each_entry(re, n, rcvlist, list) {
</I>&gt;<i> +               if (re-&gt;can_id == can_id &amp;&amp; re-&gt;mask == mask
</I>&gt;<i> +                   &amp;&amp; re-&gt;func == func &amp;&amp; re-&gt;data == data)
</I>&gt;<i>                         break;
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i> -       if (!p) {
</I>&gt;<i> +       if (!n) { /* why n?: see comment in can_rcv() */
</I>&gt;<i>                 printk(KERN_ERR &quot;CAN: receive list entry not found for &quot;
</I>&gt;<i>                        &quot;dev %s, id %03X, mask %03X\n&quot;, dev-&gt;name, 
</I>&gt;<i> can_id, mask);
</I>&gt;<i>                 goto out;
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i> -       hlist_del_rcu(&amp;p-&gt;list);
</I>&gt;<i> +       hlist_del_rcu(&amp;re-&gt;list);
</I>&gt;<i>  
</I>&gt;<i>         if (pstats.rcv_entries &gt; 0)
</I>&gt;<i>                 pstats.rcv_entries--;
</I>&gt;<i>  
</I>&gt;<i>         if (!dev)
</I>&gt;<i> -               d = &amp;rx_alldev_list;
</I>&gt;<i> -       else {
</I>&gt;<i> -               d = NULL;
</I>&gt;<i> -               hlist_for_each_entry(d, n, &amp;rx_dev_list, list)
</I>&gt;<i> -                       if (d-&gt;dev == dev)
</I>&gt;<i> +               rd = &amp;rx_alldev_list; /* for read 'all' devices only */
</I>&gt;<i> +       else
</I>&gt;<i> +               hlist_for_each_entry(rd, n, &amp;rx_dev_list, list)
</I>&gt;<i> +                       if (rd-&gt;dev == dev) /* one match is sure! */
</I>&gt;<i>                                 break;
</I>&gt;<i> -       }
</I>&gt;<i> -       d-&gt;entries--;
</I>&gt;<i>  
</I>&gt;<i> -       if (!d-&gt;entries)
</I>&gt;<i> -               d-&gt;dev = NULL; /* mark unused */
</I>&gt;<i> +       rd-&gt;entries--; /* entries for this/all device(s) */
</I>&gt;<i>  
</I>&gt;<i> +       if (!rd-&gt;entries)
</I>&gt;<i> +               rd-&gt;dev = NULL; /* mark this receive device entry unused
</I>*/
&gt;<i> +
</I>&gt;<i>   out:
</I>&gt;<i>         spin_unlock(&amp;rcv_lists_lock);
</I>&gt;<i>  
</I>&gt;<i> -       if (p) {
</I>&gt;<i> +       if (re) {
</I>&gt;<i>                 synchronize_rcu();
</I>&gt;<i> -               kfree(p);
</I>&gt;<i> +               kfree(re);
</I>&gt;<i>         }
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i> @@ -582,7 +592,7 @@
</I>&gt;<i>                    struct packet_type *pt)
</I>&gt;<i>  #endif
</I>&gt;<i>  {
</I>&gt;<i> -       struct rcv_dev_list *q;
</I>&gt;<i> +       struct rcv_dev_entry *rd;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i>         int matches;
</I>&gt;<i>  
</I>&gt;<i> @@ -598,6 +608,7 @@
</I>&gt;<i>  
</I>&gt;<i>         rcu_read_lock();
</I>&gt;<i>  
</I>&gt;<i> +       /* process listeners for 'all' CAN netdevices */
</I>&gt;<i>         matches = can_rcv_filter(&amp;rx_alldev_list, skb);
</I>&gt;<i>  
</I>&gt;<i>         /*  find receive list for this device
</I>&gt;<i> @@ -612,17 +623,18 @@
</I>&gt;<i>          *  cursor variable n to decide if a match was found.
</I>&gt;<i>          */
</I>&gt;<i>  
</I>&gt;<i> -       hlist_for_each_entry_rcu(q, n, &amp;rx_dev_list, list)
</I>&gt;<i> -               if (q-&gt;dev == dev)
</I>&gt;<i> +       hlist_for_each_entry_rcu(rd, n, &amp;rx_dev_list, list)
</I>&gt;<i> +               if (rd-&gt;dev == dev)
</I>&gt;<i>                         break;
</I>&gt;<i>  
</I>&gt;<i>         if (n)
</I>&gt;<i> -               matches += can_rcv_filter(q, skb);
</I>&gt;<i> +               matches += can_rcv_filter(rd, skb); /* process this 
</I>&gt;<i> device */
</I>&gt;<i>  
</I>&gt;<i>         rcu_read_unlock();
</I>&gt;<i>  
</I>&gt;<i> +       /* the skb may have been cloned or not due to rcv_entries */
</I>&gt;<i>         DBG(&quot;freeing skbuff %p\n&quot;, skb);
</I>&gt;<i> -       kfree_skb(skb);
</I>&gt;<i> +       kfree_skb(skb); /* remove original skb received from netdev */
</I>&gt;<i>  
</I>&gt;<i>         if (matches &gt; 0) {
</I>&gt;<i>                 stats.matches++;
</I>&gt;<i> @@ -633,33 +645,34 @@
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i>  
</I>&gt;<i> -static inline void deliver(struct sk_buff *skb, struct rcv_list *p)
</I>&gt;<i> +static inline void deliver(struct sk_buff *skb, struct rcv_entry *re)
</I>&gt;<i>  {
</I>&gt;<i>         struct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);
</I>&gt;<i>         DBG(&quot;skbuff %p cloned to %p\n&quot;, skb, clone);
</I>&gt;<i>         if (clone) {
</I>&gt;<i> -               p-&gt;func(clone, p-&gt;data);
</I>&gt;<i> -               p-&gt;matches++;    /* update specific statistics */
</I>&gt;<i> +               re-&gt;func(clone, re-&gt;data);
</I>&gt;<i> +               re-&gt;matches++;    /* update specific statistics */
</I>&gt;<i>         }
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i> -static int can_rcv_filter(struct rcv_dev_list *q, struct sk_buff *skb)
</I>&gt;<i> +/* process different filters for one specific CAN netdevice */
</I>&gt;<i> +static int can_rcv_filter(struct rcv_dev_entry *rd, struct sk_buff *skb)
</I>&gt;<i>  {
</I>&gt;<i> -       struct rcv_list *p;
</I>&gt;<i> +       struct rcv_entry *re;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i>         int matches = 0;
</I>&gt;<i>         struct can_frame *cf = (struct can_frame*)skb-&gt;data;
</I>&gt;<i>         canid_t can_id = cf-&gt;can_id;
</I>&gt;<i>  
</I>&gt;<i> -       if (q-&gt;entries == 0)
</I>&gt;<i> +       if (rd-&gt;entries == 0) /* relevant when processing rx_alldev_list
</I>*/
&gt;<i>                 return 0;
</I>&gt;<i>  
</I>&gt;<i>         if (can_id &amp; CAN_ERR_FLAG) {
</I>&gt;<i>                 /* check for error frame entries only */
</I>&gt;<i> -               hlist_for_each_entry_rcu(p, n, &amp;q-&gt;rx_err, list) {
</I>&gt;<i> -                       if (can_id &amp; p-&gt;mask) {
</I>&gt;<i> +               hlist_for_each_entry_rcu(re, n, &amp;rd-&gt;rx_err, list) {
</I>&gt;<i> +                       if (can_id &amp; re-&gt;mask) {
</I>&gt;<i>                                 DBG(&quot;match on rx_err skbuff %p\n&quot;, skb);
</I>&gt;<i> -                               deliver(skb, p);
</I>&gt;<i> +                               deliver(skb, re);
</I>&gt;<i>                                 matches++;
</I>&gt;<i>                         }
</I>&gt;<i>                 }
</I>&gt;<i> @@ -667,44 +680,44 @@
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i>         /* check for unfiltered entries */
</I>&gt;<i> -       hlist_for_each_entry_rcu(p, n, &amp;q-&gt;rx_all, list) {
</I>&gt;<i> +       hlist_for_each_entry_rcu(re, n, &amp;rd-&gt;rx_all, list) {
</I>&gt;<i>                 DBG(&quot;match on rx_all skbuff %p\n&quot;, skb);
</I>&gt;<i> -               deliver(skb, p);
</I>&gt;<i> +               deliver(skb, re);
</I>&gt;<i>                 matches++;
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i>         /* check for can_id/mask entries */
</I>&gt;<i> -       hlist_for_each_entry_rcu(p, n, &amp;q-&gt;rx_fil, list) {
</I>&gt;<i> -               if ((can_id &amp; p-&gt;mask) == p-&gt;can_id) {
</I>&gt;<i> +       hlist_for_each_entry_rcu(re, n, &amp;rd-&gt;rx_fil, list) {
</I>&gt;<i> +               if ((can_id &amp; re-&gt;mask) == re-&gt;can_id) {
</I>&gt;<i>                         DBG(&quot;match on rx_fil skbuff %p\n&quot;, skb);
</I>&gt;<i> -                       deliver(skb, p);
</I>&gt;<i> +                       deliver(skb, re);
</I>&gt;<i>                         matches++;
</I>&gt;<i>                 }
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i>         /* check for inverted can_id/mask entries */
</I>&gt;<i> -       hlist_for_each_entry_rcu(p, n, &amp;q-&gt;rx_inv, list) {
</I>&gt;<i> -               if ((can_id &amp; p-&gt;mask) != p-&gt;can_id) {
</I>&gt;<i> +       hlist_for_each_entry_rcu(re, n, &amp;rd-&gt;rx_inv, list) {
</I>&gt;<i> +               if ((can_id &amp; re-&gt;mask) != re-&gt;can_id) {
</I>&gt;<i>                         DBG(&quot;match on rx_inv skbuff %p\n&quot;, skb);
</I>&gt;<i> -                       deliver(skb, p);
</I>&gt;<i> +                       deliver(skb, re);
</I>&gt;<i>                         matches++;
</I>&gt;<i>                 }
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i>         /* check CAN_ID specific entries */
</I>&gt;<i>         if (can_id &amp; CAN_EFF_FLAG) {
</I>&gt;<i> -               hlist_for_each_entry_rcu(p, n, &amp;q-&gt;rx_eff, list) {
</I>&gt;<i> -                       if (p-&gt;can_id == can_id) {
</I>&gt;<i> +               hlist_for_each_entry_rcu(re, n, &amp;rd-&gt;rx_eff, list) {
</I>&gt;<i> +                       if (re-&gt;can_id == can_id) {
</I>&gt;<i>                                 DBG(&quot;match on rx_eff skbuff %p\n&quot;, skb);
</I>&gt;<i> -                               deliver(skb, p);
</I>&gt;<i> +                               deliver(skb, re);
</I>&gt;<i>                                 matches++;
</I>&gt;<i>                         }
</I>&gt;<i>                 }
</I>&gt;<i>         } else {
</I>&gt;<i>                 can_id &amp;= CAN_SFF_MASK;
</I>&gt;<i> -               hlist_for_each_entry_rcu(p, n, &amp;q-&gt;rx_sff[can_id], list) {
</I>&gt;<i> +               hlist_for_each_entry_rcu(re, n, &amp;rd-&gt;rx_sff[can_id], 
</I>&gt;<i> list) {
</I>&gt;<i>                         DBG(&quot;match on rx_sff skbuff %p\n&quot;, skb);
</I>&gt;<i> -                       deliver(skb, p);
</I>&gt;<i> +                       deliver(skb, re);
</I>&gt;<i>                         matches++;
</I>&gt;<i>                 }
</I>&gt;<i>         }
</I>&gt;<i> @@ -713,6 +726,8 @@
</I>&gt;<i>         return matches;
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i> +/* find for the wanted device the best matching receive list type 
</I>&gt;<i> inside */
</I>&gt;<i> +/* the associated receive device structure (see struct 
</I>&gt;<i> rcv_dev_entry)    */
</I>&gt;<i>  static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,
</I>&gt;<i>                                         struct net_device *dev)
</I>&gt;<i>  {
</I>&gt;<i> @@ -721,7 +736,7 @@
</I>&gt;<i>         canid_t rtr = *can_id &amp; *mask &amp; CAN_RTR_FLAG; /* correct RTR 
</I>&gt;<i> check? */
</I>&gt;<i>         canid_t err = *mask &amp; CAN_ERR_FLAG; /* mask for error frames 
</I>&gt;<i> only */
</I>&gt;<i>  
</I>&gt;<i> -       struct rcv_dev_list *p;
</I>&gt;<i> +       struct rcv_dev_entry *rd = NULL;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i>  
</I>&gt;<i>         /* make some paranoic operations */
</I>&gt;<i> @@ -734,29 +749,29 @@
</I>&gt;<i>  
</I>&gt;<i>         /* find receive list for this device */
</I>&gt;<i>         if (!dev)
</I>&gt;<i> -               p = &amp;rx_alldev_list;
</I>&gt;<i> +               rd = &amp;rx_alldev_list;
</I>&gt;<i>         else {
</I>&gt;<i>                 /* find the list for dev or an unused list entry, 
</I>&gt;<i> otherwise */
</I>&gt;<i> -               struct rcv_dev_list *q;
</I>&gt;<i> -               p = NULL;
</I>&gt;<i> +               struct rcv_dev_entry *q = NULL;
</I>&gt;<i> +
</I>&gt;<i>                 hlist_for_each_entry(q, n, &amp;rx_dev_list, list)
</I>&gt;<i>                         if (!q-&gt;dev)
</I>&gt;<i> -                               p = q;
</I>&gt;<i> +                               rd = q; /* reactivating: 2nd best choice
</I>*/
&gt;<i>                         else if (q-&gt;dev == dev) {
</I>&gt;<i> -                               p = q;
</I>&gt;<i> +                               rd = q; /* found device: best choice */
</I>&gt;<i>                                 break;
</I>&gt;<i>                         }
</I>&gt;<i>  
</I>&gt;<i> -               if (p &amp;&amp; !p-&gt;dev) {
</I>&gt;<i> -                       DBG(&quot;reactivating rcv_dev_list for %s\n&quot;, 
</I>&gt;<i> dev-&gt;name);
</I>&gt;<i> -                       p-&gt;dev = dev;
</I>&gt;<i> +               if (rd &amp;&amp; !rd-&gt;dev) {
</I>&gt;<i> +                       DBG(&quot;reactivating rcv_dev_entry for %s\n&quot;, 
</I>&gt;<i> dev-&gt;name);
</I>&gt;<i> +                       rd-&gt;dev = dev;
</I>&gt;<i>                 }
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i> -       if (!p) {
</I>&gt;<i> -               /* create new rcv_dev_list for this device */
</I>&gt;<i> -               DBG(&quot;creating new rcv_dev_list for %s\n&quot;, dev-&gt;name);
</I>&gt;<i> -               if (!(p = kmalloc(sizeof(struct rcv_dev_list), 
</I>&gt;<i> GFP_KERNEL))) {
</I>&gt;<i> +       if (!rd) {
</I>&gt;<i> +               /* create new rcv_dev_entry for this device */
</I>&gt;<i> +               DBG(&quot;creating new rcv_dev_entry for %s\n&quot;, dev-&gt;name);
</I>&gt;<i> +               if (!(rd = kmalloc(sizeof(struct rcv_dev_entry), 
</I>&gt;<i> GFP_KERNEL))) {
</I>&gt;<i>                         printk(KERN_ERR &quot;CAN: allocation of receive list 
</I>&gt;<i> failed\n&quot;);
</I>&gt;<i>                         return NULL;
</I>&gt;<i>                 }
</I>&gt;<i> @@ -764,33 +779,37 @@
</I>&gt;<i>                         for the embedded hlist_head structs.
</I>&gt;<i>                         Another list type, e.g. list_head, would require
</I>&gt;<i>                         explicit initialization. */
</I>&gt;<i> -               memset (p, 0, sizeof(struct rcv_dev_list));
</I>&gt;<i> +               memset (rd, 0, sizeof(struct rcv_dev_entry));
</I>&gt;<i>  
</I>&gt;<i> -               p-&gt;dev = dev;
</I>&gt;<i> -               hlist_add_head(&amp;p-&gt;list, &amp;rx_dev_list);
</I>&gt;<i> +               rd-&gt;dev = dev;
</I>&gt;<i> +               hlist_add_head(&amp;rd-&gt;list, &amp;rx_dev_list);
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i>         if (err) /* error frames */
</I>&gt;<i> -               return &amp;p-&gt;rx_err;
</I>&gt;<i> +               return &amp;rd-&gt;rx_err;
</I>&gt;<i>  
</I>&gt;<i>         if (inv) /* inverse can_id/can_mask filter and RTR */
</I>&gt;<i> -               return &amp;p-&gt;rx_inv;
</I>&gt;<i> +               return &amp;rd-&gt;rx_inv;
</I>&gt;<i>  
</I>&gt;<i>         if (*can_id &amp; CAN_RTR_FLAG) /* positive filter RTR */
</I>&gt;<i> -               return &amp;p-&gt;rx_fil;
</I>&gt;<i> +               return &amp;rd-&gt;rx_fil;
</I>&gt;<i>  
</I>&gt;<i>         if (!(*mask)) /* mask == 0 =&gt; no filter */
</I>&gt;<i> -               return &amp;p-&gt;rx_all;
</I>&gt;<i> +               return &amp;rd-&gt;rx_all;
</I>&gt;<i>  
</I>&gt;<i>         if (*can_id &amp; CAN_EFF_FLAG) {
</I>&gt;<i>                 if (*mask == CAN_EFF_MASK) /* filter exact EFF can_id */
</I>&gt;<i> -                       return &amp;p-&gt;rx_eff;
</I>&gt;<i> +                       return &amp;rd-&gt;rx_eff;
</I>&gt;<i> +               /* remark: This is only a simple linear list and not a
</I>*/
&gt;<i> +               /* 'fast access' sollution like for SFF-frames (below).
</I>*/
&gt;<i> +               /* A hash table would be suggested here, if anyone needs
</I>*/
&gt;<i> +               /* to access lots of single exact EFF frames. O.Hartkopp
</I>*/
&gt;<i>         } else {
</I>&gt;<i>                 if (*mask == CAN_SFF_MASK) /* filter exact SFF can_id */
</I>&gt;<i> -                       return &amp;p-&gt;rx_sff[*can_id];
</I>&gt;<i> +                       return &amp;rd-&gt;rx_sff[*can_id];
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i> -       return &amp;p-&gt;rx_fil;  /* filter via can_id/can_mask */
</I>&gt;<i> +       return &amp;rd-&gt;rx_fil;  /* default: filter via can_id/can_mask */
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i>  /**************************************************/
</I>&gt;<i> 
</I>&gt;<i> Modified: branches/ut/hlist/kernel/2.6/net/can/bcm.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- branches/ut/hlist/kernel/2.6/net/can/bcm.c  2006-08-30 12:46:15 UTC 
</I>&gt;<i> (rev 64)
</I>&gt;<i> +++ branches/ut/hlist/kernel/2.6/net/can/bcm.c  2006-09-01 09:42:27 UTC 
</I>&gt;<i> (rev 65)
</I>&gt;<i> @@ -375,12 +375,6 @@
</I>&gt;<i>  
</I>&gt;<i>                 unsigned long reduction;
</I>&gt;<i>  
</I>&gt;<i> -               if (len &gt;= PAGE_SIZE - 100) {
</I>&gt;<i> -                       /* mark output cut off */
</I>&gt;<i> -                       len += snprintf(page + len, PAGE_SIZE - len, 
</I>&gt;<i> &quot;(..)\n&quot;);
</I>&gt;<i> -                       break;
</I>&gt;<i> -               }
</I>&gt;<i> -
</I>&gt;<i>                 /* print only active entries &amp; prevent division by zero */
</I>&gt;<i>                 if (!op-&gt;frames_abs)
</I>&gt;<i>                         continue;
</I>&gt;<i> @@ -400,16 +394,16 @@
</I>&gt;<i>  
</I>&gt;<i>                 len += snprintf(page + len, PAGE_SIZE - len, &quot;%s%ld%%\n&quot;,
</I>&gt;<i>                                 (reduction == 100)?&quot;near &quot;:&quot;&quot;, reduction);
</I>&gt;<i> -       }
</I>&gt;<i>  
</I>&gt;<i> -       list_for_each_entry(op, &amp;ud-&gt;tx_ops, list) {
</I>&gt;<i> -
</I>&gt;<i>                 if (len &gt;= PAGE_SIZE - 100) {
</I>&gt;<i>                         /* mark output cut off */
</I>&gt;<i>                         len += snprintf(page + len, PAGE_SIZE - len, 
</I>&gt;<i> &quot;(..)\n&quot;);
</I>&gt;<i>                         break;
</I>&gt;<i> -               }
</I>&gt;<i> +               }
</I>&gt;<i> +       }
</I>&gt;<i>  
</I>&gt;<i> +       list_for_each_entry(op, &amp;ud-&gt;tx_ops, list) {
</I>&gt;<i> +
</I>&gt;<i>                 len += snprintf(page + len, PAGE_SIZE - len, &quot;tx_op: 
</I>&gt;<i> %03X [%d] &quot;,
</I>&gt;<i>                                 op-&gt;can_id, op-&gt;nframes);
</I>&gt;<i>                 if (op-&gt;j_ival1)
</I>&gt;<i> @@ -419,6 +413,12 @@
</I>&gt;<i>                         len += snprintf(page + len, PAGE_SIZE - len, 
</I>&gt;<i> &quot;t2=%ld &quot;, op-&gt;j_ival2);
</I>&gt;<i>  
</I>&gt;<i>                 len += snprintf(page + len, PAGE_SIZE - len, &quot;# sent 
</I>&gt;<i> %ld\n&quot;, op-&gt;frames_abs);
</I>&gt;<i> +
</I>&gt;<i> +               if (len &gt;= PAGE_SIZE - 100) {
</I>&gt;<i> +                       /* mark output cut off */
</I>&gt;<i> +                       len += snprintf(page + len, PAGE_SIZE - len, 
</I>&gt;<i> &quot;(..)\n&quot;);
</I>&gt;<i> +                       break;
</I>&gt;<i> +               }
</I>&gt;<i>         }
</I>&gt;<i>  
</I>&gt;<i>         len += snprintf(page + len, PAGE_SIZE - len, &quot;\n&quot;);
</I>&gt;<i> @@ -1335,34 +1335,34 @@
</I>&gt;<i>  
</I>&gt;<i>  static struct bcm_op *bcm_find_op(struct list_head *ops, canid_t can_id)
</I>&gt;<i>  {
</I>&gt;<i> -       struct bcm_op *p;
</I>&gt;<i> +       struct bcm_op *op;
</I>&gt;<i>  
</I>&gt;<i> -       list_for_each_entry(p, ops, list)
</I>&gt;<i> -               if (p-&gt;can_id == can_id)
</I>&gt;<i> -                       return p;
</I>&gt;<i> +       list_for_each_entry(op, ops, list)
</I>&gt;<i> +               if (op-&gt;can_id == can_id)
</I>&gt;<i> +                       return op;
</I>&gt;<i>  
</I>&gt;<i>         return NULL;
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i>  static void bcm_delete_rx_op(struct list_head *ops, canid_t can_id)
</I>&gt;<i>  {
</I>&gt;<i> -       struct bcm_op *p, *n;
</I>&gt;<i> +       struct bcm_op *op, *n;
</I>&gt;<i>  
</I>&gt;<i> -       list_for_each_entry_safe(p, n, ops, list) {
</I>&gt;<i> -               if (p-&gt;can_id == can_id) {
</I>&gt;<i> -                       DBG(&quot;removing rx_op (%p) for can_id &lt;%03X&gt;\n&quot;, 
</I>&gt;<i> p, p-&gt;can_id);
</I>&gt;<i> +       list_for_each_entry_safe(op, n, ops, list) {
</I>&gt;<i> +               if (op-&gt;can_id == can_id) {
</I>&gt;<i> +                       DBG(&quot;removing rx_op (%p) for can_id &lt;%03X&gt;\n&quot;, 
</I>&gt;<i> op, op-&gt;can_id);
</I>&gt;<i>  
</I>&gt;<i> -                       if (p-&gt;sk-&gt;sk_bound_dev_if) {
</I>&gt;<i> -                               struct net_device *dev = 
</I>&gt;<i> dev_get_by_index(p-&gt;sk-&gt;sk_bound_dev_if);
</I>&gt;<i> +                       if (op-&gt;sk-&gt;sk_bound_dev_if) {
</I>&gt;<i> +                               struct net_device *dev = 
</I>&gt;<i> dev_get_by_index(op-&gt;sk-&gt;sk_bound_dev_if);
</I>&gt;<i>                                 if (dev) {
</I>&gt;<i> -                                       can_rx_unregister(dev, 
</I>&gt;<i> p-&gt;can_id, BCM_RX_REGMASK, bcm_rx_handler, p);
</I>&gt;<i> +                                       can_rx_unregister(dev, 
</I>&gt;<i> op-&gt;can_id, BCM_RX_REGMASK, bcm_rx_handler, op);
</I>&gt;<i>                                         dev_put(dev);
</I>&gt;<i>                                 }
</I>&gt;<i>                         } else
</I>&gt;<i> -                               DBG(&quot;sock %p not bound for 
</I>&gt;<i> can_rx_unregister()\n&quot;, p-&gt;sk);
</I>&gt;<i> +                               DBG(&quot;sock %p not bound for 
</I>&gt;<i> can_rx_unregister()\n&quot;, op-&gt;sk);
</I>&gt;<i>  
</I>&gt;<i> -                       list_del(&amp;p-&gt;list);
</I>&gt;<i> -                       bcm_remove_op(p);
</I>&gt;<i> +                       list_del(&amp;op-&gt;list);
</I>&gt;<i> +                       bcm_remove_op(op);
</I>&gt;<i>                         return;
</I>&gt;<i>                 }
</I>&gt;<i>         }
</I>&gt;<i> @@ -1370,14 +1370,14 @@
</I>&gt;<i>  
</I>&gt;<i>  static void bcm_delete_tx_op(struct list_head *ops, canid_t can_id)
</I>&gt;<i>  {
</I>&gt;<i> -       struct bcm_op *p, *n;
</I>&gt;<i> +       struct bcm_op *op, *n;
</I>&gt;<i>  
</I>&gt;<i> -       list_for_each_entry_safe(p, n, ops, list) {
</I>&gt;<i> -               if (p-&gt;can_id == can_id) {
</I>&gt;<i> +       list_for_each_entry_safe(op, n, ops, list) {
</I>&gt;<i> +               if (op-&gt;can_id == can_id) {
</I>&gt;<i>                         DBG(&quot;removing rx_op (%p) for can_id &lt;%03X&gt;\n&quot;,
</I>&gt;<i> -                           p, p-&gt;can_id);
</I>&gt;<i> -                       list_del(&amp;p-&gt;list);
</I>&gt;<i> -                       bcm_remove_op(p);
</I>&gt;<i> +                           op, op-&gt;can_id);
</I>&gt;<i> +                       list_del(&amp;op-&gt;list);
</I>&gt;<i> +                       bcm_remove_op(op);
</I>&gt;<i>                         return;
</I>&gt;<i>                 }
</I>&gt;<i>         }
</I>&gt;<i> 
</I>&gt;<i> Modified: branches/ut/hlist/kernel/2.6/net/can/proc.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- branches/ut/hlist/kernel/2.6/net/can/proc.c 2006-08-30 12:46:15 UTC 
</I>&gt;<i> (rev 64)
</I>&gt;<i> +++ branches/ut/hlist/kernel/2.6/net/can/proc.c 2006-09-01 09:42:27 UTC 
</I>&gt;<i> (rev 65)
</I>&gt;<i> @@ -202,7 +202,7 @@
</I>&gt;<i>  static int can_print_recv_list(char *page, int len, struct hlist_head 
</I>&gt;<i> *rx_list,
</I>&gt;<i>                                struct net_device *dev)
</I>&gt;<i>  {
</I>&gt;<i> -       struct rcv_list *p;
</I>&gt;<i> +       struct rcv_entry *p;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i>  
</I>&gt;<i>         rcu_read_lock();
</I>&gt;<i> @@ -344,7 +344,7 @@
</I>&gt;<i>                                      int count, int *eof, void *data)
</I>&gt;<i>  {
</I>&gt;<i>         int len = 0;
</I>&gt;<i> -       struct rcv_dev_list *p;
</I>&gt;<i> +       struct rcv_dev_entry *p;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i>  
</I>&gt;<i>         /* RX_ALL */
</I>&gt;<i> @@ -374,7 +374,7 @@
</I>&gt;<i>                                      int count, int *eof, void *data)
</I>&gt;<i>  {
</I>&gt;<i>         int len = 0;
</I>&gt;<i> -       struct rcv_dev_list *p;
</I>&gt;<i> +       struct rcv_dev_entry *p;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i>  
</I>&gt;<i>         /* RX_FIL */
</I>&gt;<i> @@ -404,7 +404,7 @@
</I>&gt;<i>                                      int count, int *eof, void *data)
</I>&gt;<i>  {
</I>&gt;<i>         int len = 0;
</I>&gt;<i> -       struct rcv_dev_list *p;
</I>&gt;<i> +       struct rcv_dev_entry *p;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i>  
</I>&gt;<i>         /* RX_INV */
</I>&gt;<i> @@ -434,7 +434,7 @@
</I>&gt;<i>                                      int count, int *eof, void *data)
</I>&gt;<i>  {
</I>&gt;<i>         int len = 0;
</I>&gt;<i> -       struct rcv_dev_list *p;
</I>&gt;<i> +       struct rcv_dev_entry *p;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i>  
</I>&gt;<i>         /* RX_SFF */
</I>&gt;<i> @@ -474,7 +474,7 @@
</I>&gt;<i>                                      int count, int *eof, void *data)
</I>&gt;<i>  {
</I>&gt;<i>         int len = 0;
</I>&gt;<i> -       struct rcv_dev_list *p;
</I>&gt;<i> +       struct rcv_dev_entry *p;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i>  
</I>&gt;<i>         /* RX_EFF */
</I>&gt;<i> @@ -504,7 +504,7 @@
</I>&gt;<i>                                      int count, int *eof, void *data)
</I>&gt;<i>  {
</I>&gt;<i>         int len = 0;
</I>&gt;<i> -       struct rcv_dev_list *p;
</I>&gt;<i> +       struct rcv_dev_entry *p;
</I>&gt;<i>         struct hlist_node *n;
</I>&gt;<i>  
</I>&gt;<i>         /* RX_ERR */
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Socketcan-commit mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">Socketcan-commit at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-commit">https://lists.berlios.de/mailman/listinfo/socketcan-commit</A>
</I>&gt;<i> 
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000044.html">r65 - in branches/ut/hlist/kernel/2.6: include/linux/can net/can
</A></li>
	<LI>Next message: <A HREF="000046.html">r66 - in branches/ut/hlist/kernel/2.6: include/linux/can net/can
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45">[ date ]</a>
              <a href="thread.html#45">[ thread ]</a>
              <a href="subject.html#45">[ subject ]</a>
              <a href="author.html#45">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-commit">More information about the Socketcan-commit
mailing list</a><br>
</body></html>
